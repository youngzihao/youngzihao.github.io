<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> ARKit · Feng Shui</title><meta name="description" content="ARKit - null"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Feng Shui"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.svg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/youngzihao" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">ARKit</h1><div class="post-info">Jul 24, 2018</div><div class="post-content"><blockquote>
<p>Collected by 《ARKit by Tutorials》</p>
</blockquote>
<h1 id="Basic-Session-Management"><a href="#Basic-Session-Management" class="headerlink" title="Basic Session Management"></a>Basic Session Management</h1><h2 id="Starting-an-AR-Session"><a href="#Starting-an-AR-Session" class="headerlink" title="Starting an AR Session"></a>Starting an AR Session</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func initARSession() &#123;</span><br><span class="line">    // - Checking device capabilities</span><br><span class="line">    guard ARWorldTrackingConfiguration.isSupported else &#123;</span><br><span class="line">        print(&quot;AR World Tracking Not Supported&quot;)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // - Creating the configuration</span><br><span class="line">    let config = ARWorldTrackingConfiguration()</span><br><span class="line">    config.worldAlignment = .gravity</span><br><span class="line">    config.providesAudioData = false</span><br><span class="line">    </span><br><span class="line">    // - Running the session</span><br><span class="line">    sceneView.session.run(config)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Updating-the-status-message"><a href="#Updating-the-status-message" class="headerlink" title="Updating the status message"></a>Updating the status message</h2><p><code>var trackingStatus: String = &quot;&quot;</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func renderer(_ renderer: SCNSceneRenderer, updateAtTime time: TimeInterval) &#123;</span><br><span class="line">   DispatchQueue.main.async &#123;</span><br><span class="line">     self.statusLabel.text = self.trackingStatus</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Handling-AR-session-errors"><a href="#Handling-AR-session-errors" class="headerlink" title="Handling AR session errors"></a>Handling AR session errors</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func session(_ session: ARSession, didFailWithError error: Error) &#123;</span><br><span class="line">  trackingStatus = &quot;AR Session Failure: \(error)&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func sessionWasInterrupted(_ session: ARSession) &#123;</span><br><span class="line">  trackingStatus = &quot;AR Session Was Interrupted!&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func sessionInterruptionEnded(_ session: ARSession) &#123;</span><br><span class="line">  trackingStatus = &quot;AR Session Interruption Ended&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Handling-AR-session-state-changes"><a href="#Handling-AR-session-state-changes" class="headerlink" title="Handling AR session state changes"></a>Handling AR session state changes</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">func session(_ session: ARSession, cameraDidChangeTrackingState camera: ARCamera) &#123;</span><br><span class="line">    switch camera.trackingState &#123;</span><br><span class="line">    case .notAvailable:</span><br><span class="line">      self.trackingStatus = &quot;Tacking:  Not available!&quot;</span><br><span class="line">      break</span><br><span class="line">    case .normal:</span><br><span class="line">      self.trackingStatus = &quot;Tracking: All Good!&quot;</span><br><span class="line">      break</span><br><span class="line">    case .limited(let reason):</span><br><span class="line">      switch reason &#123;</span><br><span class="line">      case .excessiveMotion:</span><br><span class="line">        self.trackingStatus = &quot;Tracking: Limited due to excessive motion!&quot;</span><br><span class="line">        break</span><br><span class="line">      case .insufficientFeatures:</span><br><span class="line">        self.trackingStatus = &quot;Tracking: Limited due to insufficient features!&quot;</span><br><span class="line">        break</span><br><span class="line">      case .relocalizing:</span><br><span class="line">        self.trackingStatus = &quot;Tracking: Relocalizing...&quot;</span><br><span class="line">        break</span><br><span class="line">      case .initializing:</span><br><span class="line">        self.trackingStatus = &quot;Tracking: Initializing...&quot;</span><br><span class="line">        break</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Showing-debug-options"><a href="#Showing-debug-options" class="headerlink" title="Showing debug options"></a>Showing debug options</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sceneView.debugOptions = [</span><br><span class="line">      ARSCNDebugOptions.showFeaturePoints,</span><br><span class="line">      ARSCNDebugOptions.showWorldOrigin,</span><br><span class="line">      SCNDebugOptions.showBoundingBoxes,</span><br><span class="line">      SCNDebugOptions.showWireframe</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>
<h1 id="Loading-3D-objects"><a href="#Loading-3D-objects" class="headerlink" title="Loading 3D objects"></a>Loading 3D objects</h1><h2 id="Configuring-an-empty-scene"><a href="#Configuring-an-empty-scene" class="headerlink" title="Configuring an empty scene"></a>Configuring an empty scene</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func initScene() &#123;</span><br><span class="line">    // - Creating an empty scene</span><br><span class="line">    let scene = SCNScene()</span><br><span class="line">    </span><br><span class="line">    // - Loading the environment map</span><br><span class="line">    scene.lightingEnvironment.contents = &quot;PokerDice.scnassets/Textures/Environment_CUBE.jpg&quot;</span><br><span class="line">    scene.lightingEnvironment.intensity = 2</span><br><span class="line">    </span><br><span class="line">    scene.isPaused = false</span><br><span class="line">    sceneView.scene = scene</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Loading-the-3D-objects"><a href="#Loading-the-3D-objects" class="headerlink" title="Loading the 3D objects"></a>Loading the 3D objects</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var diceNodes: [SCNNode] = []</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func loadModels() &#123;    </span><br><span class="line">  let diceScene = SCNScene(named: &quot;PokerDice.scnassets/Models/DiceScene.scn&quot;)!</span><br><span class="line">  for count in 0..&lt;5 &#123;</span><br><span class="line">    diceNodes.append(diceScene.rootNode.childNode(withName: &quot;dice\(count)&quot;, recursively: false)!)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>viewDidLoad():</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.loadModels()</span><br></pre></td></tr></table></figure>
<h2 id="Placing-3D-objects"><a href="#Placing-3D-objects" class="headerlink" title="Placing 3D objects"></a>Placing 3D objects</h2><ul>
<li>The dice nodes are loaded and ready to be placed into the AR scene.<br>Start off by adding some helper functions and properties that will clone dice nodes into the AR scene.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// - A counter that indicates the number of dice in your hand.</span><br><span class="line">var diceCount: Int = 5</span><br><span class="line"></span><br><span class="line">// - A simple index that you’ll use to switch between the various styled dice.</span><br><span class="line">var diceStyle: Int = 0</span><br><span class="line"></span><br><span class="line">// - An array of various position offsets to make the action more realistic.</span><br><span class="line">var diceOffset: [SCNVector3] = [SCNVector3(0.0,0.0,0.0), </span><br><span class="line">SCNVector3(-0.05, 0.00, 0.0), </span><br><span class="line">SCNVector3(0.05, 0.00, 0.0), </span><br><span class="line">SCNVector3(-0.05, 0.05, 0.02), </span><br><span class="line">SCNVector3(0.05, 0.05, 0.02)]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func throwDiceNode(transform: SCNMatrix4, offset: SCNVector3) &#123;</span><br><span class="line">  // - This creates an offset position by combining the provided transform’s positional data </span><br><span class="line">  with the vector that was passed into the function.</span><br><span class="line">  let position = SCNVector3(transform.m41 + offset.x,</span><br><span class="line">    transform.m42 + offset.y,</span><br><span class="line">    transform.m43 + offset.z)</span><br><span class="line">    </span><br><span class="line">  // - This creates a clone of the selected dice node, renames it to &quot;dice&quot;, and sets its position.</span><br><span class="line">  let diceNode = diceNodes[diceStyle].clone()</span><br><span class="line">  diceNode.name = &quot;dice&quot;</span><br><span class="line">  diceNode.position = position</span><br><span class="line">  </span><br><span class="line">  // - the newly cloned dice node is placed into the AR scene, and diceCount is decremented to indicate that a die has left the players hand.</span><br><span class="line">  sceneView.scene.rootNode.addChildNode(diceNode)</span><br><span class="line">  diceCount -= 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Adding-a-swipe-gesture"><a href="#Adding-a-swipe-gesture" class="headerlink" title="Adding a swipe gesture"></a>Adding a swipe gesture</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@IBAction func swipeUpGestureHandler(_ sender: Any) &#123;</span><br><span class="line">	 // - currentFrame is an ARFrame object associated with the AR scene. It</span><br><span class="line">	  contains the most recently captured video frame image (capturedImage), </span><br><span class="line">	  along with other things like the captured depth data, the AR camera, the</span><br><span class="line">	  currently estimated light, anchors and feature points. This line of code</span><br><span class="line">	  simply ensures that there’s a valid frame available.</span><br><span class="line">    guard let frame = self.sceneView.session.currentFrame else &#123; return &#125;</span><br><span class="line">    </span><br><span class="line">    // - This part iterates through the five dice, throwing a single die each </span><br><span class="line">    time into the AR scene using the AR camera’s transform matrix, which</span><br><span class="line">    contains information about the camera’s position and rotation. Ultimately,</span><br><span class="line">    the for loop will throw all the available dice in your hand into the AR </span><br><span class="line">    scene.   </span><br><span class="line">    for count in 0..&lt;diceCount &#123;</span><br><span class="line">      throwDiceNode(transform: SCNMatrix4(frame.camera.transform),</span><br><span class="line">                    offset: diceOffset[count])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Changing-dice-styles"><a href="#Changing-dice-styles" class="headerlink" title="Changing dice styles"></a>Changing dice styles</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@IBAction func styleButtonPressed(_ sender: Any) &#123;</span><br><span class="line">    diceStyle = diceStyle &gt;= 4 ? 0 : diceStyle + 1</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h1 id="Detecting-Surfaces"><a href="#Detecting-Surfaces" class="headerlink" title="Detecting Surfaces"></a>Detecting Surfaces</h1><h2 id="Creating-new-planes"><a href="#Creating-new-planes" class="headerlink" title="Creating new planes"></a>Creating new planes</h2><ul>
<li>Getting ARKit to detect real-world surfaces requires enabling a flag within the ARConfiguration object. ARKit will now start detecting horizontal surfaces and automatically generate ARPlaneAnchor instances for every detected surface.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let config = ARWorldTrackingConfiguration()</span><br><span class="line">config.planeDetection = .horizontal</span><br></pre></td></tr></table></figure>
<ul>
<li>Creating new planes</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func createARPlaneNode(planeAnchor: ARPlaneAnchor, color: UIColor) -&gt; SCNNode &#123;</span><br><span class="line">    // 1 - Create plane geometry using anchor extents</span><br><span class="line">    let planeGeometry = SCNPlane(width: CGFloat(planeAnchor.extent.x),</span><br><span class="line">                                 height: CGFloat(planeAnchor.extent.z))</span><br><span class="line">                                 </span><br><span class="line">    // 2 - Create meterial with just a diffuse color</span><br><span class="line">    let planeMaterial = SCNMaterial()</span><br><span class="line">    planeMaterial.diffuse.contents = &quot;PokerDice.scnassets/Textures/Surface_DIFFUSE.png&quot; //color</span><br><span class="line">    planeGeometry.materials = [planeMaterial]</span><br><span class="line"></span><br><span class="line">    // 3 - Create plane node</span><br><span class="line">    let planeNode = SCNNode(geometry: planeGeometry)</span><br><span class="line">    planeNode.position = SCNVector3Make(planeAnchor.center.x, 0, planeAnchor.center.z)</span><br><span class="line">    planeNode.transform = SCNMatrix4MakeRotation(-Float.pi / 2, 1, 0, 0)</span><br><span class="line">    return planeNode</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>With plane detection activated, ARKit will automatically start creating ARPlaneAnchors for every horizontal surface it detects. A corresponding renderer(_:didAdd:for) delegate will be called to inform you of newly-added anchors. All you need to do is wait for the event to trigger and create a corresponding SceneKit plane for the anchor.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func renderer(_ renderer: SCNSceneRenderer, didAdd node: SCNNode, for anchor: ARAnchor) &#123;</span><br><span class="line">	guard let planeAnchor = anchor as? ARPlaneAnchor else &#123; return &#125;</span><br><span class="line">	DispatchQueue.main.async &#123;</span><br><span class="line">		let planeNode = self.createARPlaneNode(planeAnchor: planeAnchor, color: UIColor.yellow.withAlphaComponent(0.5))</span><br><span class="line">		node.addChildNode(planeNode)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Updating-planes"><a href="#Updating-planes" class="headerlink" title="Updating planes"></a>Updating planes</h2><ul>
<li>ARKit might not have detected the entire surface at first, so you may need to update the previously detected plane with new information as the player moves around.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func updateARPlaneNode(planeNode: SCNNode, planeAchor: ARPlaneAnchor) &#123;</span><br><span class="line">    // 1 - Update plane geometry with planeAnchor details</span><br><span class="line">    let planeGeometry = planeNode.geometry as! SCNPlane</span><br><span class="line">    planeGeometry.width = CGFloat(planeAchor.extent.x)</span><br><span class="line">    planeGeometry.height = CGFloat(planeAchor.extent.z)</span><br><span class="line"></span><br><span class="line">    // 2 - Update plane position</span><br><span class="line">    planeNode.position = SCNVector3Make(planeAchor.center.x, 0, planeAchor.center.z)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Handling plane anchor updates</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func renderer(_ renderer: SCNSceneRenderer, didUpdate node: SCNNode, for anchor: ARAnchor) &#123;</span><br><span class="line">guard let planeAnchor = anchor as? ARPlaneAnchor else &#123; return &#125;</span><br><span class="line">	DispatchQueue.main.async &#123;</span><br><span class="line">		self.updateARPlaneNode(planeNode: node.childNodes[0], planeAchor: planeAnchor)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Creating-a-focus-node"><a href="#Creating-a-focus-node" class="headerlink" title="Creating a focus node"></a>Creating a focus node</h1><h2 id="Creating-the-focus-point"><a href="#Creating-the-focus-point" class="headerlink" title="Creating the focus point"></a>Creating the focus point</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// - Create a property to hold this screen position.</span><br><span class="line">var focusPoint:CGPoint!</span><br><span class="line"></span><br><span class="line">// - Initialize the position</span><br><span class="line">focusPoint = CGPoint(x: view.center.x, y: view.center.y + view.center.y * 0.25)</span><br></pre></td></tr></table></figure>
<h2 id="Handling-orientation-changes"><a href="#Handling-orientation-changes" class="headerlink" title="Handling orientation changes"></a>Handling orientation changes</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@objc func orientationChanged() &#123;focusPoint = CGPoint(x: view.center.x, y: view.center.y + view.center.y * 0.25)&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NotificationCenter.default.addObserver(self, selector: #selector(ViewController.orientationChanged), name: NSNotification.Name.UIDeviceOrientationDidChange, object: nil)</span><br></pre></td></tr></table></figure>
<h2 id="Updating-the-focus-node"><a href="#Updating-the-focus-node" class="headerlink" title="Updating the focus node"></a>Updating the focus node</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">func updateFocusNode() &#123;</span><br><span class="line">  // - Performs a ray cast test. </span><br><span class="line">  let results = self.sceneView.hitTest(self.focusPoint, </span><br><span class="line">    types: [.existingPlaneUsingExtent])</span><br><span class="line">    </span><br><span class="line">  // - Looking for the first hit result. Once found update the focus node.</span><br><span class="line">  if results.count == 1 &#123;</span><br><span class="line">    if let match = results.first &#123;</span><br><span class="line">    </span><br><span class="line">      // - Using the hit result’s worldTransform, a matrix containing position,</span><br><span class="line">      orientation and scaling information.</span><br><span class="line">      let t = match.worldTransform</span><br><span class="line">      </span><br><span class="line">     // - Updating the focus node’s position based on the hit result transform </span><br><span class="line">     matrix. The position information can be found in the third column of the </span><br><span class="line">     transform matrix.</span><br><span class="line">      self.focusNode.position = SCNVector3( x: t.columns.3.x, y: t.columns.3.y,</span><br><span class="line">      z: t.columns.3.z)</span><br><span class="line">      self.gameState = .swipeToPlay</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">  </span><br><span class="line">    // - If no hit results were found, the game should continue to instruct the </span><br><span class="line">    player to point towards a detected surface.</span><br><span class="line">    self.gameState = .pointToSurface</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>renderer(_:updateAtTime):</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.updateFocusNode()</span><br></pre></td></tr></table></figure>
<h1 id="Adding-physics"><a href="#Adding-physics" class="headerlink" title="Adding physics"></a>Adding physics</h1><h2 id="Controlling-the-physics-world-speed"><a href="#Controlling-the-physics-world-speed" class="headerlink" title="Controlling the physics world speed"></a>Controlling the physics world speed</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scene.physicsWorld.speed = 0.05</span><br></pre></td></tr></table></figure>
<h2 id="Controlling-the-physics-simulation-speed"><a href="#Controlling-the-physics-simulation-speed" class="headerlink" title="Controlling the physics simulation speed"></a>Controlling the physics simulation speed</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scene.physicsWorld.timeStep = 1.0 / 60.0</span><br></pre></td></tr></table></figure>
<h2 id="Recovering-fallen-dice"><a href="#Recovering-fallen-dice" class="headerlink" title="Recovering fallen dice"></a>Recovering fallen dice</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func updateDiceNodes() &#123;       </span><br><span class="line">   // - Iterating through all the available nodes within active scene.</span><br><span class="line">   for node in sceneView.scene.rootNode.childNodes &#123;</span><br><span class="line">   </span><br><span class="line">     // - You’re only interested in the ones named &quot;dice&quot; that are also 2 meters below </span><br><span class="line">     the ground plane.</span><br><span class="line">     if node.name == &quot;dice&quot; &#123;</span><br><span class="line">       if  node.presentation.position.y &lt; -2 &#123;</span><br><span class="line">       </span><br><span class="line">         // - Removing it from the scene, then increase diceCount by one, essentially </span><br><span class="line">         putting the die back into the player’s hand.</span><br><span class="line">         node.removeFromParentNode()</span><br><span class="line">         diceCount += 1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>renderer(_:updateAtTime):</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.updateDiceNodes()</span><br></pre></td></tr></table></figure>
<h2 id="Adding-plane-physics"><a href="#Adding-plane-physics" class="headerlink" title="Adding plane physics"></a>Adding plane physics</h2><ul>
<li>To make an object take part in SceneKit’s built-in physics simulation, you have to attach an SCNPhysicsBody to your object’s SCNode.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func createARPlanePhysics(geometry: SCNGeometry) -&gt; SCNPhysicsBody &#123;</span><br><span class="line">    // - Creating a kinematic physics body that’s very similar to a static body</span><br><span class="line">    let physicsBody = SCNPhysicsBody(</span><br><span class="line">        type: .kinematic,</span><br><span class="line">        // - Creating an appropriate shape for a 3D object if you provide it with the object geometry</span><br><span class="line">        shape: SCNPhysicsShape(geometry: geometry,</span><br><span class="line">          options: nil))</span><br><span class="line">          </span><br><span class="line">    // - Adjusting some of its physical properties</span><br><span class="line">    physicsBody.restitution = 0.5</span><br><span class="line">    physicsBody.friction = 0.5</span><br><span class="line">    </span><br><span class="line">    // - Providing the resulting physics body back to the caller.</span><br><span class="line">    return physicsBody</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>When creating AR plane nodes, you need to create the physics body for the plane node too. Add the following to createARPlaneNode(planeAnchor:color:), right before the return planeNode statement:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">planeNode.physicsBody = createARPlanePhysics(geometry: planeGeometry)</span><br></pre></td></tr></table></figure>
<ul>
<li>What about when the AR plane node is updated? Well, unfortunately, you have to destroy the old physics body, then recreate a new one. Luckily that’s easier achieved than you’d think. Add the following to bottom of updateARPlaneNode(planeNode:planeAchor:):</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">planeNode.physicsBody = nil</span><br><span class="line">planeNode.physicsBody = createARPlanePhysics(geometry: planeGeometry)</span><br></pre></td></tr></table></figure>
<h2 id="Randomizing-rotation"><a href="#Randomizing-rotation" class="headerlink" title="Randomizing rotation"></a>Randomizing rotation</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func throwDiceNode(transform: SCNMatrix4, offset: SCNVector3) &#123;</span><br><span class="line">    // - This defines a vector that contains a random rotation for each axis</span><br><span class="line">    let rotation = SCNVector3(Double.random(min: 0, max: Double.pi), Double.random(min: 0, max: Double.pi), Double.random(min: 0, max: Double.pi))</span><br><span class="line">    let position = SCNVector3(transform.m41 + offset.x,</span><br><span class="line">                              transform.m42 + offset.y,</span><br><span class="line">                              transform.m43 + offset.z)</span><br><span class="line">    let diceNode = diceNodes[diceStyle].clone()</span><br><span class="line">    diceNode.name = &quot;dice&quot;</span><br><span class="line">    diceNode.position = position</span><br><span class="line">    </span><br><span class="line">    // - This sets the euler angles of the dice, which is essentially the dice rotation</span><br><span class="line">    diceNode.eulerAngles = rotation</span><br><span class="line">    sceneView.scene.rootNode.addChildNode(diceNode)</span><br><span class="line">    diceCount -= 1</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Force"><a href="#Force" class="headerlink" title="Force"></a>Force</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func throwDiceNode(transform: SCNMatrix4, offset: SCNVector3) &#123;</span><br><span class="line">    // - This line calculates that exact distance between the dice and the focus node.</span><br><span class="line">    let distance = simd_distance(focusNode.simdPosition,simd_make_float3(transform.m41, transform.m42, transform.m43))</span><br><span class="line">    </span><br><span class="line">    // - This creates a forward direction vector, incorporating the distance you just calculated, including the dice rotation.</span><br><span class="line">    let direction = SCNVector3(-(distance * 2.5) * transform.m31, -(distance * 2.5) * (transform.m32 - Float.pi / 4), -(distance * 2.5) * transform.m33)</span><br><span class="line">    let rotation = SCNVector3(Double.random(min: 0, max: Double.pi), Double.random(min: 0, max: Double.pi), Double.random(min: 0, max: Double.pi))</span><br><span class="line">    let position = SCNVector3(transform.m41 + offset.x,</span><br><span class="line">                              transform.m42 + offset.y,</span><br><span class="line">                              transform.m43 + offset.z)</span><br><span class="line">    let diceNode = diceNodes[diceStyle].clone()</span><br><span class="line">    diceNode.name = &quot;dice&quot;</span><br><span class="line">    diceNode.position = position</span><br><span class="line">    diceNode.eulerAngles = rotation</span><br><span class="line">    </span><br><span class="line">    // - This updates the dice physics body position to match it’s actual position.</span><br><span class="line">    diceNode.physicsBody?.resetTransform()</span><br><span class="line">    </span><br><span class="line">    // - This applies a force to the dice, throwing it into a certain direction, as a short impulse.</span><br><span class="line">    diceNode.physicsBody?.applyForce(direction, asImpulse: true)</span><br><span class="line">    sceneView.scene.rootNode.addChildNode(diceNode)</span><br><span class="line">    diceCount -= 1</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Adding-a-shadow-casting-light"><a href="#Adding-a-shadow-casting-light" class="headerlink" title="Adding a shadow-casting light"></a>Adding a shadow-casting light</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var lightNode: SCNNode</span><br></pre></td></tr></table></figure>
<ul>
<li>Then, add the following to the bottom of *loadModels():</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lightNode = diceScene.rootNode.childNode(withName: &quot;directional&quot;, recursively: false)!</span><br><span class="line">sceneView.scene.rootNode.addChildNode(lightNode)</span><br></pre></td></tr></table></figure>
<h2 id="Light-estimation"><a href="#Light-estimation" class="headerlink" title="Light estimation"></a>Light estimation</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func initARSession() &#123;</span><br><span class="line">    guard ARWorldTrackingConfiguration.isSupported else &#123;</span><br><span class="line">      print(&quot;*** ARConfig: AR World Tracking Not Supported&quot;)</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    let config = ARWorldTrackingConfiguration()</span><br><span class="line">    config.worldAlignment = .gravity</span><br><span class="line">    config.providesAudioData = false</span><br><span class="line">    config.planeDetection = .horizontal</span><br><span class="line">    </span><br><span class="line">    // - Allowing ARKit to manage the light intensity based on the detected environment light intensity.</span><br><span class="line">    config.isLightEstimationEnabled = true</span><br><span class="line">    sceneView.session.run(config)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h1 id="Wrapping-things-up"><a href="#Wrapping-things-up" class="headerlink" title="Wrapping things up"></a>Wrapping things up</h1><h2 id="Suspending-AR-plane-detection"><a href="#Suspending-AR-plane-detection" class="headerlink" title="Suspending AR plane detection"></a>Suspending AR plane detection</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func suspendARPlaneDetection() &#123;</span><br><span class="line">  // - This gets the current AR tracking configuration from the scene view session.</span><br><span class="line">  let config = sceneView.session.configuration as!</span><br><span class="line">    ARWorldTrackingConfiguration</span><br><span class="line">    </span><br><span class="line">  // - Then it clears the planeDetection property by setting it to an empty array. </span><br><span class="line">  config.planeDetection = []</span><br><span class="line">  </span><br><span class="line">  // - “Finally, it re-runs the session with the minor change in configuration. Now </span><br><span class="line">  ARKit knows not to waste any energy on detecting more planes.</span><br><span class="line">  sceneView.session.run(config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Hiding-visible-planes"><a href="#Hiding-visible-planes" class="headerlink" title="Hiding visible planes"></a>Hiding visible planes</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func hideARPlaneNodes() &#123;</span><br><span class="line">    // - Start by stepping through all the available anchors in the scene view. This is achieved by accessing them through the current frame.</span><br><span class="line">    for anchor in</span><br><span class="line">      (self.sceneView.session.currentFrame?.anchors)! &#123;</span><br><span class="line">      </span><br><span class="line">      // - Get the related node for the current anchor.</span><br><span class="line">      if let node = self.sceneView.node(for: anchor) &#123;</span><br><span class="line">      </span><br><span class="line">        // - Once you’ve got the related node, hide it, along with all its children.</span><br><span class="line">        for child in node.childNodes &#123;</span><br><span class="line">        </span><br><span class="line">          // - Once you’ve got it, you can clear its color buffer write mask by setting it to an empty array.</span><br><span class="line">          let material = child.geometry?.materials.first!</span><br><span class="line">          material?.colorBufferWriteMask = []</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Blocking-swipe-gestures"><a href="#Blocking-swipe-gestures" class="headerlink" title="Blocking swipe gestures"></a>Blocking swipe gestures</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// - Once the game starts, it will go into a .swipeToPlay state, only then will you allow swipe gestures.</span><br><span class="line">guard gameState == .swipeToPlay else &#123; return &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Starting-the-game"><a href="#Starting-the-game" class="headerlink" title="Starting the game"></a>Starting the game</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func startGame() &#123;</span><br><span class="line">  DispatchQueue.main.async &#123;</span><br><span class="line">    self.startButton.isHidden = true</span><br><span class="line">    self.suspendARPlaneDetection()</span><br><span class="line">    self.hideARPlaneNodes()</span><br><span class="line">    self.gameState = .pointToSurface</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Resetting-the-game"><a href="#Resetting-the-game" class="headerlink" title="Resetting the game"></a>Resetting the game</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func resetARSession() &#123;</span><br><span class="line">  // - The function simply re-enables .horizontal plane detection by adjusting the existing AR configuration.</span><br><span class="line">  let config = sceneView.session.configuration as!</span><br><span class="line">    ARWorldTrackingConfiguration</span><br><span class="line">  config.planeDetection = .horizontal</span><br><span class="line">  sceneView.session.run(config,</span><br><span class="line">  </span><br><span class="line">    // - This time, when re-running the config, you’re passing in some additional options:</span><br><span class="line">    	.resetTracking will essentially restart ARKit.</span><br><span class="line">		.removeExistingAnchors will destroy all previously detected anchors, which will also destroy all previously detected surface nodes. </span><br><span class="line">    options: [.resetTracking, .removeExistingAnchors])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func resetGame() &#123;</span><br><span class="line">  DispatchQueue.main.async &#123;</span><br><span class="line">    self.startButton.isHidden = false</span><br><span class="line">    self.resetARSession()</span><br><span class="line">    self.gameState = .detectSurface</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Hit-testing"><a href="#Hit-testing" class="headerlink" title="Hit testing"></a>Hit testing</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">override func touchesBegan(_ touches: Set&lt;UITouch&gt;,</span><br><span class="line">  with event: UIEvent?) &#123;</span><br><span class="line">  DispatchQueue.main.async &#123;</span><br><span class="line">    // - Starting by getting the position where the player touched the screen.</span><br><span class="line">    if let touchLocation = touches.first?.location(</span><br><span class="line">      in: self.sceneView) &#123;</span><br><span class="line">      </span><br><span class="line">      // - Using that touched position as the starting point for the hit test.</span><br><span class="line">      if let hit = self.sceneView.hitTest(touchLocation,</span><br><span class="line">        options: nil).first &#123;</span><br><span class="line">        </span><br><span class="line">        // - Only interested whether the player is touching a die. This will make sure of that.</span><br><span class="line">        if hit.node.name == &quot;dice&quot; &#123;</span><br><span class="line">        </span><br><span class="line">          // - If the player indeed did touch a die, remove it from the scene and put it back into the player’s hand by increasing the diceCount by one.</span><br><span class="line">          hit.node.removeFromParentNode()</span><br><span class="line">          self.diceCount += 1</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div></main><footer><div class="paginator"><a href="/2018/07/08/loser/" class="next">NEXT</a></div><div class="copyright"><p>© 2017 - 2018 <a href="http://yoursite.com"></a> <a href="https://hexo.io/" target="_blank"> </a> <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank"> </a></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>