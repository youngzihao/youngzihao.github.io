<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> ARKit by Tutorials · Feng Shui</title><meta name="description" content="ARKit by Tutorials - null"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Feng Shui"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.svg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/youngzihao" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">ARKit by Tutorials</h1><div class="post-info">Sep 18, 2018</div><div class="post-content"><h1 id="1-Basic-Session-Management"><a href="#1-Basic-Session-Management" class="headerlink" title="1.Basic Session Management"></a>1.Basic Session Management</h1><h2 id="Create-the-configuration"><a href="#Create-the-configuration" class="headerlink" title="Create the configuration"></a>Create the configuration</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func initARSession() &#123;</span><br><span class="line">    guard ARWorldTrackingConfiguration.isSupported else &#123;</span><br><span class="line">      print(&quot;*** ARConfig: AR World Tracking Not Supported&quot;)</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    // 1</span><br><span class="line">    let config = ARWorldTrackingConfiguration()</span><br><span class="line">    // 2</span><br><span class="line">    config.worldAlignment = .gravity</span><br><span class="line">    // 3</span><br><span class="line">    config.providesAudioData = false</span><br><span class="line">    // 4</span><br><span class="line">    sceneView.session.run(config)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>创建一个 ARWorldTrackingConfiguration 实例，分配给了 config </li>
<li>设置 worldAlignment 的属性，也就是具体说明虚拟的内容将如何与现实世界相关联</li>
<li>不允许 AR session 捕捉声音，还有一个属性 isLightEstimationEnabled 之后会学到</li>
<li>运行 AR session ，并使用你刚刚设置好的配置，现在实时追踪 6DOF 维度的数据</li>
</ol>
<h2 id="Controll-an-AR-session"><a href="#Controll-an-AR-session" class="headerlink" title="Controll an AR session"></a>Controll an AR session</h2><ol>
<li>Pause:<br><code>ARSession.pause()</code></li>
<li>Resume:<br><code>ARSession.run()</code></li>
<li>Update:<br><code>ARSession.run(ARSessionConfig)</code></li>
<li>Reset:<br><code>ARSession.run(_:options:)</code></li>
</ol>
<h2 id="Update-the-status-message"><a href="#Update-the-status-message" class="headerlink" title="Update the status message"></a>Update the status message</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var trackingStatus: String = &quot;&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func renderer(_ renderer: SCNSceneRenderer, </span><br><span class="line">   updateAtTime time: TimeInterval) &#123;</span><br><span class="line">   DispatchQueue.main.async &#123;</span><br><span class="line">     self.statusLabel.text = self.trackingStatus</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Handle-AR-session-errors"><a href="#Handle-AR-session-errors" class="headerlink" title="Handle AR session errors"></a>Handle AR session errors</h2><ol>
<li><p>Session 失败</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func session(_ session: ARSession, </span><br><span class="line">  didFailWithError error: Error) &#123;</span><br><span class="line">  trackingStatus = &quot;AR Session Failure: \(error)&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Session 中断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func sessionWasInterrupted(_ session: ARSession) &#123;</span><br><span class="line">  trackingStatus = &quot;AR Session Was Interrupted!&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Session 中断结束</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func sessionInterruptionEnded(_ session: ARSession) &#123;</span><br><span class="line">  trackingStatus = &quot;AR Session Interruption Ended&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Handle-AR-session-state-changes"><a href="#Handle-AR-session-state-changes" class="headerlink" title="Handle AR session state changes"></a>Handle AR session state changes</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">func session(_ session: ARSession,</span><br><span class="line">               cameraDidChangeTrackingState camera: ARCamera) &#123;</span><br><span class="line">    switch camera.trackingState &#123;</span><br><span class="line">    // 1</span><br><span class="line">    case .notAvailable:</span><br><span class="line">      trackingStatus = &quot;Tacking:  Not available!&quot;</span><br><span class="line">      break</span><br><span class="line">    // 2</span><br><span class="line">    case .normal:</span><br><span class="line">      trackingStatus = &quot;Tracking: All good!&quot;</span><br><span class="line">      break</span><br><span class="line">    // 3</span><br><span class="line">    case .limited(let reason):</span><br><span class="line">      switch reason &#123;</span><br><span class="line">      case .excessiveMotion:</span><br><span class="line">        trackingStatus = &quot;Tracking: Limited due to excessive motion!&quot;</span><br><span class="line">      // 3.1</span><br><span class="line">      case .insufficientFeatures:</span><br><span class="line">        trackingStatus = &quot;Tracking: Limited due to insufficient features!&quot;</span><br><span class="line">      // 3.2</span><br><span class="line">      case .initializing:</span><br><span class="line">        trackingStatus = &quot;Tracking: Initializing...&quot;</span><br><span class="line">      // 3.3</span><br><span class="line">      case .relocalizing:</span><br><span class="line">        trackingStatus = &quot;Tracking: Relocalizing...&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>当 AR session 正在运行时，session 受到外部的条件影响会改变追踪状态，每一次状态改变，该方法就会被触发，我们需要监视所有的 ARCamera.trackingStatus 的状态改变。</p>
<ol>
<li>notAvailable</li>
<li>normal</li>
</ol>
<h2 id="Show-debug-options"><a href="#Show-debug-options" class="headerlink" title="Show debug options"></a>Show debug options</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sceneView.debugOptions = [</span><br><span class="line">      ARSCNDebugOptions.showFeaturePoints,</span><br><span class="line">      ARSCNDebugOptions.showWorldOrigin,</span><br><span class="line">      SCNDebugOptions.showBoundingBoxes,</span><br><span class="line">      SCNDebugOptions.showWireframe</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>
<h1 id="2-Add-3D-Objects-and-Textures"><a href="#2-Add-3D-Objects-and-Textures" class="headerlink" title="2.Add 3D Objects and Textures"></a>2.Add 3D Objects and Textures</h1><h2 id="Creating-the-dice-scene"><a href="#Creating-the-dice-scene" class="headerlink" title="Creating the dice scene"></a>Creating the dice scene</h2><ol>
<li>COLLDA 格式 –&gt; 转换为 SceneKit scene file format (.scn)</li>
<li>新建 DiceScene.scn ，在里面复制粘贴出五个 dice  </li>
</ol>
<h2 id="Physically-based-rendering-PBR"><a href="#Physically-based-rendering-PBR" class="headerlink" title="Physically based rendering (PBR)"></a>Physically based rendering (PBR)</h2><h4 id="Environment-map（环境贴图）"><a href="#Environment-map（环境贴图）" class="headerlink" title="Environment map（环境贴图）"></a>Environment map（环境贴图）</h4><ul>
<li>环境贴图有两个目的，第一是与反射贴图类似，在高反射的表面上可以看到映射。第二是为基于物理渲染的物体提供光照信息，给予它们一个真实的光照环境。</li>
</ul>
<h4 id="Diffuse-map-（漫反射贴图）"><a href="#Diffuse-map-（漫反射贴图）" class="headerlink" title="Diffuse map （漫反射贴图）"></a>Diffuse map （漫反射贴图）</h4><h4 id="Normal-map-（法线贴图）"><a href="#Normal-map-（法线贴图）" class="headerlink" title="Normal map （法线贴图）"></a>Normal map （法线贴图）</h4><h4 id="Height-map"><a href="#Height-map" class="headerlink" title="Height map"></a>Height map</h4><h4 id="Occlusion-map-（闭塞贴图）"><a href="#Occlusion-map-（闭塞贴图）" class="headerlink" title="Occlusion map （闭塞贴图）"></a>Occlusion map （闭塞贴图）</h4><h4 id="Emission-map"><a href="#Emission-map" class="headerlink" title="Emission map"></a>Emission map</h4><h4 id="Self-illumination-map"><a href="#Self-illumination-map" class="headerlink" title="Self-illumination map"></a>Self-illumination map</h4><h4 id="Displacement-map-（置换贴图）"><a href="#Displacement-map-（置换贴图）" class="headerlink" title="Displacement map （置换贴图）"></a>Displacement map （置换贴图）</h4><h4 id="Metalness-map-（金属贴图）"><a href="#Metalness-map-（金属贴图）" class="headerlink" title="Metalness map （金属贴图）"></a>Metalness map （金属贴图）</h4><h4 id="roughness-map"><a href="#roughness-map" class="headerlink" title="roughness map"></a>roughness map</h4><h2 id="Load-3D-objects"><a href="#Load-3D-objects" class="headerlink" title="Load 3D objects"></a>Load 3D objects</h2><blockquote>
<p>创建一个新的 scene ，使得 dice 进入增强现实空间</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let scene = SCNScene()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为 AR scene 准备一个 environment map 。现在 scene 已经为基于 PBR 的 3D 物体准备好了一个合适的 lighting environment map </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scene.lightingEnvironment.contents = </span><br><span class="line">   &quot;PokerDice.scnassets/Textures/Environment_CUBE.jpg&quot;</span><br><span class="line">scene.lightingEnvironment.intensity = 2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>创建一个数组，因为你刚刚创建了五个风格不一的 dice node</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var diceNodes: [SCNNode] = []</span><br></pre></td></tr></table></figure>
<blockquote>
<p>现在需要把这些 dice nodes 加载进入数组<br> （1）加载 DiceScene.scn 并存储进 diceScene<br> （2）循环五次<br> （3）childNode() 搜索 diceScene.rootNode scene， 寻找所有的 dice，一旦发现，添加 dice node 到 diceNodes 数组</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func loadModels() &#123;</span><br><span class="line">  // 1      </span><br><span class="line">  let diceScene = SCNScene(</span><br><span class="line">    named: &quot;PokerDice.scnassets/Models/DiceScene.scn&quot;)!</span><br><span class="line">  // 2</span><br><span class="line">  for count in 0..&lt;5 &#123;</span><br><span class="line">    // 3</span><br><span class="line">    diceNodes.append(diceScene.rootNode.childNode(</span><br><span class="line">      withName: &quot;dice\(count)&quot;, </span><br><span class="line">      recursively: false)!)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在一开始就调用方法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.loadModels()</span><br></pre></td></tr></table></figure>
<h2 id="Place-3D-objects"><a href="#Place-3D-objects" class="headerlink" title="Place 3D objects"></a>Place 3D objects</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var diceCount: Int = 5</span><br><span class="line">var diceStyle: Int = 0</span><br><span class="line">var diceOffset: [SCNVector3] = [SCNVector3(0.0,0.0,0.0),</span><br><span class="line">                           SCNVector3(-0.05, 0.00, 0.0),</span><br><span class="line">                           SCNVector3(0.05, 0.00, 0.0),</span><br><span class="line">                           SCNVector3(-0.05, 0.05, 0.02),</span><br><span class="line">                           SCNVector3(0.05, 0.05, 0.02)]</span><br></pre></td></tr></table></figure>
<ul>
<li>diceCount：计数手中还有多少 dice</li>
<li>diceStyle：标志不同风格的 dice</li>
<li>diceOffset：一组位置偏移</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func throwDiceNode(transform: SCNMatrix4, offset: SCNVector3) &#123;</span><br><span class="line">    // 1</span><br><span class="line">    let position = SCNVector3(transform.m41 + offset.x,</span><br><span class="line">                              transform.m42 + offset.y,</span><br><span class="line">                              transform.m43 + offset.z)</span><br><span class="line">    // 2</span><br><span class="line">    let diceNode = diceNodes[diceStyle].clone()</span><br><span class="line">    diceNode.name = &quot;dice&quot;</span><br><span class="line">    diceNode.position = position</span><br><span class="line">    //3</span><br><span class="line">    sceneView.scene.rootNode.addChildNode(diceNode)</span><br><span class="line">    //diceCount -= 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>通过联合转换后的数据和传入函数的数据创建了一个位置偏移量</li>
<li>克隆了一个被选中的 dice node，重新命名为 dice ，并且设置它的位置</li>
<li>最后新克隆的 dice node 被放置于 AR scene 中，diceCount 自减表示手中少了一个 dice</li>
</ol>
<h2 id="Add-a-swipe-gesture"><a href="#Add-a-swipe-gesture" class="headerlink" title="Add a swipe gesture"></a>Add a swipe gesture</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@IBAction func swipeUpGestureHandler(_ sender: Any) &#123;</span><br><span class="line">    // 1</span><br><span class="line">    guard let frame = self.sceneView.session.currentFrame else &#123; return &#125;</span><br><span class="line">    // 2</span><br><span class="line">    for count in 0..&lt;diceCount &#123;</span><br><span class="line">      throwDiceNode(transform: SCNMatrix4(frame.camera.transform),</span><br><span class="line">                    offset: diceOffset[count])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>currentFrame 是一个 ARFrame 对象，连接着AR scene，它包含最近捕捉的视频帧图像的，同时还有捕捉的深度数据，AR 相机，当前的环境估计光，锚，特征点，这行代码确保这有一个可用的画面</li>
<li>遍历了五个 dice，使用 AR 相机的转换矩阵，它包含关于相机位置和旋转的信息，一次抛出一个 dice 进入 AR scene ，最后将会抛出你手中所有的 dice </li>
</ol>
<h2 id="Change-dice-styles"><a href="#Change-dice-styles" class="headerlink" title="Change dice styles"></a>Change dice styles</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@IBAction func styleButtonPressed(_ sender: Any) &#123;</span><br><span class="line">    diceStyle = diceStyle &gt;= 4 ? 0 : diceStyle + 1</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-Detect-Surface"><a href="#3-Detect-Surface" class="headerlink" title="3.Detect Surface"></a>3.Detect Surface</h1><h2 id="Define-game-states"><a href="#Define-game-states" class="headerlink" title="Define game states"></a>Define game states</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum GameState: Int16 &#123;</span><br><span class="line">  case detectSurface  </span><br><span class="line">  case pointToSurface   </span><br><span class="line">  case swipeToPlay</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>detectSurface：ARKit 需要花费一小会儿去理解它的环境，然后开始检测平面。只要游戏处于这个状态中，玩家就必须去扫描他们的环境以寻找合适的水平平面，例如晚餐桌。一旦玩家对于 ARKit 所侦测到的平面表示满意，他们就可以点击开始按钮进入下一阶段。</li>
<li>pointToSurface：玩家现在将设备指向已侦测过的平面，可以看到一个准心光标出现，准心光标表示目标点，也就是 dice 将会被抛向的地方</li>
<li>swipeToPlay：一旦目标点出现，玩家就可以轻划将 dice 抛向准心光标</li>
</ul>
<h2 id="Add-game-state-messages"><a href="#Add-game-state-messages" class="headerlink" title="Add game state messages"></a>Add game state messages</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var gameState: GameState = .detectSurface</span><br><span class="line">var statusMessage: String = &quot;&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func updateStatus() &#123;</span><br><span class="line">  // 1</span><br><span class="line">  switch gameState &#123;</span><br><span class="line">    case .detectSurface:</span><br><span class="line">      statusMessage = &quot;Scan entire table surface...\nHit START when ready!&quot;</span><br><span class="line">    case .pointToSurface:</span><br><span class="line">      statusMessage = &quot;Point at designated surface first!&quot;</span><br><span class="line">    case .swipeToPlay:</span><br><span class="line">      statusMessage = &quot;Swipe UP to throw!\nTap on dice to collect it again.&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  // 2    </span><br><span class="line">  self.statusLabel.text = trackingStatus != &quot;&quot; ? </span><br><span class="line">    &quot;\(trackingStatus)&quot; : &quot;\(statusMessage)&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Anchors"><a href="#Anchors" class="headerlink" title="Anchors"></a>Anchors</h2><ul>
<li>ARKit 使用一个虚拟的锚去固定你的 3D 物体，主要目的是当玩家在现实世界移动设备时，维持 3D 物体的位置</li>
<li>ARAnchor 包含一个真实世界的位置和朝向，并且不可见，它只是一个 ARKit scene 中的一个对象。ARKit 会默认给每一个 ARAnchor 配对一个空的 SCNNode，你要做的就是添加你的 3D 物体作为这个 node 的孩子</li>
<li>ARPlaneAnchor 是一个特殊的锚，包含了一个真实世界的位置和朝向，并且还有一个附加的平面信息，包括中心点，朝向，以及平面范围大小，你能够使用这些信息去创造一个 SceneKit plane node</li>
</ul>
<h2 id="Create-new-planes"><a href="#Create-new-planes" class="headerlink" title="Create new planes"></a>Create new planes</h2><ul>
<li>当一个新的 plane anchor 被添加时，使用这个函数去创建一个对应的可视对象，这个函数接受了一个 ARPlaneAnchor 以及一个 UIColor，现在我们拥有了所有的信息去生成一个 SceneKit Plane node</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func createARPlaneNode(planeAnchor: ARPlaneAnchor, color: UIColor) -&gt; SCNNode &#123;</span><br><span class="line">    </span><br><span class="line">    // 1 </span><br><span class="line">    let planeGeometry = SCNPlane(width: CGFloat(planeAnchor.extent.x),</span><br><span class="line">                                 height: CGFloat(planeAnchor.extent.z))</span><br><span class="line">    </span><br><span class="line">    // 2</span><br><span class="line">    let planeMaterial = SCNMaterial()</span><br><span class="line">    planeMaterial.diffuse.contents = &quot;PokerDice.scnassets/Textures/Surface_DIFFUSE.png&quot; //color</span><br><span class="line">    planeGeometry.materials = [planeMaterial]</span><br><span class="line">    </span><br><span class="line">    // 3</span><br><span class="line">    let planeNode = SCNNode(geometry: planeGeometry)</span><br><span class="line">    planeNode.position = SCNVector3Make(planeAnchor.center.x, 0, planeAnchor.center.z)</span><br><span class="line">    planeNode.transform = SCNMatrix4MakeRotation(-Float.pi / 2, 1, 0, 0)</span><br><span class="line">    </span><br><span class="line">    return planeNode</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>使用 anchor 的范围大小来生成 plane 的几何形状</li>
<li>创建一个新的材质，然后设置它的 diffuse.contents 属性</li>
<li><p>创建 plane node</p>
<blockquote>
<p>第三步详解：</p>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 1 </span><br><span class="line">let planeNode = SCNNode(geometry: planeGeometry)</span><br><span class="line">// 2</span><br><span class="line">planeNode.position = SCNVector3Make(</span><br><span class="line">  planeAnchor.center.x, 0, planeAnchor.center.z)</span><br><span class="line">// 3</span><br><span class="line">planeNode.transform = SCNMatrix4MakeRotation(-Float.pi / 2, 1, 0, 0)</span><br><span class="line">// 4        </span><br><span class="line">return planeNode</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>通过传入之前生成的 plane geometry，创建了一个新的plane node</p>
</li>
<li>基于锚的中心点设置了 plane node 的位置</li>
<li>通过 SCNPlane 生成的几何形状默认是垂直的，所以你需要绕 X 轴顺时针旋转 90 度，使得plane 平躺于平面上，当你直接创建垂直平面的时候，你可以直接忽略这一步</li>
<li>返回给调用者</li>
</ol>
<h2 id="Handle-new-plane-anchors"><a href="#Handle-new-plane-anchors" class="headerlink" title="Handle new plane anchors"></a>Handle new plane anchors</h2><ul>
<li>随着平面侦测的激活，ARKit 会自动开始为每一个它侦测到的水平平面创建 ARPlaneAnchors，对应的<br>renderer(_:didAdd:for) 委托方法将会被调用去通知你新添加的锚。你需要去做的就是等待这个事件被触发，然后为 anchor 创建一个对应的 SceneKit plane</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">func renderer(_ renderer: SCNSceneRenderer, didAdd node: SCNNode, for anchor: ARAnchor) &#123;</span><br><span class="line">	 // 2</span><br><span class="line">    guard let planeAnchor = anchor as? ARPlaneAnchor else &#123; return &#125;</span><br><span class="line">    // 3</span><br><span class="line">    DispatchQueue.main.async &#123;</span><br><span class="line">      // 4</span><br><span class="line">      let planeNode = self.createARPlaneNode(planeAnchor: planeAnchor,</span><br><span class="line">                                             color: UIColor.yellow.withAlphaComponent(0.5))</span><br><span class="line">      // 5                                                        </span><br><span class="line">      node.addChildNode(planeNode)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>注意这个委托方法接受了一个 SCNNode，这是一个新的 SceneKit node，会与接受道德 ARAnchor node 进行配对</li>
<li>你只关注 ARPlaneAnchors，因此将会筛选出这一类的锚</li>
<li>你只能在主线程里面创建可视对象</li>
<li>调用你刚刚创建的 createARPlaneNode()，传入锚信息和颜色 </li>
<li>plane node 被添加作为 ARKit 所创建的 node 的孩子 </li>
</ol>
<h2 id="Update-planes"><a href="#Update-planes" class="headerlink" title="Update planes"></a>Update planes</h2><ul>
<li>ARKit 一开始可能没有侦测到整个平面，所以随着玩家移动你需要去更新之前侦测到的平面</li>
<li>ARKit 将会触发 renderer(_:didUpdate:for) 代理方法，如果之前侦测的平面有新的信息更新</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">func renderer(_ renderer: SCNSceneRenderer, </span><br><span class="line">  didUpdate node: SCNNode, for anchor: ARAnchor) &#123;</span><br><span class="line">  // 2</span><br><span class="line">  guard let planeAnchor = anchor as? ARPlaneAnchor else &#123; return &#125;</span><br><span class="line">    // 3</span><br><span class="line">    DispatchQueue.main.async &#123;</span><br><span class="line">      // 4</span><br><span class="line">      self.updateARPlaneNode(planeNode: node.childNodes[0],</span><br><span class="line">        planeAchor: planeAnchor)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>注意这个代理方法接受了一个 SCNNode，这是一个一直存在的 node，当你之前添加你的 plane node 时</li>
<li>再一次，你只感兴趣 ARPlaneAnchors，所以将会筛选出此类的锚</li>
<li>你只能在主线程里更新可视对象</li>
<li>最后调用updatePlane()，You’re passing in the first child node, along with the associated plane anchor.</li>
</ol>
</div></article></div></main><footer><div class="paginator"><a href="/2018/07/08/loser/" class="next">下一篇</a></div><div class="copyright"><p>© 2017 - 2018 <a href="http://yoursite.com"></a> <a href="https://hexo.io/" target="_blank"> </a> <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank"> </a></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>