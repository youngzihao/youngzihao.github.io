<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> ARKit by Tutorials Section Ⅰ 野生笔记 · Feng Shui</title><meta name="description" content="ARKit by Tutorials Section Ⅰ 野生笔记 - null"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Feng Shui"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.svg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/youngzihao" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">ARKit by Tutorials Section Ⅰ 野生笔记</h1><div class="post-info">Sep 18, 2018</div><div class="post-content"><h1 id="Chapter-3-Basic-Session-Management"><a href="#Chapter-3-Basic-Session-Management" class="headerlink" title="Chapter 3: Basic Session Management"></a>Chapter 3: Basic Session Management</h1><h2 id="Mark-out-sections"><a href="#Mark-out-sections" class="headerlink" title="Mark out sections"></a>Mark out sections</h2><p><img src="https://i.loli.net/2018/09/22/5ba5ae2c6c97c.png" alt=""></p>
<h4 id="View-Management"><a href="#View-Management" class="headerlink" title="View Management"></a>View Management</h4><ul>
<li>这里面都是与 View 有关联的，不会修改过多，除了 <code>viewDidLoad()</code>，一直在添加各种初始化函数</li>
</ul>
<h4 id="Initialization"><a href="#Initialization" class="headerlink" title="Initialization"></a>Initialization</h4><ul>
<li><p>这里有之前提到的各种初始化函数</p>
<ul>
<li><code>initSceneView()</code> 负责设置 sceneView 的 delegate</li>
<li><code>initScene()</code>负责加载你的场景</li>
<li><code>initARSession()</code>现在还只是个空壳</li>
</ul>
</li>
</ul>
<h4 id="The-ARSCNViewDelegate-protocol-extension"><a href="#The-ARSCNViewDelegate-protocol-extension" class="headerlink" title="The ARSCNViewDelegate protocol extension"></a>The ARSCNViewDelegate protocol extension</h4><ul>
<li>这个协议被移动到自己的扩展中，清晰地隔离开来，并且使得功能相近的协议在一起，最后提高整个代码可读性</li>
</ul>
<h2 id="Create-the-configuration"><a href="#Create-the-configuration" class="headerlink" title="Create the configuration"></a>Create the configuration</h2><ul>
<li><p>ARSCNView view 本质上就是 SceneKit view，它包括一个 ARSession ，负责 ARKit 的运动追踪和图像处理，这是基于 session 的，意味着你必须创建一个 ARSession 实例，通过 “run” 来开启 AR 的追踪过程</p>
</li>
<li><p>在开启 ARSession 之前，你必须去创建一个 ARSession 配置，这个配置被用于建立现实世界和虚拟世界的联系，也就是你的设备位置和虚拟内容的位置关系</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func initARSession() &#123;</span><br><span class="line">    guard ARWorldTrackingConfiguration.isSupported else &#123;</span><br><span class="line">      print(&quot;*** ARConfig: AR World Tracking Not Supported&quot;)</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    // 1</span><br><span class="line">    let config = ARWorldTrackingConfiguration()</span><br><span class="line">    // 2</span><br><span class="line">    config.worldAlignment = .gravity</span><br><span class="line">    // 3</span><br><span class="line">    config.providesAudioData = false</span><br><span class="line">    // 4</span><br><span class="line">    sceneView.session.run(config)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>创建一个 ARWorldTrackingConfiguration 实例，分配给了 config </li>
<li>设置 worldAlignment 的属性，也就是具体说明虚拟的内容将如何与现实世界相关联</li>
<li>不允许 ARSession 捕捉声音，还有一个属性 isLightEstimationEnabled 之后会学到</li>
<li>运行 ARSession ，并使用你刚刚设置好的配置，现在实时追踪 6DOF 维度的数据</li>
</ol>
<h2 id="Controll-an-ARSession"><a href="#Controll-an-ARSession" class="headerlink" title="Controll an ARSession"></a>Controll an ARSession</h2><ol>
<li>Pause:<br><code>ARSession.pause()</code></li>
<li>Resume:<br><code>ARSession.run()</code></li>
<li>Update:<br><code>ARSession.run(ARSessionConfig)</code></li>
<li>Reset:<br><code>ARSession.run(_:options:)</code></li>
</ol>
<h2 id="Update-the-status-message"><a href="#Update-the-status-message" class="headerlink" title="Update the status message"></a>Update the status message</h2><blockquote>
<p>Properties</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var trackingStatus: String = &quot;&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>SceneKit Management</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func renderer(_ renderer: SCNSceneRenderer, </span><br><span class="line">   updateAtTime time: TimeInterval) &#123;</span><br><span class="line">   DispatchQueue.main.async &#123;</span><br><span class="line">     self.statusLabel.text = self.trackingStatus</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>注意：当更新 UI 中的元素时，例如 status bar label，你必须在主线程  DispatchQueue.main.async { … } 中进行更新</li>
</ul>
<h2 id="Handle-AR-session-errors"><a href="#Handle-AR-session-errors" class="headerlink" title="Handle AR session errors"></a>Handle AR session errors</h2><blockquote>
<p>Session Error Management</p>
</blockquote>
<ol>
<li>Session 失败</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func session(_ session: ARSession, didFailWithError error: Error) &#123;</span><br><span class="line">  trackingStatus = &quot;AR Session Failure: \(error)&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>Session 中断</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func sessionWasInterrupted(_ session: ARSession) &#123;</span><br><span class="line">  trackingStatus = &quot;AR Session Was Interrupted!&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>Session 中断结束</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func sessionInterruptionEnded(_ session: ARSession) &#123;</span><br><span class="line">  trackingStatus = &quot;AR Session Interruption Ended&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Handle-AR-session-state-changes"><a href="#Handle-AR-session-state-changes" class="headerlink" title="Handle AR session state changes"></a>Handle AR session state changes</h2><blockquote>
<p>Session State Management</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">func session(_ session: ARSession,</span><br><span class="line">               cameraDidChangeTrackingState camera: ARCamera) &#123;</span><br><span class="line">    switch camera.trackingState &#123;</span><br><span class="line">    // 1</span><br><span class="line">    case .notAvailable:</span><br><span class="line">      trackingStatus = &quot;Tacking:  Not available!&quot;</span><br><span class="line">      break</span><br><span class="line">    // 2</span><br><span class="line">    case .normal:</span><br><span class="line">      trackingStatus = &quot;Tracking: All good!&quot;</span><br><span class="line">      break</span><br><span class="line">    // 3</span><br><span class="line">    case .limited(let reason):</span><br><span class="line">      switch reason &#123;</span><br><span class="line">      case .excessiveMotion:</span><br><span class="line">        trackingStatus = &quot;Tracking: Limited due to excessive motion!&quot;</span><br><span class="line">      // 3.1</span><br><span class="line">      case .insufficientFeatures:</span><br><span class="line">        trackingStatus = &quot;Tracking: Limited due to insufficient features!&quot;</span><br><span class="line">      // 3.2</span><br><span class="line">      case .initializing:</span><br><span class="line">        trackingStatus = &quot;Tracking: Initializing...&quot;</span><br><span class="line">      // 3.3</span><br><span class="line">      case .relocalizing:</span><br><span class="line">        trackingStatus = &quot;Tracking: Relocalizing...&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>当 ARSession 正在运行时，session 受到外部的条件影响会改变追踪状态，每一次状态改变，该方法就会被触发，我们需要监视所有的 ARCamera.trackingStatus 的状态改变。</p>
<ol>
<li>notAvailable</li>
<li>normal</li>
</ol>
<h2 id="Show-debug-options"><a href="#Show-debug-options" class="headerlink" title="Show debug options"></a>Show debug options</h2><blockquote>
<p>initSceneView()</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sceneView.debugOptions = [</span><br><span class="line">      ARSCNDebugOptions.showFeaturePoints,</span><br><span class="line">      ARSCNDebugOptions.showWorldOrigin,</span><br><span class="line">      SCNDebugOptions.showBoundingBoxes,</span><br><span class="line">      SCNDebugOptions.showWireframe</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>
<h1 id="Chapter-4-Add-3D-Objects-and-Textures"><a href="#Chapter-4-Add-3D-Objects-and-Textures" class="headerlink" title="Chapter 4: Add 3D Objects and Textures"></a>Chapter 4: Add 3D Objects and Textures</h1><h2 id="Create-the-dice-scene"><a href="#Create-the-dice-scene" class="headerlink" title="Create the dice scene"></a>Create the dice scene</h2><ul>
<li><p>COLLADA 是一种 3D 物体流行的文件格式，Xcode 完全兼容这种格式，你只需要插入这种格式的文件，使用 Xcode 将它们转换为本地的 SceneKit 模型</p>
<blockquote>
<p>步骤：</p>
<ol>
<li>COLLDA 格式 –&gt; 转换为 SceneKit scene file format (.scn)</li>
<li>新建 DiceScene.scn ，在里面复制粘贴出五个 dice  </li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Physically-based-rendering-PBR"><a href="#Physically-based-rendering-PBR" class="headerlink" title="Physically based rendering (PBR)"></a>Physically based rendering (PBR)</h2><ul>
<li>Environment map：环境贴图有两个目的，第一是与反射贴图类似，在高反射的表面上可以看到映射。第二是为基于物理渲染的物体提供光照信息，给予它们一个真实的光照环境</li>
</ul>
<h2 id="Load-3D-objects"><a href="#Load-3D-objects" class="headerlink" title="Load 3D objects"></a>Load 3D objects</h2><ul>
<li>创建一个新的场景 ，使得骰子进入增强现实场景</li>
</ul>
<blockquote>
<p>initScene()</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let scene = SCNScene()</span><br></pre></td></tr></table></figure>
<ul>
<li>为 AR scene 准备一个 environment map 。现在 scene 已经为基于 PBR 的 3D 物体准备好了一个合适的 lighting environment map </li>
</ul>
<blockquote>
<p>initScene()</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scene.lightingEnvironment.contents = </span><br><span class="line">   &quot;PokerDice.scnassets/Textures/Environment_CUBE.jpg&quot;</span><br><span class="line">scene.lightingEnvironment.intensity = 2</span><br></pre></td></tr></table></figure>
<ul>
<li>创建一个数组，因为你刚刚创建了五个风格不一的 dice node</li>
</ul>
<blockquote>
<p>Properties</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var diceNodes: [SCNNode] = []</span><br></pre></td></tr></table></figure>
<ul>
<li>现在需要把这些 dice nodes 加载进入数组</li>
</ul>
<blockquote>
<p>Load Models</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func loadModels() &#123;</span><br><span class="line">  // 1      </span><br><span class="line">  let diceScene = SCNScene(</span><br><span class="line">    named: &quot;PokerDice.scnassets/Models/DiceScene.scn&quot;)!</span><br><span class="line">  // 2</span><br><span class="line">  for count in 0..&lt;5 &#123;</span><br><span class="line">    // 3</span><br><span class="line">    diceNodes.append(diceScene.rootNode.childNode(</span><br><span class="line">      withName: &quot;dice\(count)&quot;, </span><br><span class="line">      recursively: false)!)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>加载 DiceScene.scn 并存储进 diceScene</li>
<li>循环五次</li>
<li>childNode() 搜索 diceScene.rootNode scene， 寻找所有的骰子，一旦发现，添加 dice node 到 diceNodes 数组</li>
</ol>
<ul>
<li>在一开始就调用方法</li>
</ul>
<blockquote>
<p>viewDidLoad()</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.loadModels()</span><br></pre></td></tr></table></figure>
<h2 id="Place-3D-objects"><a href="#Place-3D-objects" class="headerlink" title="Place 3D objects"></a>Place 3D objects</h2><ul>
<li>dice nodes 已被加载，准备放入增强现实场景中 </li>
</ul>
<blockquote>
<p>Properties</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var diceCount: Int = 5</span><br><span class="line">var diceStyle: Int = 0</span><br><span class="line">var diceOffset: [SCNVector3] = [SCNVector3(0.0,0.0,0.0),</span><br><span class="line">                           SCNVector3(-0.05, 0.00, 0.0),</span><br><span class="line">                           SCNVector3(0.05, 0.00, 0.0),</span><br><span class="line">                           SCNVector3(-0.05, 0.05, 0.02),</span><br><span class="line">                           SCNVector3(0.05, 0.05, 0.02)]</span><br></pre></td></tr></table></figure>
<ul>
<li>diceCount：计数手中还有多少骰子</li>
<li>diceStyle：代表不同风格的骰子</li>
<li>diceOffset：一组位置偏移</li>
</ul>
<blockquote>
<p>Helper Functions</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func throwDiceNode(transform: SCNMatrix4, offset: SCNVector3) &#123;</span><br><span class="line">    // 1</span><br><span class="line">    let position = SCNVector3(transform.m41 + offset.x,</span><br><span class="line">                              transform.m42 + offset.y,</span><br><span class="line">                              transform.m43 + offset.z)</span><br><span class="line">    // 2</span><br><span class="line">    let diceNode = diceNodes[diceStyle].clone()</span><br><span class="line">    diceNode.name = &quot;dice&quot;</span><br><span class="line">    diceNode.position = position</span><br><span class="line">    //3</span><br><span class="line">    sceneView.scene.rootNode.addChildNode(diceNode)</span><br><span class="line">    //diceCount -= 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>将转换后的数据和传入函数的数据联合创建了一个位置偏移量</li>
<li>克隆了一个被选中的 dice node，重新命名为 “dice” ，并且设置它的位置</li>
<li>克隆的 dice node 被放置于增强现实场景中，diceCount 自减表示手中少了一个骰子</li>
</ol>
<h2 id="Add-a-swipe-gesture"><a href="#Add-a-swipe-gesture" class="headerlink" title="Add a swipe gesture"></a>Add a swipe gesture</h2><blockquote>
<p>Actions</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@IBAction func swipeUpGestureHandler(_ sender: Any) &#123;</span><br><span class="line">    // 1</span><br><span class="line">    guard let frame = self.sceneView.session.currentFrame else &#123; return &#125;</span><br><span class="line">    // 2</span><br><span class="line">    for count in 0..&lt;diceCount &#123;</span><br><span class="line">      throwDiceNode(transform: SCNMatrix4(frame.camera.transform),</span><br><span class="line">                    offset: diceOffset[count])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>currentFrame 是一个 ARFrame 对象，连接着增强现实场景，它包含最近捕捉的视频帧图像的，同时还有捕捉的深度数据，AR 相机，当前的环境估计光，锚，特征点，这行代码确保这有一个可用的画面</li>
<li>遍历了五个骰子，使用 AR 相机的转换矩阵，它包含关于相机位置和旋转的信息，一次抛出一个骰子进入 AR scene ，最后将会抛出你手中所有的骰子 </li>
</ol>
<h2 id="Change-dice-styles"><a href="#Change-dice-styles" class="headerlink" title="Change dice styles"></a>Change dice styles</h2><blockquote>
<p>Actions</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@IBAction func styleButtonPressed(_ sender: Any) &#123;</span><br><span class="line">    diceStyle = diceStyle &gt;= 4 ? 0 : diceStyle + 1</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h1 id="Chapter-5-Detect-Surface"><a href="#Chapter-5-Detect-Surface" class="headerlink" title="Chapter 5: Detect Surface"></a>Chapter 5: Detect Surface</h1><h2 id="Define-game-states"><a href="#Define-game-states" class="headerlink" title="Define game states"></a>Define game states</h2><blockquote>
<p>Game State</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum GameState: Int16 &#123;</span><br><span class="line">  case detectSurface  </span><br><span class="line">  case pointToSurface   </span><br><span class="line">  case swipeToPlay</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>detectSurface：ARKit 需要花费一点时间去理解它的环境，然后开始检测平面。只要游戏处于这个状态中，玩家就必须去扫描他们的环境以寻找合适的水平平面,一旦玩家对于 ARKit 所侦测到的平面满意，就可以进入下一阶段。</li>
<li>pointToSurface：玩家现在将设备指向侦测到的平面，出现一个准心光标，准心光标表示目标点，也就是骰子将会掷向的地方</li>
<li>swipeToPlay：一旦目标点出现，玩家向准心光标掷出骰子</li>
</ul>
<h2 id="Add-game-state-messages"><a href="#Add-game-state-messages" class="headerlink" title="Add game state messages"></a>Add game state messages</h2><blockquote>
<p>Properties</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var gameState: GameState = .detectSurface</span><br><span class="line">var statusMessage: String = &quot;&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Helper Functions</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func updateStatus() &#123;</span><br><span class="line">  // 1</span><br><span class="line">  switch gameState &#123;</span><br><span class="line">    case .detectSurface:</span><br><span class="line">      statusMessage = &quot;Scan entire table surface...\nHit START when ready!&quot;</span><br><span class="line">    case .pointToSurface:</span><br><span class="line">      statusMessage = &quot;Point at designated surface first!&quot;</span><br><span class="line">    case .swipeToPlay:</span><br><span class="line">      statusMessage = &quot;Swipe UP to throw!\nTap on dice to collect it again.&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  // 2    </span><br><span class="line">  self.statusLabel.text = trackingStatus != &quot;&quot; ? </span><br><span class="line">    &quot;\(trackingStatus)&quot; : &quot;\(statusMessage)&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>SceneKit Management</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func renderer(_ renderer: SCNSceneRenderer, updateAtTime time: TimeInterval) &#123;</span><br><span class="line">    DispatchQueue.main.async &#123;</span><br><span class="line">      //self.statusLabel.text = self.trackingStatus</span><br><span class="line">      self.updateStatus()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Anchors"><a href="#Anchors" class="headerlink" title="Anchors"></a>Anchors</h2><ul>
<li>ARKit 使用一个虚拟的锚去固定你的 3D 物体，当玩家在现实世界移动设备时，可以保持 3D 物体的位置</li>
<li><strong>ARAnchor 包含一个真实世界中的位置和朝向，并且不可见，它只是一个 ARKit scene 中的一个对象。ARKit 会默认给每一个 ARAnchor 配对一个空的 SCNNode，你要做的就是添加你的 3D 物体作为这个 node 的子对象</strong></li>
<li>ARPlaneAnchor 是一种特殊类型的锚，包含了一个真实世界的位置和朝向，并且还附加了平面信息，包括中心点，朝向，以及范围大小，你能够使用这些信息去创造一个 SceneKit plane node</li>
</ul>
<h2 id="Detect-surfaces"><a href="#Detect-surfaces" class="headerlink" title="Detect surfaces"></a>Detect surfaces</h2><blockquote>
<p>Initialization</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func initARSession() &#123;</span><br><span class="line">    guard ARWorldTrackingConfiguration.isSupported else &#123;</span><br><span class="line">      print(&quot;*** ARConfig: AR World Tracking Not Supported&quot;)</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    let config = ARWorldTrackingConfiguration()</span><br><span class="line">    config.worldAlignment = .gravity</span><br><span class="line">    config.providesAudioData = false</span><br><span class="line">    config.planeDetection = .horizontal</span><br><span class="line">    sceneView.session.run(config)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>ARKit 将会开始侦测水平平面，并且为每一个侦测到的平面自动生成 ARPlaneAnchor</li>
<li>通过使用.vertical instead，你还可以侦测垂直的平面</li>
</ul>
<h2 id="Create-new-planes"><a href="#Create-new-planes" class="headerlink" title="Create new planes"></a>Create new planes</h2><ul>
<li>当一个新的 plane anchor 被添加时，此函数可以创建一个对应的可视对象，这个函数接受了 ARPlaneAnchor 以及 UIColor，现在我们可以生成一个 SceneKit Plane node</li>
</ul>
<blockquote>
<p>Helper Functions</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func createARPlaneNode(planeAnchor: ARPlaneAnchor, color: UIColor) -&gt; SCNNode &#123;</span><br><span class="line">    </span><br><span class="line">    // 1 </span><br><span class="line">    let planeGeometry = SCNPlane(width: CGFloat(planeAnchor.extent.x),</span><br><span class="line">                                 height: CGFloat(planeAnchor.extent.z))</span><br><span class="line">    </span><br><span class="line">    // 2</span><br><span class="line">    let planeMaterial = SCNMaterial()</span><br><span class="line">    planeMaterial.diffuse.contents = &quot;PokerDice.scnassets/Textures/Surface_DIFFUSE.png&quot; //color</span><br><span class="line">    planeGeometry.materials = [planeMaterial]</span><br><span class="line">    </span><br><span class="line">    // 3</span><br><span class="line">    let planeNode = SCNNode(geometry: planeGeometry)</span><br><span class="line">    planeNode.position = SCNVector3Make(planeAnchor.center.x, 0, planeAnchor.center.z)</span><br><span class="line">    planeNode.transform = SCNMatrix4MakeRotation(-Float.pi / 2, 1, 0, 0)</span><br><span class="line">    </span><br><span class="line">    return planeNode</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>使用 anchor 的范围大小来生成 plane 的几何形状</li>
<li>创建一个新的材质，然后设置它的 diffuse.contents 属性</li>
<li><p>创建 plane node</p>
<blockquote>
<p>第三步详解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 1 </span><br><span class="line">let planeNode = SCNNode(geometry: planeGeometry)</span><br><span class="line">// 2</span><br><span class="line">planeNode.position = SCNVector3Make(</span><br><span class="line">  planeAnchor.center.x, 0, planeAnchor.center.z)</span><br><span class="line">// 3</span><br><span class="line">planeNode.transform = SCNMatrix4MakeRotation(-Float.pi / 2, 1, 0, 0)</span><br><span class="line">// 4        </span><br><span class="line">return planeNode</span><br></pre></td></tr></table></figure>
</blockquote>
<ol>
<li>通过传入之前生成的 plane geometry，创建了一个新的 plane node</li>
<li>基于锚的中心点设置了 plane node 的位置</li>
<li>通过 SCNPlane 生成的几何形状默认是垂直的，所以你需要绕 X 轴顺时针旋转 90 度，使得 plane 平躺，当你直接创建垂直平面的时候，你可以直接忽略这一步</li>
<li>返回给调用者</li>
</ol>
</li>
</ol>
<h2 id="Handle-new-plane-anchors"><a href="#Handle-new-plane-anchors" class="headerlink" title="Handle new plane anchors"></a>Handle new plane anchors</h2><ul>
<li>随着平面侦测的激活，ARKit 会自动为每一个它侦测到的水平平面创建 ARPlaneAnchors，当添加新的锚时，renderer(_:didAdd:for) 方法被调用。你需要去做的就是等待这个事件被触发，然后为锚创建一个对应的 SceneKit plane</li>
</ul>
<blockquote>
<p>Plane Management</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">func renderer(_ renderer: SCNSceneRenderer, didAdd node: SCNNode, for anchor: ARAnchor) &#123;</span><br><span class="line">	 // 2</span><br><span class="line">    guard let planeAnchor = anchor as? ARPlaneAnchor else &#123; return &#125;</span><br><span class="line">    // 3</span><br><span class="line">    DispatchQueue.main.async &#123;</span><br><span class="line">      // 4</span><br><span class="line">      let planeNode = self.createARPlaneNode(planeAnchor: planeAnchor,</span><br><span class="line">                                             color: UIColor.yellow.withAlphaComponent(0.5))</span><br><span class="line">      // 5                                                        </span><br><span class="line">      node.addChildNode(planeNode)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>注意这个委托方法接受了一个 SCNNode，这是一个新的 SceneKit node，会与接受到的 ARAnchor node 进行配对</li>
<li>你只关注 ARPlaneAnchors，因此将会筛选出这一类的锚</li>
<li>你只能在主线程里面创建可视对象</li>
<li>调用你刚刚创建的 createARPlaneNode()，传入锚的信息和颜色 </li>
<li>plane node 被添加作为 ARKit 所创建的 node 的子对象</li>
</ol>
<h2 id="Update-planes"><a href="#Update-planes" class="headerlink" title="Update planes"></a>Update planes</h2><ul>
<li>ARKit 一开始可能没有侦测到整个平面，随着玩家移动你需要去更新之前侦测到的平面</li>
<li>你需要使用全新的位置，朝向，尺寸大小去更新一个已经存在的 plane node</li>
</ul>
<blockquote>
<p>Helper Functions</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func updateARPlaneNode(planeNode: SCNNode, planeAchor: ARPlaneAnchor) &#123;</span><br><span class="line">  	let planeGeometry = planeNode.geometry as! SCNPlane</span><br><span class="line">  	// 1</span><br><span class="line">  	planeGeometry.width = CGFloat(planeAchor.extent.x)</span><br><span class="line">  	planeGeometry.height = CGFloat(planeAchor.extent.z)</span><br><span class="line">  	// 2</span><br><span class="line">  	planeNode.position = SCNVector3Make(planeAchor.center.x, 0, planeAchor.center.z)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>从 plane node 那取回了之前生成的 planeGeometry，然后基于之前的 planeAnchor 更新了它的宽度和高度信息</li>
<li>基于之前 planeAnchor 的位置信息更新 planeNode 的位置</li>
</ol>
<ul>
<li>如果之前侦测的平面有新的信息更新，ARKit 将会触发 renderer(_:didUpdate:for) 方法，</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">func renderer(_ renderer: SCNSceneRenderer, </span><br><span class="line">  didUpdate node: SCNNode, for anchor: ARAnchor) &#123;</span><br><span class="line">  // 2</span><br><span class="line">  guard let planeAnchor = anchor as? ARPlaneAnchor else &#123; return &#125;</span><br><span class="line">    // 3</span><br><span class="line">    DispatchQueue.main.async &#123;</span><br><span class="line">      // 4</span><br><span class="line">      self.updateARPlaneNode(planeNode: node.childNodes[0],</span><br><span class="line">        planeAchor: planeAnchor)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>注意这个代理方法接受了一个 SCNNode，这是一个一直存在的 node，之前添你将 planeNode 添加到此 node 中</li>
<li>再一次，你只感兴趣 ARPlaneAnchors，所以将会筛选出此类的锚</li>
<li>你只能在主线程里更新可视对象</li>
<li>最后调用 updatePlane()，你正在传入第一个子 node，以及一个相关联的 plane anchor</li>
</ol>
<h2 id="Create-a-focus-node"><a href="#Create-a-focus-node" class="headerlink" title="Create a focus node"></a>Create a focus node</h2><ul>
<li>现在你的 AR 游戏正在侦测平面，当用户掷出骰子时你应该提供用户某样东西可以去参照，如何将 focus node 置于平面之上，也就是用户所指之处，答案就是 ray casting</li>
</ul>
<h4 id="load-focus-node"><a href="#load-focus-node" class="headerlink" title="load focus node"></a>load focus node</h4><blockquote>
<p>Properties</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var focusNode: SCNNode!</span><br></pre></td></tr></table></figure>
<blockquote>
<p>loadModels()</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let focusScene = SCNScene(</span><br><span class="line">  named: &quot;PokerDice.scnassets/Models/FocusScene.scn&quot;)!</span><br><span class="line">focusNode = focusScene.rootNode.childNode(</span><br><span class="line">  withName: &quot;focus&quot;, recursively: false)!</span><br><span class="line">sceneView.scene.rootNode.addChildNode(focusNode)</span><br></pre></td></tr></table></figure>
<ul>
<li>加载了新场景，然后保存到 focusNode 中去</li>
</ul>
<h4 id="Ray-casting"><a href="#Ray-casting" class="headerlink" title="Ray casting"></a>Ray casting</h4><ul>
<li>Ray casting 是当玩家搜寻 3D 物体时，从屏幕中心投射虚拟射线进入场景中。在这种特殊情况中，场景中的射线与 plane nodes 产生相交点，一旦相交，相交位置就被用来放置 focus node</li>
</ul>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fvgx0ii2eqj31kw115kjm.jpg" alt=""></p>
<h4 id="Create-the-focus-point"><a href="#Create-the-focus-point" class="headerlink" title="Create the focus point"></a>Create the focus point</h4><blockquote>
<p>Properties</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var focusPoint:CGPoint!</span><br></pre></td></tr></table></figure>
<blockquote>
<p>initSceneView()</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">focusPoint = CGPoint(x: view.center.x,</span><br><span class="line">  y: view.center.y + view.center.y * 0.25)</span><br></pre></td></tr></table></figure>
<h4 id="Handle-orientation-changes"><a href="#Handle-orientation-changes" class="headerlink" title="Handle orientation changes"></a>Handle orientation changes</h4><blockquote>
<p>View Management</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@objc func orientationChanged() &#123;</span><br><span class="line">  focusPoint = CGPoint(x: view.center.x,</span><br><span class="line">    y: view.center.y + view.center.y * 0.25)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>initSceneView()</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NotificationCenter.default.addObserver(self, </span><br><span class="line">  selector: #selector(ViewController.orientationChanged),</span><br><span class="line">  name: NSNotification.Name.UIDeviceOrientationDidChange,</span><br><span class="line">  object: nil)</span><br></pre></td></tr></table></figure>
<ul>
<li>当用户改变设备朝向的时候，NSNotification.Name.UIDeviceOrientationDidChange 被触发</li>
<li>现在每一次设备的朝向改变你都会得到通知，同时你也保持 focusPoint 一直更新</li>
</ul>
<h4 id="Update-the-focus-node"><a href="#Update-the-focus-node" class="headerlink" title="Update the focus node"></a>Update the focus node</h4><ul>
<li>基于屏幕的 focus point 持续地更新 focus node</li>
</ul>
<blockquote>
<p>Helper Functions</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func updateFocusNode() &#123;</span><br><span class="line">  // 1</span><br><span class="line">  let results = self.sceneView.hitTest(self.focusPoint, </span><br><span class="line">    types: [.existingPlaneUsingExtent])</span><br><span class="line">  // 2 </span><br><span class="line">  if results.count == 1 &#123;</span><br><span class="line">    if let match = results.first &#123;</span><br><span class="line">      // 3</span><br><span class="line">      let t = match.worldTransform</span><br><span class="line">     // 4</span><br><span class="line">      self.focusNode.position = SCNVector3( x: t.columns.3.x, y: t.columns.3.y,</span><br><span class="line">        z: t.columns.3.z)</span><br><span class="line">      self.gameState = .swipeToPlay</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 5</span><br><span class="line">    self.gameState = .pointToSurface</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>sceneView.hitTest() 执行一个 ray cast，你提供一个屏幕位置，也就是发射射线的位置，你也需要提供你正在寻找的对象的类型，.existingPlaneUsingExtent 具体说明了你只搜寻那些基于自身范围大小的已侦测到的平面，hits 被保存在 results 中。当然你还可以基于其他类型执行 ray cast，例如 featurePoints，estimatedHorizontalPlane，existingPlane.</li>
<li>你只需要寻找第一个 hit 结果，因此一旦发现，你要准备去更新 focus node</li>
<li>你将会使用 hit 结果的 worldTransform，这个矩阵包括位置，朝向，以及范围大小信息</li>
<li>你将基于 hit 结果 的 transform matrix 来更新 focus node 的位置，位置信息位于 transform matrix 的第三列</li>
<li>如果结果未被发现，游戏将会持续指导玩家去指向已被侦测到的平面</li>
</ol>
<blockquote>
<p>SceneKit Management</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func renderer(_ renderer: SCNSceneRenderer, updateAtTime time: TimeInterval) &#123;</span><br><span class="line">    DispatchQueue.main.async &#123;</span><br><span class="line">      //self.statusLabel.text = self.trackingStatus</span><br><span class="line">      self.updateStatus()</span><br><span class="line">      self.updateFocusNode()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>你现在应该看见了侦测到的平面，focus node 会立即弹出并且跟随你，随着你的指向而移动</li>
</ul>
<h4 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h4><ul>
<li>你可能会注意到有时候你的平面会部分重叠，ARKit 有时会合并多个侦测到的平面为一个平面，为了做到这个，ARKit 在创建新的之前需要去删除旧的平面，问题在于你还未执行 renderer(_:didRemove:for) 方法</li>
</ul>
<blockquote>
<p>Helper Functions</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func removeARPlaneNode(node: SCNNode) &#123;</span><br><span class="line">    for childNode in node.childNodes &#123;</span><br><span class="line">      childNode.removeFromParentNode()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Plane Management</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func renderer(_ renderer: SCNSceneRenderer, didRemove node: SCNNode, for anchor: ARAnchor) &#123;</span><br><span class="line">    guard anchor is ARPlaneAnchor else &#123; return &#125;</span><br><span class="line">    DispatchQueue.main.async &#123;</span><br><span class="line">      self.removeARPlaneNode(node: node)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h1 id="Chapter-6-Add-Physics"><a href="#Chapter-6-Add-Physics" class="headerlink" title="Chapter 6: Add Physics"></a>Chapter 6: Add Physics</h1><h2 id="The-physics-body"><a href="#The-physics-body" class="headerlink" title="The physics body"></a>The physics body</h2><ul>
<li><p>为了使对象能够参与到 SceneKit 内置的物理模拟环境中，你必须要为对象的 SCNode 新增SCNPhysicsBody</p>
</li>
<li><p>这里有三种基本的物理形态：</p>
</li>
</ul>
<ol>
<li>静态：本质上就是静止，例如城墙，在模拟环境中，其他物理形态物体将会和静态物体相互作用，但不会有任何反应，它将保持静止状态</li>
<li>动态: 完全被物理引擎所控制，在模拟环境中，动态物体可以四处移动与其他物理形态物体相互作用，例如骰子和球</li>
<li>运动态: 不被物理模拟环境所控制，被编程控制。允许你创建动态可移动的对象参与到物理模拟环境中去，例如越狱类游戏中的短浆</li>
</ol>
<h2 id="Controll-the-physics-world-speed"><a href="#Controll-the-physics-world-speed" class="headerlink" title="Controll the physics world speed"></a>Controll the physics world speed</h2><blockquote>
<p>initScene()</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scene.physicsWorld.speed = 0.05</span><br></pre></td></tr></table></figure>
<h2 id="Controll-the-physics-simulation-speed"><a href="#Controll-the-physics-simulation-speed" class="headerlink" title="Controll the physics simulation speed"></a>Controll the physics simulation speed</h2><blockquote>
<p>initScene()</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scene.physicsWorld.timeStep = 1.0 / 60.0</span><br></pre></td></tr></table></figure>
<h2 id="Recover-fallen-dice"><a href="#Recover-fallen-dice" class="headerlink" title="Recover fallen dice"></a>Recover fallen dice</h2><ul>
<li>为了防止骰子掉入无尽的深渊，你需要实时监视每一个骰子的位置，当位置低于特定的点时，骰子可以返回玩家手中</li>
</ul>
<blockquote>
<p>Helper Functions</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func updateDiceNodes() &#123;       </span><br><span class="line">   // 1</span><br><span class="line">   for node in sceneView.scene.rootNode.childNodes &#123;</span><br><span class="line">     // 2</span><br><span class="line">     if node.name == &quot;dice&quot; &#123;</span><br><span class="line">       if  node.presentation.position.y &lt; -2 &#123;</span><br><span class="line">         // 3</span><br><span class="line">         node.removeFromParentNode()</span><br><span class="line">         diceCount += 1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>你遍历了场景中所有可用的结点</li>
<li>你只对名字为 dice，并且低于地面两米的骰子感兴趣</li>
<li>一旦你发现了符合条件的骰子结点，你将会把它从场景中移除掉，然后 diceCountOnce 增加 1 ，本质上就是骰子重新回到了玩家手中</li>
</ol>
<blockquote>
<p>SceneKit Management</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func renderer(_ renderer: SCNSceneRenderer, updateAtTime time: TimeInterval) &#123;</span><br><span class="line">    DispatchQueue.main.async &#123;</span><br><span class="line">      //self.statusLabel.text = self.trackingStatus</span><br><span class="line">      self.updateStatus()</span><br><span class="line">      self.updateFocusNode()</span><br><span class="line">      self.updateDiceNodes()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Add-plane-physics"><a href="#Add-plane-physics" class="headerlink" title="Add plane physics"></a>Add plane physics</h2><blockquote>
<p>Helper Functions</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func createARPlanePhysics(geometry: SCNGeometry) -&gt; SCNPhysicsBody &#123;</span><br><span class="line">    // 1</span><br><span class="line">    let physicsBody = SCNPhysicsBody(</span><br><span class="line">        type: .kinematic,</span><br><span class="line">        // 2</span><br><span class="line">        shape: SCNPhysicsShape(geometry: geometry,</span><br><span class="line">          options: nil))</span><br><span class="line">    // 3</span><br><span class="line">    physicsBody.restitution = 0.5</span><br><span class="line">    physicsBody.friction = 0.5</span><br><span class="line">    // 4</span><br><span class="line">    return physicsBody</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>创建了一个运动态，除了你可以移动它之外，其他都与静态非常类似</li>
<li>第二个参数是一个物理形状，SCNPhysicsShape() 非常聪明，如果你提供对象的几何信息，它将会自动地为 3D 物体创建一个合适的形状，还有一个为 nil 的附加选项，由于你都是使用简单的平面，物理形状都会非常简单</li>
<li>调整平面的弹性和粗糙程度</li>
<li>返回结果给调用者</li>
</ol>
<blockquote>
<p>createARPlaneNode(planeAnchor:color:)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">planeNode.physicsBody = createARPlanePhysics(geometry: planeGeometry)</span><br></pre></td></tr></table></figure>
<ul>
<li>当创建 AR 平面结点时，你同时也需要为平面结点创建物理形态，现在，当 AR 平面结点被创建时，它会附有一个物理形态</li>
</ul>
<blockquote>
<p>updateARPlaneNode(planeNode:planeAchor:)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">planeNode.physicsBody = nil</span><br><span class="line">planeNode.physicsBody = createARPlanePhysics(geometry: planeGeometry)</span><br></pre></td></tr></table></figure>
<ul>
<li>通过设置 nil 来达到摧毁之前的物理形态的目的，然后重新创建物理形态，现在，当平面得到更新时，物理形态也同时更新</li>
</ul>
<h2 id="Randomize-rotation"><a href="#Randomize-rotation" class="headerlink" title="Randomize rotation"></a>Randomize rotation</h2><blockquote>
<p>throwDiceNode(transform:offset:)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let rotation = SCNVector3(Double.random(min: 0, max: Double.pi),</span><br><span class="line">  Double.random(min: 0, max: Double.pi),</span><br><span class="line">  Double.random(min: 0, max: Double.pi))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diceNode.eulerAngles = rotation</span><br></pre></td></tr></table></figure>
<h2 id="Add-force"><a href="#Add-force" class="headerlink" title="Add force"></a>Add force</h2><ul>
<li><p>Force 能够在一个特定的点上被施加，可分为有推动力的和无推动力的，有推动力的只能作用于物理形态上，比如投掷出一个骰子。无推动力的会作用于模拟环境的每一步，SceneKit 会将所有的力共同作用于物体并且加速物理形态，比如火箭的推进器，那里的力是持续的</p>
</li>
<li><p>Transform 是一个 SCNMatrix4，也就是 4 x 4 的数学矩阵，当你看到 m41 时，这就是指四行一列的矩阵，矩阵中的每一行都关联了一个 transform 值</p>
</li>
</ul>
<blockquote>
<p>throwDiceNode(transform:offset:)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">let distance = simd_distance(focusNode.simdPosition,</span><br><span class="line">  simd_make_float3(transform.m41,</span><br><span class="line">    transform.m42,</span><br><span class="line">    transform.m43))</span><br><span class="line">// 2        </span><br><span class="line">let direction = SCNVector3(-(distance * 2.5) * transform.m31,</span><br><span class="line">  -(distance * 2.5) * (transform.m32 - Float.pi / 4),</span><br><span class="line">  -(distance * 2.5) * transform.m33)</span><br></pre></td></tr></table></figure>
<ol>
<li>你需要施加一个方向不定的的力给骰子，这个力需要去包括筛子到 focus node 的距离，这行代码计算出了他们两者的距离</li>
<li>你想要去向前投掷出骰子，创建一个向前方向的矢量，包含你刚刚创建的距离，以及骰子的旋转</li>
</ol>
<blockquote>
<p>throwDiceNode(transform:offset:)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">diceNode.physicsBody?.resetTransform()</span><br><span class="line">// 2</span><br><span class="line">diceNode.physicsBody?.applyForce(direction, asImpulse: true)</span><br></pre></td></tr></table></figure>
<ul>
<li>更新了骰子物理形态的位置去匹配它实际的位置</li>
<li>给筛子施加了一个力，将它掷入到特定的方向，并伴随一个小的推动</li>
</ul>
<h2 id="Add-a-shadow-casting-light"><a href="#Add-a-shadow-casting-light" class="headerlink" title="Add a shadow-casting light"></a>Add a shadow-casting light</h2><blockquote>
<p>Properties</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var lightNode: SCNNode!</span><br></pre></td></tr></table></figure>
<blockquote>
<p>loadModels()</p>
</blockquote>
<ul>
<li>从 diceScene 中加载方向光，然后将它添加到 AR 场景</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lightNode = diceScene.rootNode.childNode(withName: &quot;directional&quot;, recursively: false)!</span><br><span class="line">sceneView.scene.rootNode.addChildNode(lightNode)</span><br></pre></td></tr></table></figure>
<h2 id="Light-estimation"><a href="#Light-estimation" class="headerlink" title="Light estimation"></a>Light estimation</h2><blockquote>
<p>initARSession()</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.isLightEstimationEnabled = true</span><br></pre></td></tr></table></figure>
<ul>
<li><p>允许 ARKit 基于侦测到的环境光强度来管理光的强度</p>
</li>
<li><p>当玩家在明亮的环境中，光的强度就会很高，当玩家在黑暗的环境中，光的强度将会变低</p>
</li>
</ul>
<h2 id="Suspend-AR-plane-detection"><a href="#Suspend-AR-plane-detection" class="headerlink" title="Suspend AR plane detection"></a>Suspend AR plane detection</h2><blockquote>
<p>Helper Functions</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func suspendARPlaneDetection() &#123;</span><br><span class="line">  // 1</span><br><span class="line">  let config = sceneView.session.configuration as!</span><br><span class="line">    ARWorldTrackingConfiguration</span><br><span class="line">  // 2</span><br><span class="line">  config.planeDetection = []</span><br><span class="line">  // 3</span><br><span class="line">  sceneView.session.run(config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>从 session 中得到了目前的配置信息</li>
<li>通过设置空数组清除了 planeDetection 属性 </li>
<li>重新运行，现在 ARKit 知道侦测更多的平面时该如何不去耗能</li>
</ol>
<h2 id="Hide-visible-planes"><a href="#Hide-visible-planes" class="headerlink" title="Hide visible planes"></a>Hide visible planes</h2><ul>
<li>显示所有被侦测的平面是无意义的，最好的办法是把它们移除</li>
</ul>
<blockquote>
<p>Helper Functions</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func hideARPlaneNodes() &#123;</span><br><span class="line">    // 1</span><br><span class="line">    for anchor in</span><br><span class="line">      (self.sceneView.session.currentFrame?.anchors)! &#123;</span><br><span class="line">      // 2 </span><br><span class="line">      if let node = self.sceneView.node(for: anchor) &#123;</span><br><span class="line">        // 3</span><br><span class="line">        for child in node.childNodes &#123;</span><br><span class="line">          // 4</span><br><span class="line">          let material = child.geometry?.materials.first!</span><br><span class="line">          material?.colorBufferWriteMask = []</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>在 SceneView 遍历出所有可获得的锚，这一步是通过访问当前的 frame 来实现</li>
<li>得到当前锚相关联的结点</li>
<li>一旦你得到了相关联的结点，隐藏它和它的子对象</li>
<li>你只干星期第一个可获得的 material，一旦你得到它，你就能够通过设置空数组来清除它的颜色，这就简单地清除了结点 material 的所有颜色信息，最终达到隐藏结点的目的</li>
</ol>
<h2 id="Block-swipe-gestures"><a href="#Block-swipe-gestures" class="headerlink" title="Block swipe gestures"></a>Block swipe gestures</h2><ul>
<li>游戏还未开始，玩家不允许去投掷骰子</li>
</ul>
<blockquote>
<p>swipeUpGestureHandler(_:)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">guard gameState == .swipeToPlay else &#123; return &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Start-the-game"><a href="#Start-the-game" class="headerlink" title="Start the game"></a>Start the game</h2><blockquote>
<p>Helper Functions </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func startGame() &#123;</span><br><span class="line">  DispatchQueue.main.async &#123;</span><br><span class="line">    self.startButton.isHidden = true</span><br><span class="line">    self.suspendARPlaneDetection()</span><br><span class="line">    self.hideARPlaneNodes()</span><br><span class="line">    self.gameState = .pointToSurface</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>startButtonPressed(_:)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.startGame()</span><br></pre></td></tr></table></figure>
<h2 id="Reset-the-game"><a href="#Reset-the-game" class="headerlink" title="Reset the game"></a>Reset the game</h2><blockquote>
<p>Helper Functions</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func resetARSession() &#123;</span><br><span class="line">  // 1</span><br><span class="line">  let config = sceneView.session.configuration as!</span><br><span class="line">    ARWorldTrackingConfiguration</span><br><span class="line">  config.planeDetection = .horizontal</span><br><span class="line">  sceneView.session.run(config,</span><br><span class="line">    // 2</span><br><span class="line">    options: [.resetTracking, .removeExistingAnchors])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过调整存在的 AR 配置来重新启动水平平面侦测</li>
<li>重新运行配置时，你传入了附加选项<ul>
<li>.resetTracking 本质上将会重启 ARKit</li>
<li>.removeExistingAnchors 将会摧毁之前侦测到的所有锚以及所有侦测到的平面结点</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func resetGame() &#123;</span><br><span class="line">  DispatchQueue.main.async &#123;</span><br><span class="line">    self.startButton.isHidden = false</span><br><span class="line">    self.resetARSession()</span><br><span class="line">    self.gameState = .detectSurface</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>resetButtonPressed(_:)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.resetGame()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>sessionInterruptionEnded()</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.resetGame()</span><br></pre></td></tr></table></figure>
<ul>
<li>当出现问题的时候，这一招会特别好用， 例如当用户切换到另一个 App 时，或者是玩游戏的时候接了一个电话，这些情况发生时，直接重置游戏</li>
</ul>
<h2 id="Add-interaction"><a href="#Add-interaction" class="headerlink" title="Add interaction"></a>Add interaction</h2><ul>
<li>Hit test：有专门的函数可以执行 hit test，你需要做的只是提供用户触摸屏幕时的位置，SceneKit 将会发射一束射线进入增强现实场景，被射线所命中的物体将会被认为是 “hit” </li>
</ul>
<blockquote>
<p>Actions</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">override func touchesBegan(_ touches: Set&lt;UITouch&gt;,</span><br><span class="line">  with event: UIEvent?) &#123;</span><br><span class="line">  DispatchQueue.main.async &#123;</span><br><span class="line">    // 1</span><br><span class="line">    if let touchLocation = touches.first?.location(</span><br><span class="line">      in: self.sceneView) &#123;</span><br><span class="line">      // 2</span><br><span class="line">      if let hit = self.sceneView.hitTest(touchLocation,</span><br><span class="line">        options: nil).first &#123;</span><br><span class="line">        // 3</span><br><span class="line">        if hit.node.name == &quot;dice&quot; &#123;</span><br><span class="line">          // 4</span><br><span class="line">          hit.node.removeFromParentNode()</span><br><span class="line">          self.diceCount += 1</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>获得用户触摸屏幕的位置</li>
<li>使用被触摸的点作为 hit test 的开始点</li>
<li>你只感兴趣玩家触摸的是否是骰子</li>
<li>如果玩家确实触摸的是一个骰子，把它从场景中移除掉，并且通过增加 diceCount 来达到返回到玩家的手中的目的</li>
</ol>
</div></article></div></main><footer><div class="paginator"><a href="/2018/09/23/arkitSection2/" class="prev">PREV</a><a href="/2018/07/08/loser/" class="next">NEXT</a></div><div class="copyright"><p>© 2017 - 2018 <a href="http://yoursite.com"></a> <a href="https://hexo.io/" target="_blank"> </a> <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank"> </a></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>