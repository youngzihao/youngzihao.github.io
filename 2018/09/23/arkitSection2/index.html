<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> ARKit by Tutorials Section Ⅱ 野生笔记 · Autobiography</title><meta name="description" content="ARKit by Tutorials Section Ⅱ 野生笔记 - null"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Autobiography"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.svg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/youngzihao" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">ARKit by Tutorials Section Ⅱ 野生笔记</h1><div class="post-info">Sep 23, 2018</div><div class="post-content"><h1 id="Chapter-7-Get-Started-Portal-App"><a href="#Chapter-7-Get-Started-Portal-App" class="headerlink" title="Chapter 7: Get Started: Portal App"></a>Chapter 7: Get Started: Portal App</h1><h2 id="Get-started"><a href="#Get-started" class="headerlink" title="Get started"></a>Get started</h2><ul>
<li><p>ARKit 处理所有的传感器和摄像头数据，但是不会生成任何虚拟内容，你需要依靠其他框架在场景中增加虚拟内容，例如 SceneKit 或 SpriteKit</p>
</li>
<li><p>ARSCNView 是苹果提供一种的框架，能够轻松整合 ARKit 数据和 SceneKit</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">@IBOutlet var sceneView: ARSCNView?</span><br><span class="line">// 2</span><br><span class="line">@IBOutlet weak var messageLabel: UILabel?</span><br><span class="line">// 3</span><br><span class="line">@IBOutlet weak var sessionStateLabel: UILabel?</span><br></pre></td></tr></table></figure>
<ol>
<li>sceneView 被用来给摄像头视图增加 3D 物体</li>
<li>显示指示信息</li>
<li>显示会话状态</li>
</ol>
<h2 id="Setting-up-ARKit"><a href="#Setting-up-ARKit" class="headerlink" title="Setting up ARKit"></a>Setting up ARKit</h2><ul>
<li>开始的第一步是使用摄像头去捕捉视频流，你将用到一个 ARSCNView 对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func runSession() &#123;</span><br><span class="line">  // 1  </span><br><span class="line">  let configuration = ARWorldTrackingConfiguration.init()</span><br><span class="line">  // 2</span><br><span class="line">  configuration.planeDetection = .horizontal</span><br><span class="line">  // 3</span><br><span class="line">  configuration.isLightEstimationEnabled = true</span><br><span class="line">  // 4</span><br><span class="line">  sceneView?.session.run(configuration)</span><br><span class="line"></span><br><span class="line">  // 5</span><br><span class="line">  #if DEBUG</span><br><span class="line">    sceneView?.debugOptions = [ARSCNDebugOptions.showFeaturePoints]</span><br><span class="line">  #endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>实例化了一个 ARWorldTrackingConfiguration，并为 ARSession 定义了配置，这有两种类型的配置：<code>ARSessionConfiguration</code> 和 <code>ARWorldTrackingConfiguration</code></li>
<li>configuration.planeDetection 被设置为侦测水平平面，平面范围大小可以改变，随着摄像机移动,多个平面可以合成为一个平面</li>
<li>启用光线估计计算，被生成图像的框架采用，使得虚拟内容看上去更加真实</li>
<li>根据配置来开启 AR 的处理进程。将会开启 AR 会话以及来自摄像头的视频流捕捉，最后显示在 sceneView 上</li>
<li>排错设置，增加可视的光点，覆盖在摄像头视图上</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func resetLabels() &#123;</span><br><span class="line">  messageLabel?.alpha = 1.0</span><br><span class="line">  messageLabel?.text =</span><br><span class="line">    &quot;Move the phone around and allow the app to find a plane.&quot; +</span><br><span class="line">    &quot;You will see a yellow horizontal plane.&quot;</span><br><span class="line">  sessionStateLabel?.alpha = 0.0</span><br><span class="line">  sessionStateLabel?.text = &quot;&quot;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>设置标签的默认值，调整 messageLabel 和 sessionStateLabel 的不透明度和内容，messageLabel 给用户显示指令，然而 sessionStateLabel 被用来显示错误信息，此情况下属于有地方出错</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">  super.viewDidLoad()    </span><br><span class="line">  resetLabels()</span><br><span class="line">  runSession()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>启动时加载视图的时候开启 ARKit session </li>
</ul>
<h2 id="Plane-detection-and-rendering"><a href="#Plane-detection-and-rendering" class="headerlink" title="Plane detection and rendering"></a>Plane detection and rendering</h2><ul>
<li>扩展  PortalViewController 以至于它能够执行 ARSCNViewDelegate 协议</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extension PortalViewController: ARSCNViewDelegate &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>设置 sceneView 的 delegate 为 PortalViewController</li>
</ul>
<blockquote>
<p>runSession()</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sceneView?.delegate = self</span><br></pre></td></tr></table></figure>
<blockquote>
<p>extension</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">func renderer(_ renderer: SCNSceneRenderer,</span><br><span class="line">              didAdd node: SCNNode,</span><br><span class="line">              for anchor: ARAnchor) &#123;</span><br><span class="line">  // 2</span><br><span class="line">  DispatchQueue.main.async &#123;</span><br><span class="line">    // 3</span><br><span class="line">    if let planeAnchor = anchor as? ARPlaneAnchor &#123;</span><br><span class="line">        // 4</span><br><span class="line">      #if DEBUG</span><br><span class="line">        // 5</span><br><span class="line">        let debugPlaneNode = createPlaneNode(</span><br><span class="line">          center: planeAnchor.center,</span><br><span class="line">          extent: planeAnchor.extent)</span><br><span class="line">        // 6  </span><br><span class="line">        node.addChildNode(debugPlaneNode)</span><br><span class="line">      #endif</span><br><span class="line">      // 7</span><br><span class="line">      self.messageLabel?.text =</span><br><span class="line">      &quot;Tap on the detected horizontal plane to place the portal&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>ARPlaneAnchors 被自动添加给了 ARSession 的锚数组，ARSCNView 自动将 ARPlaneAnchor 对象转换成为 SCNNode nodes，为了去提供这些平面，你需要在 ARSCNViewDelegate 扩展中去执行 delegate 方法</li>
</ul>
<ol>
<li>当ARSession 侦测到了一个新的平面时，renderer(_:didAdd:for:) 被调用，ARSCNView 会自动为这个平面增加一个 ARPlaneAnchor</li>
<li>这个调用发生在后台线程，但在这里，你将代码块发送到主线程，因为任何更新 UI 的操作都应该在主线程中完成</li>
<li>检查了 ARAnchor 是否是一个 ARPlaneAnchor</li>
<li>检查你是否在排错模式</li>
<li>如果是这样，通过传入 planeAnchor 的中心和范围大小来创建 plane SCNNode</li>
<li>node 现在是一个空的 SCNNode，通过 ARSCNView 被自动添加到场景中，它的坐标与 ARAnchor 的位置一样，现在你需要添加 debugPlaneNode 作为一个子结点，以至于它能够放置于跟 node 一样的位置上 </li>
<li>最后，无论你是不是在排错模式，你都更新指示消息给玩家，表示准备完毕可以将门放入场景中</li>
</ol>
<blockquote>
<p>SCNNodeHelpers.swift</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import SceneKit</span><br><span class="line"></span><br><span class="line">  // 1</span><br><span class="line">func createPlaneNode(center: vector_float3,</span><br><span class="line">                     extent: vector_float3) -&gt; SCNNode &#123;</span><br><span class="line">  // 2</span><br><span class="line">  let plane = SCNPlane(width: CGFloat(extent.x),</span><br><span class="line">                      height: CGFloat(extent.z))</span><br><span class="line">  // 3</span><br><span class="line">  let planeMaterial = SCNMaterial()</span><br><span class="line">  planeMaterial.diffuse.contents = UIColor.yellow.withAlphaComponent(0.4)</span><br><span class="line">  // 4</span><br><span class="line">  plane.materials = [planeMaterial]</span><br><span class="line">  // 5</span><br><span class="line">  let planeNode = SCNNode(geometry: plane)</span><br><span class="line">  // 6</span><br><span class="line">  planeNode.position = SCNVector3Make(center.x, 0, center.z)</span><br><span class="line">  // 7</span><br><span class="line">  planeNode.transform = SCNMatrix4MakeRotation(-Float.pi / 2, 1, 0, 0)</span><br><span class="line">  // 8</span><br><span class="line">  return planeNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建一个新的 Swift 文件名为 SCNNodeHelpers.swift，这个文件将会包含所有与生成 SCNNode 相关的代码</li>
</ul>
<ol>
<li>createPlaneNode 方法有两个参数， 将提供的平面的中心和范围大小，都是 vector_float3 类型， 表示点坐标，返回一个 SCNNode </li>
<li>通过具体说明平面的宽度和广度实例化了 SCNPlane ，你从 extent 的 x 坐标中得到了宽度，从 z 坐标中得到了高度 </li>
<li>你初始化了 SCNMaterial 并为它配置了 diffuse content，被设置为半透明的黄色</li>
<li>SCNMaterial 被添加给了平面的 materials 数组，定义了平面的材质和颜色</li>
<li>使用 plane 的几何大小创建了一个 SCNNode，SCNPlane 继承自 SCNGeometry 类，这个类提供了可视对象的形状，并由 SceneKit 负责生成，. 你通过将几何图形依附在 SCNNod 进而规定了它的位置和朝向，多个 nodes 可以指向同一个几何大小，允许它出现在一个场景的不同位置</li>
<li>设置 planeNode 的位置，注意 node 被翻译为了 coordinates (center.x, 0, center.z) ，通过 ARPlaneAnchor instance</li>
<li>SceneKit 中的平面默认都是垂直的，因此你需要去旋转 90°使之水平</li>
<li>返回一个 planeNode 对象</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">func renderer(_ renderer: SCNSceneRenderer, didUpdate node: SCNNode,</span><br><span class="line">              for anchor: ARAnchor) &#123;</span><br><span class="line">  // 2              </span><br><span class="line">  DispatchQueue.main.async &#123;</span><br><span class="line">    // 3</span><br><span class="line">    if let planeAnchor = anchor as? ARPlaneAnchor,</span><br><span class="line">      node.childNodes.count &gt; 0 &#123;</span><br><span class="line">      // 4  </span><br><span class="line">      updatePlaneNode(node.childNodes[0],</span><br><span class="line">                      center: planeAnchor.center,</span><br><span class="line">                      extent: planeAnchor.extent)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>ARKit 基于新发现的特征点持续更新平面的位置和范围大小，新增委托方法去接受这些更</li>
</ul>
<ol>
<li>当对应的锚更新时，renderer(_:didUpdate:for:) 方法被调用</li>
<li>UI 元素的更新应该在主线程中 </li>
<li>检查 ARAnchor 是一个 ARPlaneAnchor，然后确认至少它有一个子结点，与 plane’s SCNNode 相符</li>
<li>updatePlaneNode(_:center:extent:) 是一个不久将执行的方法，它通过 ARPlaneAnchor 中的更新值来更新平面的坐标和大小</li>
</ol>
<blockquote>
<p>SCNNodeHelpers.swift</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func updatePlaneNode(_ node: SCNNode,</span><br><span class="line">                     center: vector_float3,</span><br><span class="line">                     extent: vector_float3) &#123;</span><br><span class="line">  // 1                    </span><br><span class="line">  let geometry = node.geometry as? SCNPlane</span><br><span class="line">  // 2</span><br><span class="line">  geometry?.width = CGFloat(extent.x)</span><br><span class="line">  geometry?.height = CGFloat(extent.z)</span><br><span class="line">  // 3</span><br><span class="line">  node.position = SCNVector3Make(center.x, 0, center.z)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>检查是否 node 含有 SCNPlane geometry</li>
<li>使用传入的新值更新 node geometry，也就是使用 ARPlaneAnchor 的范围或大小去更新 plane 的宽度和高度</li>
<li>使用新的位置来更新 plane 的位置</li>
</ol>
<ul>
<li>运行时你将会看到平面的大小和位置随着侦测到新的特征点而改变，仍然有一个问题需要去解决，一旦侦测到平面，如果你离开应用在进来，你将会看到之前侦测到的平面现在在其他对象的顶部，不再匹配它之前侦测的平面，为了解决这个问题，你需要去移除 plane node 当 ARSession 中断时</li>
</ul>
<h1 id="Chapter-8-Add-Objects-to-your-World"><a href="#Chapter-8-Add-Objects-to-your-World" class="headerlink" title="Chapter 8: Add Objects to your World"></a>Chapter 8: Add Objects to your World</h1><h2 id="Get-started-1"><a href="#Get-started-1" class="headerlink" title="Get started"></a>Get started</h2><ul>
<li><p>现在你可以去侦测并生成水平平面，会话有任何中断你则需要去重启会话，当应用切换到后台或者多个应用在前台时，ARSession 会中断，一旦中断，视频捕捉将会失败，ARSession 将不可能做任何追踪，也将不再接受任何传感器数据，当应用返回前台时，生成的平面仍然会在场景中。然而，如果你的设备改变了位置和角度，ARSession 追踪将不再继续，因此你也需要去重启会话</p>
</li>
<li><p>ARSCNViewDelegate 执行 ARSessionObserver 协议，这个协议包括当 ARSession 侦测中断或者会话出错时调用的方法</p>
</li>
</ul>
<blockquote>
<p>extension</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">func session(_ session: ARSession, didFailWithError error: Error) &#123;</span><br><span class="line">  // 2</span><br><span class="line">  guard let label = self.sessionStateLabel else &#123; return &#125;</span><br><span class="line">  showMessage(error.localizedDescription, label: label, seconds: 3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3</span><br><span class="line">func sessionWasInterrupted(_ session: ARSession) &#123;</span><br><span class="line">  guard let label = self.sessionStateLabel else &#123; return &#125;</span><br><span class="line">  showMessage(&quot;Session interrupted&quot;, label: label, seconds: 3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 4</span><br><span class="line">func sessionInterruptionEnded(_ session: ARSession) &#123;</span><br><span class="line">  // 5</span><br><span class="line">  guard let label = self.sessionStateLabel else &#123; return &#125;</span><br><span class="line">  showMessage(&quot;Session resumed&quot;, label: label, seconds: 3)</span><br><span class="line"></span><br><span class="line">  // 6</span><br><span class="line">  DispatchQueue.main.async &#123;</span><br><span class="line">    self.removeAllNodes()</span><br><span class="line">    self.resetLabels()</span><br><span class="line">  &#125;</span><br><span class="line">  // 7</span><br><span class="line">  runSession()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>会话失败时，<code>session(_:, didFailWithError:)</code> 方法被调用。会话会终止并且不会收到任何传感器数据</li>
<li>因为会话失败，设置 sessionStateLabel 文本为错误信息。在规定的时间内， <code>showMessage(_:, label:, seconds:)</code> 在特定的标签上显示信息</li>
<li>切换到后台视频捕捉中断时，<code>sessionWasInterrupted(_:)</code> 方法被调用，直到中断结束也没有额外的帧更新被发送，在标签中显示 “Session interrupted” 三秒</li>
<li>会话中断已经结束时 <code>sessionInterruptionEnded(_:)</code> 方法被调用，一旦中断结束，会话将会从最后一个已知的状态开始，如果设备移动，任何锚都会错位，为了避免这种情况，你需要重启会话</li>
<li>显示 “Session resumed” 三秒</li>
<li>移除之前的生成对象并且重置所有标签，不久后你将执行这些方法，因这些方法更新 UI，因此需要在主线程中调用</li>
<li>重启会话</li>
</ol>
<ul>
<li>debugPlanes 是一组 SCNNode 对象，在排错模式中能够保存所有生成的水平平面</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var debugPlanes: [SCNNode] = []</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">func showMessage(_ message: String, label: UILabel, seconds: Double) &#123;</span><br><span class="line">  label.text = message</span><br><span class="line">  label.alpha = 1</span><br><span class="line"></span><br><span class="line">  DispatchQueue.main.asyncAfter(deadline: .now() + seconds) &#123;</span><br><span class="line">    if label.text == message &#123;</span><br><span class="line">      label.text = &quot;&quot;</span><br><span class="line">      label.alpha = 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2</span><br><span class="line">func removeAllNodes() &#123;</span><br><span class="line">  removeDebugPlanes()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3</span><br><span class="line">func removeDebugPlanes() &#123;</span><br><span class="line">  for debugPlaneNode in self.debugPlanes &#123;</span><br><span class="line">    debugPlaneNode.removeFromParentNode()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  self.debugPlanes = []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>在标签中展示信息，一旦规定的时间过去，重新设置标签能见度和文本</li>
<li><code>removeAllNodes()</code> 移除场景中存在的所有 SCNNode objects，目前你只能移除生成的水平平面</li>
<li>移除场景中所有生成的水平平面，并重置 debugPlanes 数组</li>
</ol>
<blockquote>
<p>renderer(_:, didAdd:, for:) 中添加到 #if DEBUG 预处理程序末尾</p>
</blockquote>
<ul>
<li>将添加到场景中的水平平面增加到 debugPlanes 数组中去</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.debugPlanes.append(debugPlaneNode)</span><br></pre></td></tr></table></figure>
<ul>
<li>替换 <code>sceneView?.session.run(configuration)</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sceneView?.session.run(configuration,</span><br><span class="line">                       options: [.resetTracking, .removeExistingAnchors])</span><br></pre></td></tr></table></figure>
<p>通过传入配置和一组 ARSession.RunOptions 来开启会话, 有以下几种 options：</p>
<ol>
<li>resetTracking：会话不会继续之前配置中的设备位置和运动追踪</li>
<li>removeExistingAnchors：之前配置中任何与会话相关联的锚都会被移除</li>
</ol>
<ul>
<li>打开应用然后切换到后台，重新打开应用，注意场景中之前生成的水平平面已被移除，应用重置了标签显示正确的指令给用户</li>
</ul>
<h2 id="Hit-testing"><a href="#Hit-testing" class="headerlink" title="Hit testing"></a>Hit testing</h2><ul>
<li>你现在将物体放置与被侦测到的水平平面上，你将会使用 ARSCNView 的 hit testing 来侦测屏幕上的用户触摸去找到虚拟场景中他们准备放置物体的地方，屏幕上坐标系中的 2D 点能够通过线段指向 3D 坐标系的任何一点，Hit-testing 就是利用线段找到世界中的物体的过程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var viewCenter: CGPoint &#123;</span><br><span class="line">  let viewBounds = view.bounds</span><br><span class="line">  return CGPoint(x: viewBounds.width / 2.0, y: viewBounds.height / 2.0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123;</span><br><span class="line">  // 2</span><br><span class="line">  if let hit = sceneView?.hitTest(viewCenter, types: [.existingPlaneUsingExtent]).first &#123;</span><br><span class="line">    // 3</span><br><span class="line">    sceneView?.session.add(anchor: ARAnchor.init(transform: hit.worldTransform))      </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>ARSCNView 使得触控有效，当用户点击场景时，touchesBegan() 方法被调用伴随一系列的 UITouch 对象和一个定义 touch 时间的 UIEvent，使此方法优先给 sceneView 增加一个 ARAnchor</li>
<li><p>你调用了 sceneVIew 的 <code>hitTest(_:, types:)</code>，这个 hitTest 方法有两个参数，首先取了一个 view 坐标系中的 CGPoint，也就是屏幕的中心，之后是 ARHitTestResult 要去搜索的类型。这里你使用 existingPlaneUsingExtent 类型，只考虑有限范围大小的平面。</p>
<p><code>hitTest(_:, types:)</code> 的结果是一组所有的 hit test，从最近到最远的，你选择第一个射线相交的第一个 plane，你将从 <code>hitTest(_:, types:)</code>得到结果任何时候，只要屏幕中心落在生成的水平平面上 </p>
</li>
<li><p>在你对象将要被放置的位置增加一个 ARAnchor，ARAnchor 被一个 transformation 矩阵所初始化，这个矩阵定义了锚在世界坐标系中的旋转，角度，转化以及大小</p>
</li>
</ol>
<p>当锚被添加时，在委托方法 <code>renderer(_:didAdd:for:)</code> 中 ARSCNView 接受了一个回调，这就是你生成出入口的地方</p>
<h2 id="Add-crosshairs"><a href="#Add-crosshairs" class="headerlink" title="Add crosshairs"></a>Add crosshairs</h2><ul>
<li>在你增加出入口到场景中之前，还有一件事情，之前你使用屏幕中心来侦测 hit testing，现在你将增加一个 view 去显示屏幕中心来帮助用户定位</li>
</ul>
<blockquote>
<p>extension</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">func renderer(_ renderer: SCNSceneRenderer,</span><br><span class="line">              updateAtTime time: TimeInterval) &#123;</span><br><span class="line">  // 2</span><br><span class="line">  DispatchQueue.main.async &#123;</span><br><span class="line">    // 3</span><br><span class="line">    if let _ = self.sceneView?.hitTest(self.viewCenter,</span><br><span class="line">      types: [.existingPlaneUsingExtent]).first &#123;</span><br><span class="line">      self.crosshair.backgroundColor = UIColor.green</span><br><span class="line">    &#125; else &#123; // 4</span><br><span class="line">      self.crosshair.backgroundColor = UIColor.lightGray</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>这个方法是 SCNSceneRendererDelegate 协议的一部分，这个协议被 ARSCNViewDelegate 执行，它包含很多回调能够被很多次使用去执行操作在生成的过程中，<code>renderer(_: updateAtTime:)</code> 每一帧都被精准地调用，并且应该被用于执行每一帧的逻辑</li>
<li>如果屏幕中心落在侦测的水平平面上，在主线程中同步更新 UI</li>
<li>如果 view center 确实与水平平面相交，就在 sceneView 上执行一次 hit test，如果至少有一个一个结果被侦测到，crosshair view 的背景颜色变为绿色background</li>
<li>hit test 没有返回任何结果，crosshair view 的背景色被设为浅灰色</li>
</ol>
<h2 id="Add-a-state-machine"><a href="#Add-a-state-machine" class="headerlink" title="Add a state machine"></a>Add a state machine</h2><ul>
<li>既然你已经设置侦测平面并且放置了锚，现在你可以开始增加出入口</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var portalNode: SCNNode? = nil</span><br><span class="line">var isPortalPlaced = false</span><br></pre></td></tr></table></figure>
<ul>
<li>makePortal() 正在创建一个出入口结点，其中还有一个方块对象作为占位符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func makePortal() -&gt; SCNNode &#123;</span><br><span class="line">  // 1</span><br><span class="line">  let portal = SCNNode()</span><br><span class="line">  // 2</span><br><span class="line">  let box = SCNBox(width: 1.0,</span><br><span class="line">                   height: 1.0,</span><br><span class="line">                   length: 1.0,</span><br><span class="line">                   chamferRadius: 0)</span><br><span class="line">  let boxNode = SCNNode(geometry: box)</span><br><span class="line">  // 3</span><br><span class="line">  portal.addChildNode(boxNode)  </span><br><span class="line">  return portal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>创建一个 SCNNode 对象，它代表你的出入口 </li>
<li>初始化一个 SCNBox 对象，它其实一个方块，使用 SCNBox geometry 来生成</li>
<li>将 boxNode 作为一个子结点添加到你的出入口，然后返回 portal 结点</li>
</ol>
<ul>
<li>替换 <code>renderer(_:, didAdd:, for:)</code> 和 <code>renderer(_:, didUpdate:, for:)</code> </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">func renderer(_ renderer: SCNSceneRenderer, didAdd node: SCNNode, for anchor: ARAnchor) &#123;</span><br><span class="line">  DispatchQueue.main.async &#123;</span><br><span class="line">    // 1</span><br><span class="line">    if let planeAnchor = anchor as? ARPlaneAnchor, </span><br><span class="line">    !self.isPortalPlaced &#123;</span><br><span class="line">      #if DEBUG</span><br><span class="line">        let debugPlaneNode = createPlaneNode(</span><br><span class="line">          center: planeAnchor.center,</span><br><span class="line">          extent: planeAnchor.extent)</span><br><span class="line">        node.addChildNode(debugPlaneNode)</span><br><span class="line">        self.debugPlanes.append(debugPlaneNode)</span><br><span class="line">      #endif</span><br><span class="line">      self.messageLabel?.alpha = 1.0</span><br><span class="line">      self.messageLabel?.text = &quot;&quot;&quot;</span><br><span class="line">            Tap on the detected \</span><br><span class="line">            horizontal plane to place the portal</span><br><span class="line">            &quot;&quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    else if !self.isPortalPlaced &#123;// 2</span><br><span class="line">        // 3</span><br><span class="line">      self.portalNode = self.makePortal()</span><br><span class="line">      if let portal = self.portalNode &#123;</span><br><span class="line">        // 4</span><br><span class="line">        node.addChildNode(portal)</span><br><span class="line">        self.isPortalPlaced = true</span><br><span class="line">        // 5</span><br><span class="line">        self.removeDebugPlanes()</span><br><span class="line">        self.sceneView?.debugOptions = []</span><br><span class="line">        // 6</span><br><span class="line">        DispatchQueue.main.async &#123;</span><br><span class="line">          self.messageLabel?.text = &quot;&quot;</span><br><span class="line">          self.messageLabel?.alpha = 0</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func renderer(_ renderer: SCNSceneRenderer,</span><br><span class="line">              didUpdate node: SCNNode,</span><br><span class="line">              for anchor: ARAnchor) &#123;</span><br><span class="line">  DispatchQueue.main.async &#123;</span><br><span class="line">    // 7</span><br><span class="line">    if let planeAnchor = anchor as? ARPlaneAnchor,</span><br><span class="line">      node.childNodes.count &gt; 0,</span><br><span class="line">      !self.isPortalPlaced &#123;</span><br><span class="line">      updatePlaneNode(node.childNodes[0],</span><br><span class="line">                      center: planeAnchor.center,</span><br><span class="line">                      extent: planeAnchor.extent)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>只有当添加到场景中的锚是一个 ARPlaneAnchor 时，并且 isPortalPlaced 为假，意味着出入口还未被放置，给场景添加一个水平平面去展示侦测到的平面</li>
<li>如果被添加的锚不是一个 ARPlaneAnchor，并且出入口结点仍然没有被放置，那么这个锚一定是当用户点击屏幕时放置出入口所添加的锚</li>
<li>通过调用 makePortal() 来创建 出入口结点</li>
<li><code>renderer(_:, didAdd:, for:)</code> 在 node 被 放置于场景中时被调用，你想要将传送门结点放置到这个结点的位置上。所以你将传送门结点作为该结点的子结点，然后设置 isPortalPlaced 为真，去追踪传送门结点已经被添加</li>
<li>为了去清理场景，你移除了所有生成的水平平面，然后重置了 debugOptions 以至于特征点不再显示</li>
<li>主线程中更新 messageLabel 重置它的文本并且隐藏它</li>
<li><code>renderer(_:, didUpdate:, for:)</code>只有当所提供的锚是一个 ARPlaneAnchor 并且结点至少有一个子结点以及出入口还未被放置，你更新生成的水平平面</li>
</ol>
<blockquote>
<p>替换 removeAllNodes()</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func removeAllNodes() &#123;</span><br><span class="line">  // 1</span><br><span class="line">  removeDebugPlanes()</span><br><span class="line">  // 2</span><br><span class="line">  self.portalNode?.removeFromParentNode()</span><br><span class="line">  // 3</span><br><span class="line">  self.isPortalPlaced = false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>你移除了所有生成的水平平面</li>
<li>从 portalNode 的父结点中移除 portalNode</li>
<li>设置 isPortalPlaced 变量为假</li>
</ol>
<ul>
<li>运行应用，让应用侦测一个水平平面，当 crosshair view 变为绿色时，点击屏幕，你将会看到一个一个巨大的白色立方体</li>
</ul>
<h1 id="Chapter-9-Geomtry-Textrues-and-lighting"><a href="#Chapter-9-Geomtry-Textrues-and-lighting" class="headerlink" title="Chapter 9: Geomtry, Textrues, and lighting"></a>Chapter 9: Geomtry, Textrues, and lighting</h1><h2 id="The-SceneKit-coordinate-system"><a href="#The-SceneKit-coordinate-system" class="headerlink" title="The SceneKit coordinate system"></a>The SceneKit coordinate system</h2><ul>
<li>SceneKit 用于添加 3D 物体到场景中去，SceneKit 的内容视图由树形等级制度的结点构成，也被称为 scene graph，一个 scene 由一个根结点组成，它为这个 scene 定义了坐标空间，其他的结点则用可视内容占据空间。每一个结点或者 3D 对象都是 SCNNode 类型的。SCNNode 相较于它的父结点定义了坐标空间的 transform (位置，朝向，大小)，但是 SCNNode 自身没有任何的可视内容</li>
<li>场景中的根结点定义了 SceneKit 所生成世界的坐标系统，每一个你添加给根结点的子结点都创造了它自己的坐标系统，并且依次被他们的子结点继承。SceneKit 使用右手定则的坐标系统，默认视野的方向是负 Z 轴 </li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fvnua4qnhnj31kw1daago.jpg" alt=""></p>
<ul>
<li>SCNNode 的位置使用一个 SCNVector3 来进行定义，它能够在父结点的坐标系统中准备定位自己，默认的位置是 zero vector，表示结点被放置于父节点坐标系统的原始位置，SCNVector3 由三组分矢量组成，每一个分矢量是浮点值，代表每一个轴上的坐标</li>
<li>SCNNode 的朝向，也就是 pitch, yaw, 以及被 eulerAngles 属性定义的 roll angles，这些被一个 SCNVector3 struct 所表达，其中的每一个分矢量都是弧度中的一个角度</li>
</ul>
<h2 id="Textures"><a href="#Textures" class="headerlink" title="Textures"></a>Textures</h2><ul>
<li>SCNNode 它自己没有任何的可视对象，通过给结点增加 SCNGeometry 你才向场景中新添 2D 和 3D 对象</li>
<li>Geometries 附上可以决定对象外表的 SCNMaterial，一个 SCNMaterial 中有几个可视的属性，每一个可视属性是一个 SCNMaterialProperty 类的实例，提供了一个纯色，材质，或者其他的 2D 内容。这有许多的可视属性关于基本的阴影，基于环境光的阴影，以及特效，能够使材质变得更加真实</li>
<li>依靠 SceneKit，你能给 nodes 增加 SCNLight 去给 geometries 增加阴影效果</li>
</ul>
<h2 id="Building-the-portal"><a href="#Building-the-portal" class="headerlink" title="Building the portal"></a>Building the portal</h2><blockquote>
<p>SCNNodeHelpers.swift</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">let SURFACE_LENGTH: CGFloat = 3.0</span><br><span class="line">let SURFACE_HEIGHT: CGFloat = 0.2</span><br><span class="line">let SURFACE_WIDTH: CGFloat = 3.0</span><br><span class="line"></span><br><span class="line">// 2</span><br><span class="line">let SCALEX: Float = 2.0</span><br><span class="line">let SCALEY: Float = 2.0</span><br><span class="line"></span><br><span class="line">// 3</span><br><span class="line">let WALL_WIDTH:CGFloat = 0.2</span><br><span class="line">let WALL_HEIGHT:CGFloat = 3.0</span><br><span class="line">let WALL_LENGTH:CGFloat = 3.0</span><br></pre></td></tr></table></figure>
<ol>
<li>定义了传送门中地板和天花板的尺寸，屋顶和天花板的高度就是他们的厚度</li>
<li>定义了用于等比例放大和重复质地的常量</li>
<li>定义墙结点的宽度、高度和长度</li>
</ol>
<blockquote>
<p>SCNNodeHelpers.swift</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">func repeatTextures(geometry: SCNGeometry, scaleX: Float, scaleY: Float) &#123;</span><br><span class="line">  // 1</span><br><span class="line">  geometry.firstMaterial?.diffuse.wrapS = SCNWrapMode.repeat</span><br><span class="line">  geometry.firstMaterial?.selfIllumination.wrapS = SCNWrapMode.repeat</span><br><span class="line">  geometry.firstMaterial?.normal.wrapS = SCNWrapMode.repeat</span><br><span class="line">  geometry.firstMaterial?.specular.wrapS = SCNWrapMode.repeat</span><br><span class="line">  geometry.firstMaterial?.emission.wrapS = SCNWrapMode.repeat</span><br><span class="line">  geometry.firstMaterial?.roughness.wrapS = SCNWrapMode.repeat</span><br><span class="line"></span><br><span class="line">  // 2</span><br><span class="line">  geometry.firstMaterial?.diffuse.wrapT = SCNWrapMode.repeat</span><br><span class="line">  geometry.firstMaterial?.selfIllumination.wrapT = SCNWrapMode.repeat</span><br><span class="line">  geometry.firstMaterial?.normal.wrapT = SCNWrapMode.repeat</span><br><span class="line">  geometry.firstMaterial?.specular.wrapT = SCNWrapMode.repeat</span><br><span class="line">  geometry.firstMaterial?.emission.wrapT = SCNWrapMode.repeat</span><br><span class="line">  geometry.firstMaterial?.roughness.wrapT = SCNWrapMode.repeat</span><br><span class="line"></span><br><span class="line">  // 3</span><br><span class="line">  geometry.firstMaterial?.diffuse.contentsTransform =</span><br><span class="line">    SCNMatrix4MakeScale(scaleX, scaleY, 0)</span><br><span class="line">  geometry.firstMaterial?.selfIllumination.contentsTransform =</span><br><span class="line">    SCNMatrix4MakeScale(scaleX, scaleY, 0)</span><br><span class="line">  geometry.firstMaterial?.normal.contentsTransform =</span><br><span class="line">    SCNMatrix4MakeScale(scaleX, scaleY, 0)</span><br><span class="line">  geometry.firstMaterial?.specular.contentsTransform =</span><br><span class="line">    SCNMatrix4MakeScale(scaleX, scaleY, 0)</span><br><span class="line">  geometry.firstMaterial?.emission.contentsTransform =</span><br><span class="line">    SCNMatrix4MakeScale(scaleX, scaleY, 0)</span><br><span class="line">  geometry.firstMaterial?.roughness.contentsTransform =</span><br><span class="line">    SCNMatrix4MakeScale(scaleX, scaleY, 0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>定义了一个方法在 X 和 Y 轴的方向上去重复质地图像</li>
</ul>
<ol>
<li>这个方法将一个 SCNGeometry 和 X 和 Y 等比例缩放因子作为输入，质地地图使用 S 和 T 坐标系统，其实 S 对应 X，T 对应 Y，这里你为所有可见属性都定义了 S 维度的 wrapping mode 为 SCNWrapMode.repeat</li>
<li>为所有可见属性都定义了 T 维度的 wrapping mode 为SCNWrapMode.repeat，质地只使用了质地坐标的一小部分.</li>
<li>这里，每一个可视特性 contentsTransform 都被设置成了 SCNMatrix4 struct 描绘的 scale transform，你分别设置 X 和 Y 的缩放比例因子为 scaleX 和 scaleY</li>
</ol>
<blockquote>
<p>SCNNodeHelpers:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func makeOuterSurfaceNode(width: CGFloat,</span><br><span class="line">                          height: CGFloat,</span><br><span class="line">                          length: CGFloat) -&gt; SCNNode &#123;</span><br><span class="line">  // 1</span><br><span class="line">  let outerSurface = SCNBox(width: SURFACE_WIDTH,</span><br><span class="line">                            height: SURFACE_HEIGHT,</span><br><span class="line">                            length: SURFACE_LENGTH,</span><br><span class="line">                            chamferRadius: 0)</span><br><span class="line">  </span><br><span class="line">  // 2</span><br><span class="line">  outerSurface.firstMaterial?.diffuse.contents = UIColor.white</span><br><span class="line">  outerSurface.firstMaterial?.transparency = 0.000001</span><br><span class="line">  </span><br><span class="line">  // 3</span><br><span class="line">  let outerSurfaceNode = SCNNode(geometry: outerSurface)</span><br><span class="line">  outerSurfaceNode.renderingOrder = 10</span><br><span class="line">  return outerSurfaceNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>用户进入传送门中，才显示出地板和天花板，其他时候你都需要去隐藏它们</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func makeOuterSurfaceNode(width: CGFloat,</span><br><span class="line">                          height: CGFloat,</span><br><span class="line">                          length: CGFloat) -&gt; SCNNode &#123;</span><br><span class="line">  // 1</span><br><span class="line">  let outerSurface = SCNBox(width: SURFACE_WIDTH,</span><br><span class="line">                            height: SURFACE_HEIGHT,</span><br><span class="line">                            length: SURFACE_LENGTH,</span><br><span class="line">                            chamferRadius: 0)</span><br><span class="line">  </span><br><span class="line">  // 2</span><br><span class="line">  outerSurface.firstMaterial?.diffuse.contents = UIColor.white</span><br><span class="line">  outerSurface.firstMaterial?.transparency = 0.000001</span><br><span class="line">  </span><br><span class="line">  // 3</span><br><span class="line">  let outerSurfaceNode = SCNNode(geometry: outerSurface)</span><br><span class="line">  outerSurfaceNode.renderingOrder = 10</span><br><span class="line">  return outerSurfaceNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>使用地板和天花板的尺寸大小去创建一个 outerSurface 场景立方几何体</li>
<li>为立方体设置漫反射属性使其渲染出来，设置透明度为一个非常低的值以至于对象能够在视图中隐藏 </li>
<li>通过 outerSurface geometry 来创建一个 SCNNode，为 node 设置渲染 为 10，渲染顺序越大也就越后渲染，为了使天花板和地板在传送口的外部不可见，你要使内部天花板和地板的远远大于 10</li>
</ol>
<blockquote>
<p>SCNNodeHelpers</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">func makeFloorNode() -&gt; SCNNode &#123;</span><br><span class="line">  // 1</span><br><span class="line">  let outerFloorNode = makeOuterSurfaceNode(</span><br><span class="line">                       width: SURFACE_WIDTH,</span><br><span class="line">                       height: SURFACE_HEIGHT,</span><br><span class="line">                       length: SURFACE_LENGTH)</span><br><span class="line">  </span><br><span class="line">  // 2</span><br><span class="line">  outerFloorNode.position = SCNVector3(SURFACE_HEIGHT * 0.5,</span><br><span class="line">                                       -SURFACE_HEIGHT, 0)</span><br><span class="line">  let floorNode = SCNNode()</span><br><span class="line">  floorNode.addChildNode(outerFloorNode)</span><br><span class="line"></span><br><span class="line">  // 3</span><br><span class="line">  let innerFloor = SCNBox(width: SURFACE_WIDTH,</span><br><span class="line">                          height: SURFACE_HEIGHT,</span><br><span class="line">                          length: SURFACE_LENGTH,</span><br><span class="line">                          chamferRadius: 0)</span><br><span class="line">  </span><br><span class="line">  // 4</span><br><span class="line">  innerFloor.firstMaterial?.lightingModel = .physicallyBased</span><br><span class="line">  innerFloor.firstMaterial?.diffuse.contents =</span><br><span class="line">    UIImage(named: </span><br><span class="line">    &quot;Assets.scnassets/floor/textures/Floor_Diffuse.png&quot;)</span><br><span class="line">  innerFloor.firstMaterial?.normal.contents =</span><br><span class="line">    UIImage(named: </span><br><span class="line">    &quot;Assets.scnassets/floor/textures/Floor_Normal.png&quot;)</span><br><span class="line">  innerFloor.firstMaterial?.roughness.contents =</span><br><span class="line">    UIImage(named:</span><br><span class="line">    “Assets.scnassets/floor/textures/Floor_Roughness.png&quot;)</span><br><span class="line">  innerFloor.firstMaterial?.specular.contents =</span><br><span class="line">    UIImage(named: </span><br><span class="line">    &quot;Assets.scnassets/floor/textures/Floor_Specular.png&quot;)</span><br><span class="line">  innerFloor.firstMaterial?.selfIllumination.contents =</span><br><span class="line">    UIImage(named: </span><br><span class="line">    &quot;Assets.scnassets/floor/textures/Floor_Gloss.png&quot;)</span><br><span class="line">  </span><br><span class="line">  // 5  </span><br><span class="line">  repeatTextures(geometry: innerFloor, </span><br><span class="line">                 scaleX: SCALEX, scaleY: SCALEY)</span><br><span class="line">  </span><br><span class="line">  // 6</span><br><span class="line">  let innerFloorNode = SCNNode(geometry: innerFloor)</span><br><span class="line">  innerFloorNode.renderingOrder = 100</span><br><span class="line">  </span><br><span class="line">  // 7</span><br><span class="line">  innerFloorNode.position = SCNVector3(SURFACE_HEIGHT * 0.5, </span><br><span class="line">                                       0, 0)</span><br><span class="line">  floorNode.addChildNode(innerFloorNode)</span><br><span class="line">  return floorNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>使用地板的大小来创建地板结点</li>
<li>放置 outerFloorNode，使其位于地板节点的底面下方，将其添加到 floorNode 上,这个节点将会同时持有地板的内层和外层表面</li>
<li>使用 SCNBox 来生成地板的几何形状</li>
<li>地板材质的光照模型被设置为 physicallyBased，这种类型的阴影包含了一种物理光和物理材质的真实抽象感觉，材质可见属性的内容都来自 scnassets catalog 中的质地图片</li>
<li>材质的质地使用你之前定义的 repeatTextures() 方法在 X 和 Y 方向上重复</li>
<li>使用 innerFloor geometry object 给地板创建一个结点，然后设置渲染顺序高于outerFloorNode，这确保了当用户位于传送门之外时，地板结点将不可见</li>
<li>最后，设置 innerFloorNode 的位置位于 outerFloorNode 之上，并添加给 floorNode 作为子结点，返回地板结点给函数调用者</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let POSITION_Y: CGFloat = -WALL_HEIGHT*0.5</span><br><span class="line">let POSITION_Z: CGFloat = -SURFACE_LENGTH*0.5</span><br></pre></td></tr></table></figure>
<ul>
<li>这些常量代表结点在 Y 和 Z 维度上的偏移</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func makePortal() -&gt; SCNNode &#123;</span><br><span class="line">  // 1</span><br><span class="line">  let portal = SCNNode()</span><br><span class="line">  </span><br><span class="line">  // 2</span><br><span class="line">  let floorNode = makeFloorNode()</span><br><span class="line">  floorNode.position = SCNVector3(0, POSITION_Y, POSITION_Z)</span><br><span class="line">  </span><br><span class="line">  // 3</span><br><span class="line">  portal.addChildNode(floorNode)</span><br><span class="line">  return portal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>创建一个 SCNNode 来存储传送门</li>
<li>使用定义的 makeFloorNode() 方法来创建地板结点，使用位置偏移量来设置地板结点的位置。SCNGeometry 的中心会被设置为对准父节点坐标系中的坐标位置</li>
<li>为传送门结点增添地板结点然后返回传送门结点，注意，当用户点击视图时，renderer(_ :, didAdd:, for:) 中传送门结点被添加给了锚位置上所创建的结点</li>
</ol>
<ul>
<li>运行之后，你会发现地板结点是黑暗的，因为你还没有添加光源，现在开始添加天花板结点</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">func makeCeilingNode() -&gt; SCNNode &#123;</span><br><span class="line">  // 1</span><br><span class="line">  let outerCeilingNode = makeOuterSurfaceNode(</span><br><span class="line">                          width: SURFACE_WIDTH,</span><br><span class="line">                          height: SURFACE_HEIGHT,</span><br><span class="line">                          length: SURFACE_LENGTH)</span><br><span class="line">  </span><br><span class="line">  // 2                                            </span><br><span class="line">  outerCeilingNode.position = SCNVector3(SURFACE_HEIGHT * 0.5,</span><br><span class="line">                                         SURFACE_HEIGHT, 0)</span><br><span class="line">  let ceilingNode = SCNNode()</span><br><span class="line">  ceilingNode.addChildNode(outerCeilingNode)</span><br><span class="line"></span><br><span class="line">  // 3</span><br><span class="line">  let innerCeiling = SCNBox(width: SURFACE_WIDTH,</span><br><span class="line">                            height: SURFACE_HEIGHT,</span><br><span class="line">                            length: SURFACE_LENGTH,</span><br><span class="line">                            chamferRadius: 0)</span><br><span class="line">  </span><br><span class="line">  // 4                            </span><br><span class="line">  innerCeiling.firstMaterial?.lightingModel = .physicallyBased</span><br><span class="line">  innerCeiling.firstMaterial?.diffuse.contents =</span><br><span class="line">    UIImage(named: </span><br><span class="line">    &quot;Assets.scnassets/ceiling/textures/Ceiling_Diffuse.png&quot;)</span><br><span class="line">  innerCeiling.firstMaterial?.emission.contents =</span><br><span class="line">    UIImage(named: </span><br><span class="line">    &quot;Assets.scnassets/ceiling/textures/Ceiling_Emis.png&quot;)</span><br><span class="line">  innerCeiling.firstMaterial?.normal.contents =</span><br><span class="line">    UIImage(named: </span><br><span class="line">    &quot;Assets.scnassets/ceiling/textures/Ceiling_Normal.png&quot;)</span><br><span class="line">  innerCeiling.firstMaterial?.specular.contents =</span><br><span class="line">    UIImage(named: </span><br><span class="line">    &quot;Assets.scnassets/ceiling/textures/Ceiling_Specular.png&quot;)</span><br><span class="line">  innerCeiling.firstMaterial?.selfIllumination.contents =</span><br><span class="line">    UIImage(named: </span><br><span class="line">    &quot;Assets.scnassets/ceiling/textures/Ceiling_Gloss.png&quot;)</span><br><span class="line">  </span><br><span class="line">  // 5</span><br><span class="line">  repeatTextures(geometry: innerCeiling, scaleX: </span><br><span class="line">                 SCALEX, scaleY: SCALEY)</span><br><span class="line">  </span><br><span class="line">  // 6</span><br><span class="line">  let innerCeilingNode = SCNNode(geometry: innerCeiling)</span><br><span class="line">  innerCeilingNode.renderingOrder = 100</span><br><span class="line">  // 7</span><br><span class="line">  innerCeilingNode.position = SCNVector3(SURFACE_HEIGHT * 0.5, </span><br><span class="line">                                         0, 0)</span><br><span class="line">  ceilingNode.addChildNode(innerCeilingNode)  </span><br><span class="line">  return ceilingNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>类似于地板结点，你用地板的大小创建了一个 outerCeilingNode </li>
<li>设置外层天花板结点的位置以至于它能够位于天花板的上方，创建一个结点去持有内层天花板和外层天花板，增加 outerCeilingNode 为 ceilingNode 的子结点</li>
<li>给 innerCeiling 创建一个 SCNBox object</li>
<li>地板材质的光照模型被设置为 physicallyBased，材质可见属性的内容都来自 scnassets catalog 中的质地图片</li>
<li>材质的质地使用你之前定义的 repeatTextures() 方法在 X 和 Y 方向上重复</li>
<li>使用 innerCeiling geometry 创建 innerCeilingNode，然后设置它的 渲染顺序为高值，为了能够在 outerCeilingNode 之后被渲染</li>
<li>在父节点中设置 innerCeilingNode 的位置，然后将它添加作为 ceilingNode 的子结点，返回 ceilingNode 给调用者</li>
</ol>
<blockquote>
<p>makePortal() 中添加到 return 之前</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">let ceilingNode = makeCeilingNode()</span><br><span class="line">ceilingNode.position = SCNVector3(0,</span><br><span class="line">                                  POSITION_Y+WALL_HEIGHT,</span><br><span class="line">                                  POSITION_Z)</span><br><span class="line">// 2</span><br><span class="line">portal.addChildNode(ceilingNode)</span><br></pre></td></tr></table></figure>
<ol>
<li><p>使用你刚刚定义的 makeCeilingNode() 来创建天花板结点，设置 ceilingNode 的位置为  SCNVector3 struct，中心点的Y坐标,偏移了地板厚度加墙壁高度的位置.</p>
<p>你也可以减掉 SURFACE_HEIGHT 来得到天花板的厚度，类似于地板，Z坐标偏移也设置为POSITION_Z，这就是天花板中心点到摄像机在Z轴上的距离</p>
</li>
<li>Add ceilingNode as a child of the portal.</li>
</ol>
<ul>
<li>添加 ceilingNode 作为传送门的子节点</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">func makeWallNode(length: CGFloat = WALL_LENGTH,</span><br><span class="line">                  height: CGFloat = WALL_HEIGHT,</span><br><span class="line">                  maskLowerSide:Bool = false) -&gt; SCNNode &#123;</span><br><span class="line">    </span><br><span class="line">  // 1                      </span><br><span class="line">  let outerWall = SCNBox(width: WALL_WIDTH,</span><br><span class="line">                         height: height,</span><br><span class="line">                         length: length,</span><br><span class="line">                         chamferRadius: 0)</span><br><span class="line">  // 2                        </span><br><span class="line">  outerWall.firstMaterial?.diffuse.contents = UIColor.white</span><br><span class="line">  outerWall.firstMaterial?.transparency = 0.000001</span><br><span class="line"></span><br><span class="line">  // 3</span><br><span class="line">  let outerWallNode = SCNNode(geometry: outerWall)</span><br><span class="line">  let multiplier: CGFloat = maskLowerSide ? -1 : 1</span><br><span class="line">  outerWallNode.position = SCNVector3(WALL_WIDTH*multiplier,0,0)</span><br><span class="line">  outerWallNode.renderingOrder = 10</span><br><span class="line">  </span><br><span class="line">  // 4</span><br><span class="line">  let wallNode = SCNNode()</span><br><span class="line">  wallNode.addChildNode(outerWallNode)</span><br><span class="line"></span><br><span class="line">  // 5</span><br><span class="line">  let innerWall = SCNBox(width: WALL_WIDTH,</span><br><span class="line">                         height: height,</span><br><span class="line">                         length: length, chamferRadius: 0)</span><br><span class="line">  </span><br><span class="line">  // 6                       </span><br><span class="line">  innerWall.firstMaterial?.lightingModel = .physicallyBased</span><br><span class="line">  innerWall.firstMaterial?.diffuse.contents =</span><br><span class="line">    UIImage(named: </span><br><span class="line">    &quot;Assets.scnassets/wall/textures/Walls_Diffuse.png&quot;)</span><br><span class="line">  innerWall.firstMaterial?.metalness.contents =</span><br><span class="line">    UIImage(named: </span><br><span class="line">    &quot;Assets.scnassets/wall/textures/Walls_Metalness.png&quot;)</span><br><span class="line">  innerWall.firstMaterial?.roughness.contents =</span><br><span class="line">    UIImage(named: </span><br><span class="line">    &quot;Assets.scnassets/wall/textures/Walls_Roughness.png&quot;)</span><br><span class="line">  innerWall.firstMaterial?.normal.contents =</span><br><span class="line">    UIImage(named: </span><br><span class="line">    &quot;Assets.scnassets/wall/textures/Walls_Normal.png&quot;)</span><br><span class="line">  innerWall.firstMaterial?.specular.contents =</span><br><span class="line">    UIImage(named: </span><br><span class="line">    &quot;Assets.scnassets/wall/textures/Walls_Spec.png&quot;)</span><br><span class="line">  innerWall.firstMaterial?.selfIllumination.contents =</span><br><span class="line">    UIImage(named: </span><br><span class="line">    &quot;Assets.scnassets/wall/textures/Walls_Gloss.png&quot;)</span><br><span class="line"></span><br><span class="line">  // 7</span><br><span class="line">  let innerWallNode = SCNNode(geometry: innerWall)</span><br><span class="line">  wallNode.addChildNode(innerWallNode)  </span><br><span class="line">  return wallNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>You create an outerWall node which will sit on the outside of the wall to make it appear transparent from the outside. You create an SCNBox object matching the wall’s dimensions.</li>
<li>You set the diffuse contents of the material to a monochrome white color and the transparency to a low number. This helps achieve the see-through effect if you look at the wall from outside the room.</li>
<li><p>You create a node with the outerWall geometry. The multiplier is set based on which side of the wall the outer wall needs to be rendered. If maskLowerSide is set to true, the outer wall is placed below the inner wall in the wall node’s coordinate system; otherwise, it’s placed above.</p>
<p>You set the position of the node such that the outer wall is offset by the wall width in the X dimension. Set the rendering order for the outer wall to a low number so that it’s rendered first. This makes the walls invisible from the outside.</p>
</li>
<li><p>You also create a node to hold the wall and add the outerWallNode as its child node.</p>
</li>
<li>You make innerWall an SCNBox object with the respective wall dimensions.<br>You set the lightingModel to physicallyBased. Similar to the ceiling and floor nodes, you set the contents of the visual properties that are defined by various texture images for the walls.<br>Finally, you create an innerWallNode object using the innerWall geometry. Add this node to the parent wallNode object. By default, innerWallNode is placed at the origin of wallNode. Return the node to the caller.</li>
</ol>
<blockquote>
<p>makePortal() 中添加到 return 之前</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">let farWallNode = makeWallNode()</span><br><span class="line"></span><br><span class="line">// 2</span><br><span class="line">farWallNode.eulerAngles = SCNVector3(0, </span><br><span class="line">                                     90.0.degreesToRadians, 0)</span><br><span class="line"></span><br><span class="line">// 3</span><br><span class="line">farWallNode.position = SCNVector3(0,</span><br><span class="line">                                  POSITION_Y+WALL_HEIGHT*0.5,</span><br><span class="line">                                  POSITION_Z-SURFACE_LENGTH*0.5)</span><br><span class="line">portal.addChildNode(farWallNode)</span><br></pre></td></tr></table></figure>
<ol>
<li>Create a node for the far wall. farWallNode needs the mask on the lower side. So the default value of false for maskLowerSide will do.</li>
<li>Add eulerAngles to the node. Since the wall is rotated along the Y axis and perpendicular to the camera, it has a rotation of 90 degrees for the second component. The wall does not have a rotation angle for the X and Z axes.</li>
<li>Set the position of the center of farWallNode such that its height is offset by POSITION_Y. Its depth is calculated by adding the depth of the center of the ceiling to the distance from the center of the ceiling to its far end.</li>
</ol>
</div></article></div></main><footer><div class="paginator"><a href="/2018/09/25/designPatternSection1/" class="prev">PREV</a><a href="/2018/09/18/arkitSection1/" class="next">NEXT</a></div><div class="copyright"><p>© 2017 - 2018 <a href="http://yoursite.com"></a> <a href="https://hexo.io/" target="_blank"> </a> <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank"> </a></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>