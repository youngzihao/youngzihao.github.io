<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Feng Shui</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-26T00:45:51.470Z</updated>
  <id>http://yoursite.com/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Design Patterns by Tutorials Section Ⅰ 野生笔记</title>
    <link href="http://yoursite.com/2018/09/25/designPatternSection1/"/>
    <id>http://yoursite.com/2018/09/25/designPatternSection1/</id>
    <published>2018-09-24T16:00:00.000Z</published>
    <updated>2018-09-26T00:45:51.470Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter-1-What-are-Design-Patterns"><a href="#Chapter-1-What-are-Design-Patterns" class="headerlink" title="Chapter 1: What are Design Patterns?"></a>Chapter 1: What are Design Patterns?</h1><h2 id="Get-started"><a href="#Get-started" class="headerlink" title="Get started"></a>Get started</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Chapter-1-What-are-Design-Patterns&quot;&gt;&lt;a href=&quot;#Chapter-1-What-are-Design-Patterns&quot; class=&quot;headerlink&quot; title=&quot;Chapter 1: What are Desi
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ARKit by Tutorials Section Ⅱ 野生笔记</title>
    <link href="http://yoursite.com/2018/09/23/arkitSection2/"/>
    <id>http://yoursite.com/2018/09/23/arkitSection2/</id>
    <published>2018-09-22T16:00:00.000Z</published>
    <updated>2018-09-26T02:51:30.847Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter-7-Get-Started-Portal-App"><a href="#Chapter-7-Get-Started-Portal-App" class="headerlink" title="Chapter 7: Get Started: Portal App"></a>Chapter 7: Get Started: Portal App</h1><h2 id="Get-started"><a href="#Get-started" class="headerlink" title="Get started"></a>Get started</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">@IBOutlet var sceneView: ARSCNView?</span><br><span class="line">// 2</span><br><span class="line">@IBOutlet weak var messageLabel: UILabel?</span><br><span class="line">// 3</span><br><span class="line">@IBOutlet weak var sessionStateLabel: UILabel?</span><br></pre></td></tr></table></figure><ol><li>sceneView 被用来给摄像头视图增加 3D 物体</li><li>显示指示信息</li><li>显示会话状态</li></ol><ul><li><p>ARKit 处理所有的传感器和摄像头数据，但是不会生成任何虚拟内容，你需要依靠其他框架来在场景中增加虚拟内容，例如 SceneKit 或 SpriteKit</p></li><li><p>ARSCNView 是一种苹果提供的框架，能够轻松整合 ARKit 数据和 SceneKit</p></li></ul><h2 id="Setting-up-ARKit"><a href="#Setting-up-ARKit" class="headerlink" title="Setting up ARKit"></a>Setting up ARKit</h2><ul><li>开始的第一步是使用摄像头去捕捉视频流，你将用到一个 ARSCNView 对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func runSession() &#123;</span><br><span class="line">  // 1  </span><br><span class="line">  let configuration = ARWorldTrackingConfiguration.init()</span><br><span class="line">  // 2</span><br><span class="line">  configuration.planeDetection = .horizontal</span><br><span class="line">  // 3</span><br><span class="line">  configuration.isLightEstimationEnabled = true</span><br><span class="line">  // 4</span><br><span class="line">  sceneView?.session.run(configuration)</span><br><span class="line"></span><br><span class="line">  // 5</span><br><span class="line">  #if DEBUG</span><br><span class="line">    sceneView?.debugOptions = [ARSCNDebugOptions.showFeaturePoints]</span><br><span class="line">  #endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>实例化了一个 ARWorldTrackingConfiguration 对象，并为 ARSession 定义了配置，这有两种类型的配置：ARSessionConfiguration 和 ARWorldTrackingConfiguration</li><li>configuration.planeDetection 被设置为侦测水平平面，平面范围大小可以改变，随着摄像机移动多个平面可以合成为一个</li><li>启用光线估计计算，被转换框架才采用，使得虚拟内容看上去更加真实</li><li>根据配置来开启 AR 的处理进程。将会开启 AR 会话以及来自摄像头的视频流捕捉，最后显示在 sceneView 上</li><li>排错设置，增加可视的光点，覆盖在摄像头视图上</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func resetLabels() &#123;</span><br><span class="line">  messageLabel?.alpha = 1.0</span><br><span class="line">  messageLabel?.text =</span><br><span class="line">    &quot;Move the phone around and allow the app to find a plane.&quot; +</span><br><span class="line">    &quot;You will see a yellow horizontal plane.&quot;</span><br><span class="line">  sessionStateLabel?.alpha = 0.0</span><br><span class="line">  sessionStateLabel?.text = &quot;&quot;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>设置标签的默认值，调整 messageLabel 和 sessionStateLabel 的不透明度和内容，messageLabel 被用力显示指明给用户，然而 sessionStateLabel 被用来显示错误信息，这种情况下属于出错</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">  super.viewDidLoad()    </span><br><span class="line">  resetLabels()</span><br><span class="line">  runSession()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当 app 启动并加载视图的时候开启 ARKit session </li></ul><h2 id="Plane-detection-and-rendering"><a href="#Plane-detection-and-rendering" class="headerlink" title="Plane detection and rendering"></a>Plane detection and rendering</h2><ul><li>扩展  PortalViewController 以至于它能够执行 ARSCNViewDelegate 协议</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extension PortalViewController: ARSCNViewDelegate &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>设置 sceneView 的 delegate 为 PortalViewController</li></ul><blockquote><p>runSession()</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sceneView?.delegate = self</span><br></pre></td></tr></table></figure><ul><li>ARPlaneAnchors 被自动添加给了 ARSession 的锚数组，ARSCNView 自动将 ARPlaneAnchor 对象转换成为 SCNNode nodes，为了去提供这些平面，你需要在 ARSCNViewDelegate 扩展中去执行 delegate 方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">func renderer(_ renderer: SCNSceneRenderer,</span><br><span class="line">              didAdd node: SCNNode,</span><br><span class="line">              for anchor: ARAnchor) &#123;</span><br><span class="line">  // 2</span><br><span class="line">  DispatchQueue.main.async &#123;</span><br><span class="line">    // 3</span><br><span class="line">    if let planeAnchor = anchor as? ARPlaneAnchor &#123;</span><br><span class="line">        // 4</span><br><span class="line">      #if DEBUG</span><br><span class="line">        // 5</span><br><span class="line">        let debugPlaneNode = createPlaneNode(</span><br><span class="line">          center: planeAnchor.center,</span><br><span class="line">          extent: planeAnchor.extent)</span><br><span class="line">        // 6  </span><br><span class="line">        node.addChildNode(debugPlaneNode)</span><br><span class="line">      #endif</span><br><span class="line">      // 7</span><br><span class="line">      self.messageLabel?.text =</span><br><span class="line">      &quot;Tap on the detected horizontal plane to place the portal&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>当ARSession 侦测到了一个新的平面时，renderer(_:didAdd:for:) 被调用，ARSCNView 会自动为这个平面增加一个 ARPlaneAnchor</li><li>这个调用发生在后台线程，但在这里，你将代码块发送到主线程，因为任何更新 UI 的操作都应该在主线程中完成</li><li>检查了 ARAnchor 是否被了一个 ARPlaneAnchor</li><li>检查你是否在排错模式</li><li>如果是这样，通过传入 planeAnchor 的中心和范围大小来创建 plane SCNNode</li><li>node 现在是一个空的 SCNNode，通过 ARSCNView 被自动添加到场景中，它的坐标与 ARAnchor 的位置一样，现在你需要添加 debugPlaneNode 作为一个子结点，以至于它能够放置于跟 node 一样的位置上 </li><li>最后，无论你是不是在排错模式，你都更新指示消息给玩家，表示准备完毕可以将门放入场景中</li></ol><ul><li>创建一个新的Swift file 名为 SCNNodeHelpers.swift，这个文件将会包含所有与生成 SCNNode objects 相关的代码</li></ul><blockquote><p>SCNNodeHelpers.swift</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import SceneKit</span><br><span class="line"></span><br><span class="line">  // 1</span><br><span class="line">func createPlaneNode(center: vector_float3,</span><br><span class="line">                     extent: vector_float3) -&gt; SCNNode &#123;</span><br><span class="line">  // 2</span><br><span class="line">  let plane = SCNPlane(width: CGFloat(extent.x),</span><br><span class="line">                      height: CGFloat(extent.z))</span><br><span class="line">  // 3</span><br><span class="line">  let planeMaterial = SCNMaterial()</span><br><span class="line">  planeMaterial.diffuse.contents = UIColor.yellow.withAlphaComponent(0.4)</span><br><span class="line">  // 4</span><br><span class="line">  plane.materials = [planeMaterial]</span><br><span class="line">  // 5</span><br><span class="line">  let planeNode = SCNNode(geometry: plane)</span><br><span class="line">  // 6</span><br><span class="line">  planeNode.position = SCNVector3Make(center.x, 0, center.z)</span><br><span class="line">  // 7</span><br><span class="line">  planeNode.transform = SCNMatrix4MakeRotation(-Float.pi / 2, 1, 0, 0)</span><br><span class="line">  // 8</span><br><span class="line">  return planeNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>createPlaneNode 方法有两个参数， 将提供的平面的中心和范围大小，都是 vector_float3 类型， 表示点坐标，返回一个 SCNNode object </li><li>通过具体说明平面的宽度和广度实例化了 SCNPlane ，你从 extent 的 x 坐标中得到了宽度，从 z 坐标中得到了高度 </li><li>你初始化了 SCNMaterial 并为它配置了 diffuse content，diffuse layer color 被设置为半透明的黄色</li><li>SCNMaterial 被添加给了平面的 materials 数组，定义了平面的材质和颜色</li><li>使用 plane 的几何大小创建了一个 SCNNode，SCNPlane 继承自 SCNGeometry 类，这个类提供了可视对象的形状，并由 SceneKit 负责生成，. 你通过将几何图形依附在 SCNNode object 进而规定了它的位置和朝向，多个 nodes 可以指向同一个几何大小，允许它出现在一个场景的不同位置</li><li>设置 planeNode 的位置，注意 node 被翻译为了 coordinates (center.x, 0, center.z) ，通过 ARPlaneAnchor instance</li><li>SceneKit 中的平面默认都是垂直的，因此你需要去旋转 90°使之水平</li><li>返回一个 planeNode 对象</li></ol><ul><li>ARKit 基于新发现的特征点持续更新平面的位置和范围大小，新增委托方法去接受这些更新</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">func renderer(_ renderer: SCNSceneRenderer, didUpdate node: SCNNode,</span><br><span class="line">              for anchor: ARAnchor) &#123;</span><br><span class="line">  // 2              </span><br><span class="line">  DispatchQueue.main.async &#123;</span><br><span class="line">    // 3</span><br><span class="line">    if let planeAnchor = anchor as? ARPlaneAnchor,</span><br><span class="line">      node.childNodes.count &gt; 0 &#123;</span><br><span class="line">      // 4  </span><br><span class="line">      updatePlaneNode(node.childNodes[0],</span><br><span class="line">                      center: planeAnchor.center,</span><br><span class="line">                      extent: planeAnchor.extent)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>当对应的锚更新时，renderer(_:didUpdate:for:) 方法被调用</li><li>UI 元素的更新应该在主线程中 </li><li>检查 ARAnchor 是一个 ARPlaneAnchor，然后确认至少它有一个子结点，与 plane’s SCNNode 相符</li><li>updatePlaneNode(_:center:extent:) 是一个不久将执行的方法，它通过 ARPlaneAnchor 中的更新值来更新平面的坐标和大小</li></ol><blockquote><p>SCNNodeHelpers.swift</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func updatePlaneNode(_ node: SCNNode,</span><br><span class="line">                     center: vector_float3,</span><br><span class="line">                     extent: vector_float3) &#123;</span><br><span class="line">  // 1                    </span><br><span class="line">  let geometry = node.geometry as? SCNPlane</span><br><span class="line">  // 2</span><br><span class="line">  geometry?.width = CGFloat(extent.x)</span><br><span class="line">  geometry?.height = CGFloat(extent.z)</span><br><span class="line">  // 3</span><br><span class="line">  node.position = SCNVector3Make(center.x, 0, center.z)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>检查是否 node 含有 SCNPlane geometry</li><li>使用传入的新值更新 node geometry，也就是使用 ARPlaneAnchor 的范围或大小去更新 plane 的宽度和高度</li><li>使用新的位置来更新 plane 的位置</li></ol><ul><li>运行时你将会看到平面的大小和位置随着侦测到新的特征点而改变，仍然有一个问题需要去解决，一旦侦测到平面，如果你离开应用在进来，你将会看到之前侦测到的平面现在在其他对象的顶部，不再匹配它之前侦测的平面，为了解决这个问题，你需要去移除 plane node 当 ARSession 中断时</li></ul><h1 id="Chapter-8-Add-Objects-to-your-World"><a href="#Chapter-8-Add-Objects-to-your-World" class="headerlink" title="Chapter 8: Add Objects to your World"></a>Chapter 8: Add Objects to your World</h1><h2 id="Get-started-1"><a href="#Get-started-1" class="headerlink" title="Get started"></a>Get started</h2><ul><li><p>现在你可能去侦测并生成水平平面，如果有任何中断你则需要去调整会话的状态，当应用切换到后台或者多个应用在前台时，ARSession 会中断，一旦中断，视频捕捉将会失败，ARSession 将不可能做任何追踪，也将不再接受任何传感器数据，当应用返回前台时，生成的平面仍然会在场景中，然而，如果你的设备改变了位置和角度，ARSession 追踪将不再继续，因此你需要去重启会话</p></li><li><p>ARSCNViewDelegate 执行 ARSessionObserver 协议，这个协议包括当 ARSession 侦测中断或者会话出错时调用的方法</p></li></ul><blockquote><p>extension</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">func session(_ session: ARSession, didFailWithError error: Error) &#123;</span><br><span class="line">  // 2</span><br><span class="line">  guard let label = self.sessionStateLabel else &#123; return &#125;</span><br><span class="line">  showMessage(error.localizedDescription, label: label, seconds: 3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3</span><br><span class="line">func sessionWasInterrupted(_ session: ARSession) &#123;</span><br><span class="line">  guard let label = self.sessionStateLabel else &#123; return &#125;</span><br><span class="line">  showMessage(&quot;Session interrupted&quot;, label: label, seconds: 3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 4</span><br><span class="line">func sessionInterruptionEnded(_ session: ARSession) &#123;</span><br><span class="line">  // 5</span><br><span class="line">  guard let label = self.sessionStateLabel else &#123; return &#125;</span><br><span class="line">  showMessage(&quot;Session resumed&quot;, label: label, seconds: 3)</span><br><span class="line"></span><br><span class="line">  // 6</span><br><span class="line">  DispatchQueue.main.async &#123;</span><br><span class="line">    self.removeAllNodes()</span><br><span class="line">    self.resetLabels()</span><br><span class="line">  &#125;</span><br><span class="line">  // 7</span><br><span class="line">  runSession()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>会话失败时，<code>session(_:, didFailWithError:)</code> 方法被调用。会话会终止并且不会收到任何传感器数据</li><li>因为会话失败，设置 sessionStateLabel 文本为错误信息。在规定的时间内， <code>showMessage(_:, label:, seconds:)</code> 在特定的标签上显示信息</li><li>切换到后台视频捕捉中断时，<code>sessionWasInterrupted(_:)</code> 方法被调用，直到中断结束也没有额外的 frame updates 被发送，在标签中显示 “Session interrupted” 三秒</li><li>会话中断已经结束时 <code>sessionInterruptionEnded(_:)</code> 方法被调用，一旦中断结束，会话将会从最后一个已知的状态开始，如果设备移动，任何锚都会错位，为了避免这种情况，你需要重新开启会话</li><li>显示 “Session resumed” 三秒</li><li>移除之前的生成对象并且重置所有标签，不久后你将执行这些方法，因这些方法更新 UI，因此需要在主线程中调用</li><li>重启会话</li></ol><ul><li>debugPlanes 是一组 SCNNode 对象，在排错模式中能够持续追踪所有生成的水平平面</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var debugPlanes: [SCNNode] = []</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">func showMessage(_ message: String, label: UILabel, seconds: Double) &#123;</span><br><span class="line">  label.text = message</span><br><span class="line">  label.alpha = 1</span><br><span class="line"></span><br><span class="line">  DispatchQueue.main.asyncAfter(deadline: .now() + seconds) &#123;</span><br><span class="line">    if label.text == message &#123;</span><br><span class="line">      label.text = &quot;&quot;</span><br><span class="line">      label.alpha = 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2</span><br><span class="line">func removeAllNodes() &#123;</span><br><span class="line">  removeDebugPlanes()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3</span><br><span class="line">func removeDebugPlanes() &#123;</span><br><span class="line">  for debugPlaneNode in self.debugPlanes &#123;</span><br><span class="line">    debugPlaneNode.removeFromParentNode()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  self.debugPlanes = []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在标签中展示信息，一旦规定的时间过去，重新设置标签能见度和文本</li><li><code>removeAllNodes()</code> 移除场景中存在的所有 SCNNode objects，目前你只能移除生成的水平平面</li><li>移除场景中所有生成的水平平面，并重置 debugPlanes 数组</li></ol><blockquote><p>renderer(_:, didAdd:, for:) 中添加到 #if DEBUG 预处理程序末尾</p></blockquote><ul><li>将添加到场景中的水平平面增加到 debugPlanes 数组中去</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.debugPlanes.append(debugPlaneNode)</span><br></pre></td></tr></table></figure><ul><li>替换 <code>sceneView?.session.run(configuration)</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sceneView?.session.run(configuration,</span><br><span class="line">                       options: [.resetTracking, .removeExistingAnchors])</span><br></pre></td></tr></table></figure><p>通过传入配置和一组 ARSession.RunOptions 来开启会话, 有以下几种 options：</p><ol><li>resetTracking：会话不会继续之前配置中的设备位置和运动追踪</li><li>removeExistingAnchors：之前配置中任何与会话相关联的锚都会被移除</li></ol><ul><li>打开应用然后切换到后台，重新打开应用，注意场景中之前生成的水平平面已被移除，应用重置了标签显示正确的指令给用户</li></ul><h2 id="Hit-testing"><a href="#Hit-testing" class="headerlink" title="Hit testing"></a>Hit testing</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var viewCenter: CGPoint &#123;</span><br><span class="line">  let viewBounds = view.bounds</span><br><span class="line">  return CGPoint(x: viewBounds.width / 2.0, y: viewBounds.height / 2.0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123;</span><br><span class="line">  // 2</span><br><span class="line">  if let hit = sceneView?.hitTest(viewCenter, types: [.existingPlaneUsingExtent]).first &#123;</span><br><span class="line">    // 3</span><br><span class="line">    sceneView?.session.add(anchor: ARAnchor.init(transform: hit.worldTransform))      </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>ARSCNView 使得触控有效，当用户点击场景时，touchesBegan() 方法被调用伴随一系列的 UITouch 对象和一个定义 touch 时间的 UIEvent，使此方法优先给 sceneView 增加一个 ARAnchor</li><li><p>你调用了 sceneVIew 的 <code>hitTest(_:, types:)</code>，这个 hitTest 方法有两个参数，首先取了一个 view 坐标系中的 CGPoint，也就是屏幕的中心， 之后是 ARHitTestResult 要去搜索的类型。这里你使用 existingPlaneUsingExtent 类型，只考虑有限范围大小的平面。</p><p><code>hitTest(_:, types:)</code> 的结果是一组所有的 hit test，从最近到最远的，你选择第一个射线相交的第一个 plane，你将从 <code>hitTest(_:, types:)</code>得到结果任何时候，只要屏幕中心落在生成的水平平面上 </p></li><li>在你对象将要被放置的位置增加一个 ARAnchor，ARAnchor 被一个transformation 矩阵所初始化，这个矩阵定义了锚在世界坐标系中的旋转，角度，转化以及大小</li></ol><p>当锚被添加时，在委托方法 <code>renderer(_:didAdd:for:)</code> 中 ARSCNView 接受了一个回调，这就是你生成出入口的地方</p><h2 id="Add-crosshairs"><a href="#Add-crosshairs" class="headerlink" title="Add crosshairs"></a>Add crosshairs</h2><ul><li>在你增加出入口到场景中之前，还有一件事情，之前你使用屏幕中心来侦测 hit testing，现在你将增加一个 view 去显示屏幕中心来帮助用户定位</li></ul><blockquote><p>extension</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">func renderer(_ renderer: SCNSceneRenderer,</span><br><span class="line">              updateAtTime time: TimeInterval) &#123;</span><br><span class="line">  // 2</span><br><span class="line">  DispatchQueue.main.async &#123;</span><br><span class="line">    // 3</span><br><span class="line">    if let _ = self.sceneView?.hitTest(self.viewCenter,</span><br><span class="line">      types: [.existingPlaneUsingExtent]).first &#123;</span><br><span class="line">      self.crosshair.backgroundColor = UIColor.green</span><br><span class="line">    &#125; else &#123; // 4</span><br><span class="line">      self.crosshair.backgroundColor = UIColor.lightGray</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>这个方法是 SCNSceneRendererDelegate 协议的一部分，这个协议被 ARSCNViewDelegate 执行，它包含很多回调能够被很多次使用去执行操作在生成的过程中，<code>renderer(_: updateAtTime:)</code> 每一帧都被被精准地调用，并且应该被用于执行每一帧的逻辑</li><li>如果屏幕中心落在侦测的水平平面上，在主线程中同步更新 UI</li><li>如果 view center 确实与水平平面相交，就在 sceneView 上执行一次 hit test，如果至少有一个一个结果被侦测到，crosshair view 的背景颜色变为绿色background</li><li>hit test 没有返回任何结果，crosshair view 的背景色被设为浅灰色</li></ol><h2 id="Add-a-state-machine"><a href="#Add-a-state-machine" class="headerlink" title="Add a state machine"></a>Add a state machine</h2><ul><li>既然你已经设置侦测平面并且防止了锚，现在你可以开始增加出入口</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var portalNode: SCNNode? = nil</span><br><span class="line">var isPortalPlaced = false</span><br></pre></td></tr></table></figure><ul><li>makePortal() 正在创建一个出入口结点，其中还有一个方块对象作为占位符</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func makePortal() -&gt; SCNNode &#123;</span><br><span class="line">  // 1</span><br><span class="line">  let portal = SCNNode()</span><br><span class="line">  // 2</span><br><span class="line">  let box = SCNBox(width: 1.0,</span><br><span class="line">                   height: 1.0,</span><br><span class="line">                   length: 1.0,</span><br><span class="line">                   chamferRadius: 0)</span><br><span class="line">  let boxNode = SCNNode(geometry: box)</span><br><span class="line">  // 3</span><br><span class="line">  portal.addChildNode(boxNode)  </span><br><span class="line">  return portal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>创建一个 SCNNode 对象，它代表你的出入口 </li><li>初始化一个 SCNBox 对象，它其实一个方块，使用 SCNBox geometry 来生成</li><li>将 boxNode 作为一个子结点添加到你的出入口，然后返回 portal 结点</li></ol><ul><li>为了 SCNSceneRendererDelegate，替换 <code>renderer(_:, didAdd:, for:)</code> 和 <code>renderer(_:, didUpdate:, for:)</code> 方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">func renderer(_ renderer: SCNSceneRenderer, didAdd node: SCNNode, for anchor: ARAnchor) &#123;</span><br><span class="line">  DispatchQueue.main.async &#123;</span><br><span class="line">    // 1</span><br><span class="line">    if let planeAnchor = anchor as? ARPlaneAnchor, </span><br><span class="line">    !self.isPortalPlaced &#123;</span><br><span class="line">      #if DEBUG</span><br><span class="line">        let debugPlaneNode = createPlaneNode(</span><br><span class="line">          center: planeAnchor.center,</span><br><span class="line">          extent: planeAnchor.extent)</span><br><span class="line">        node.addChildNode(debugPlaneNode)</span><br><span class="line">        self.debugPlanes.append(debugPlaneNode)</span><br><span class="line">      #endif</span><br><span class="line">      self.messageLabel?.alpha = 1.0</span><br><span class="line">      self.messageLabel?.text = &quot;&quot;&quot;</span><br><span class="line">            Tap on the detected \</span><br><span class="line">            horizontal plane to place the portal</span><br><span class="line">            &quot;&quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    else if !self.isPortalPlaced &#123;// 2</span><br><span class="line">        // 3</span><br><span class="line">      self.portalNode = self.makePortal()</span><br><span class="line">      if let portal = self.portalNode &#123;</span><br><span class="line">        // 4</span><br><span class="line">        node.addChildNode(portal)</span><br><span class="line">        self.isPortalPlaced = true</span><br><span class="line">        // 5</span><br><span class="line">        self.removeDebugPlanes()</span><br><span class="line">        self.sceneView?.debugOptions = []</span><br><span class="line">        // 6</span><br><span class="line">        DispatchQueue.main.async &#123;</span><br><span class="line">          self.messageLabel?.text = &quot;&quot;</span><br><span class="line">          self.messageLabel?.alpha = 0</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func renderer(_ renderer: SCNSceneRenderer,</span><br><span class="line">              didUpdate node: SCNNode,</span><br><span class="line">              for anchor: ARAnchor) &#123;</span><br><span class="line">  DispatchQueue.main.async &#123;</span><br><span class="line">    // 7</span><br><span class="line">    if let planeAnchor = anchor as? ARPlaneAnchor,</span><br><span class="line">      node.childNodes.count &gt; 0,</span><br><span class="line">      !self.isPortalPlaced &#123;</span><br><span class="line">      updatePlaneNode(node.childNodes[0],</span><br><span class="line">                      center: planeAnchor.center,</span><br><span class="line">                      extent: planeAnchor.extent)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>只有当添加到场景中的锚是一个 ARPlaneAnchor 时，并且 isPortalPlaced 为假，意味着出入口还未被放置，给场景添加一个水平平面去展示侦测到的平面</li><li>如果被添加的锚不是一个 ARPlaneAnchor，并且出入口结点仍然没有被放置，那么这个锚一定是当用户点击屏幕时放置出入口所添加的锚</li><li>通过调用 makePortal() 来创建 出入口结点</li><li><code>renderer(_:, didAdd:, for:)</code> is called with the SCNNode object, node, that is added to the scene. 你想要将出入口结点放置到这个结点的位置上。所以你将出入口结点作为该结点的子结点，然后设置 isPortalPlaced 为真，去追踪出入口结点已经被添加</li><li>为了去清理场景，你移除了所有生成的水平平面，然后重置了 debugOptions 以至于特征点不再显示</li><li>主线程中更新 messageLabel 重置它的文本并且隐藏它</li><li><code>renderer(_:, didUpdate:, for:)</code>只有当所提供的锚是一个 ARPlaneAnchor 并且结点至少有一个子结点以及出入口还未被放置，你更新生成的水平平面</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func removeAllNodes() &#123;</span><br><span class="line">  // 1</span><br><span class="line">  removeDebugPlanes()</span><br><span class="line">  // 2</span><br><span class="line">  self.portalNode?.removeFromParentNode()</span><br><span class="line">  // 3</span><br><span class="line">  self.isPortalPlaced = false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>你移除了所有生成的水平平面</li><li>从 portalNode 的父结点中移除 portalNode</li><li>设置 isPortalPlaced 变量为假</li></ol><ul><li>运行应用，让应用侦测一个水平平面，当 crosshair view 变为绿色时，点击屏幕，你将会看到一个一个巨大的白色立方体</li></ul><h1 id="Chapter-9-Geomtry-Textrues-and-lighting"><a href="#Chapter-9-Geomtry-Textrues-and-lighting" class="headerlink" title="Chapter 9: Geomtry, Textrues, and lighting"></a>Chapter 9: Geomtry, Textrues, and lighting</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Chapter-7-Get-Started-Portal-App&quot;&gt;&lt;a href=&quot;#Chapter-7-Get-Started-Portal-App&quot; class=&quot;headerlink&quot; title=&quot;Chapter 7: Get Started: Port
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ARKit by Tutorials Section Ⅰ 野生笔记</title>
    <link href="http://yoursite.com/2018/09/18/arkitSection1/"/>
    <id>http://yoursite.com/2018/09/18/arkitSection1/</id>
    <published>2018-09-17T16:00:00.000Z</published>
    <updated>2018-09-25T00:20:27.714Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter-3-Basic-Session-Management"><a href="#Chapter-3-Basic-Session-Management" class="headerlink" title="Chapter 3: Basic Session Management"></a>Chapter 3: Basic Session Management</h1><h2 id="Mark-out-sections"><a href="#Mark-out-sections" class="headerlink" title="Mark out sections"></a>Mark out sections</h2><p><img src="https://i.loli.net/2018/09/22/5ba5ae2c6c97c.png" alt=""></p><h4 id="View-Management"><a href="#View-Management" class="headerlink" title="View Management"></a>View Management</h4><ul><li>这里面都是与 View 有关联的，不会修改过多，除了 <code>viewDidLoad()</code>，一直在添加各种初始化函数</li></ul><h4 id="Initialization"><a href="#Initialization" class="headerlink" title="Initialization"></a>Initialization</h4><ul><li><p>这里有之前提到的各种初始化函数</p><ul><li><code>initSceneView()</code> 负责设置 sceneView 的 delegate</li><li><code>initScene()</code>负责加载你的场景</li><li><code>initARSession()</code>现在还只是个空壳</li></ul></li></ul><h4 id="The-ARSCNViewDelegate-protocol-extension"><a href="#The-ARSCNViewDelegate-protocol-extension" class="headerlink" title="The ARSCNViewDelegate protocol extension"></a>The ARSCNViewDelegate protocol extension</h4><ul><li>这个协议被移动到自己的扩展中，清晰地隔离开来，并且使得功能相近的协议在一起，最后提高整个代码可读性</li></ul><h2 id="Create-the-configuration"><a href="#Create-the-configuration" class="headerlink" title="Create the configuration"></a>Create the configuration</h2><ul><li><p>ARSCNView view 本质上就是 SceneKit view，它包括一个 ARSession ，负责 ARKit 的运动追踪和图像处理，这是基于 session 的，意味着你必须创建一个 ARSession 实例，通过 “run” 来开启 AR 的追踪过程</p></li><li><p>在开启 ARSession 之前，你必须去创建一个 ARSession 配置，这个配置被用于建立现实世界和虚拟世界的联系，也就是你的设备位置和虚拟内容的位置关系</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func initARSession() &#123;</span><br><span class="line">    guard ARWorldTrackingConfiguration.isSupported else &#123;</span><br><span class="line">      print(&quot;*** ARConfig: AR World Tracking Not Supported&quot;)</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    // 1</span><br><span class="line">    let config = ARWorldTrackingConfiguration()</span><br><span class="line">    // 2</span><br><span class="line">    config.worldAlignment = .gravity</span><br><span class="line">    // 3</span><br><span class="line">    config.providesAudioData = false</span><br><span class="line">    // 4</span><br><span class="line">    sceneView.session.run(config)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol><li>创建一个 ARWorldTrackingConfiguration 实例，分配给了 config </li><li>设置 worldAlignment 的属性，也就是具体说明虚拟的内容将如何与现实世界相关联</li><li>不允许 ARSession 捕捉声音，还有一个属性 isLightEstimationEnabled 之后会学到</li><li>运行 ARSession ，并使用你刚刚设置好的配置，现在实时追踪 6DOF 维度的数据</li></ol><h2 id="Controll-an-ARSession"><a href="#Controll-an-ARSession" class="headerlink" title="Controll an ARSession"></a>Controll an ARSession</h2><ol><li>Pause:<br><code>ARSession.pause()</code></li><li>Resume:<br><code>ARSession.run()</code></li><li>Update:<br><code>ARSession.run(ARSessionConfig)</code></li><li>Reset:<br><code>ARSession.run(_:options:)</code></li></ol><h2 id="Update-the-status-message"><a href="#Update-the-status-message" class="headerlink" title="Update the status message"></a>Update the status message</h2><blockquote><p>Properties</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var trackingStatus: String = &quot;&quot;</span><br></pre></td></tr></table></figure><blockquote><p>SceneKit Management</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func renderer(_ renderer: SCNSceneRenderer, </span><br><span class="line">   updateAtTime time: TimeInterval) &#123;</span><br><span class="line">   DispatchQueue.main.async &#123;</span><br><span class="line">     self.statusLabel.text = self.trackingStatus</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意：当更新 UI 中的元素时，例如 status bar label，你必须在主线程  DispatchQueue.main.async { … } 中进行更新</li></ul><h2 id="Handle-AR-session-errors"><a href="#Handle-AR-session-errors" class="headerlink" title="Handle AR session errors"></a>Handle AR session errors</h2><blockquote><p>Session Error Management</p></blockquote><ol><li>Session 失败</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func session(_ session: ARSession, didFailWithError error: Error) &#123;</span><br><span class="line">  trackingStatus = &quot;AR Session Failure: \(error)&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>Session 中断</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func sessionWasInterrupted(_ session: ARSession) &#123;</span><br><span class="line">  trackingStatus = &quot;AR Session Was Interrupted!&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>Session 中断结束</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func sessionInterruptionEnded(_ session: ARSession) &#123;</span><br><span class="line">  trackingStatus = &quot;AR Session Interruption Ended&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Handle-AR-session-state-changes"><a href="#Handle-AR-session-state-changes" class="headerlink" title="Handle AR session state changes"></a>Handle AR session state changes</h2><blockquote><p>Session State Management</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">func session(_ session: ARSession,</span><br><span class="line">               cameraDidChangeTrackingState camera: ARCamera) &#123;</span><br><span class="line">    switch camera.trackingState &#123;</span><br><span class="line">    // 1</span><br><span class="line">    case .notAvailable:</span><br><span class="line">      trackingStatus = &quot;Tacking:  Not available!&quot;</span><br><span class="line">      break</span><br><span class="line">    // 2</span><br><span class="line">    case .normal:</span><br><span class="line">      trackingStatus = &quot;Tracking: All good!&quot;</span><br><span class="line">      break</span><br><span class="line">    // 3</span><br><span class="line">    case .limited(let reason):</span><br><span class="line">      switch reason &#123;</span><br><span class="line">      case .excessiveMotion:</span><br><span class="line">        trackingStatus = &quot;Tracking: Limited due to excessive motion!&quot;</span><br><span class="line">      // 3.1</span><br><span class="line">      case .insufficientFeatures:</span><br><span class="line">        trackingStatus = &quot;Tracking: Limited due to insufficient features!&quot;</span><br><span class="line">      // 3.2</span><br><span class="line">      case .initializing:</span><br><span class="line">        trackingStatus = &quot;Tracking: Initializing...&quot;</span><br><span class="line">      // 3.3</span><br><span class="line">      case .relocalizing:</span><br><span class="line">        trackingStatus = &quot;Tracking: Relocalizing...&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>当 ARSession 正在运行时，session 受到外部的条件影响会改变追踪状态，每一次状态改变，该方法就会被触发，我们需要监视所有的 ARCamera.trackingStatus 的状态改变。</p><ol><li>notAvailable</li><li>normal</li></ol><h2 id="Show-debug-options"><a href="#Show-debug-options" class="headerlink" title="Show debug options"></a>Show debug options</h2><blockquote><p>initSceneView()</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sceneView.debugOptions = [</span><br><span class="line">      ARSCNDebugOptions.showFeaturePoints,</span><br><span class="line">      ARSCNDebugOptions.showWorldOrigin,</span><br><span class="line">      SCNDebugOptions.showBoundingBoxes,</span><br><span class="line">      SCNDebugOptions.showWireframe</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><h1 id="Chapter-4-Add-3D-Objects-and-Textures"><a href="#Chapter-4-Add-3D-Objects-and-Textures" class="headerlink" title="Chapter 4: Add 3D Objects and Textures"></a>Chapter 4: Add 3D Objects and Textures</h1><h2 id="Create-the-dice-scene"><a href="#Create-the-dice-scene" class="headerlink" title="Create the dice scene"></a>Create the dice scene</h2><ul><li><p>COLLADA 是一种 3D 物体流行的文件格式，Xcode 完全兼容这种格式，你只需要插入这种格式的文件，使用 Xcode 将它们转换为本地的 SceneKit 模型</p><blockquote><p>步骤：</p><ol><li>COLLDA 格式 –&gt; 转换为 SceneKit scene file format (.scn)</li><li>新建 DiceScene.scn ，在里面复制粘贴出五个 dice  </li></ol></blockquote></li></ul><h2 id="Physically-based-rendering-PBR"><a href="#Physically-based-rendering-PBR" class="headerlink" title="Physically based rendering (PBR)"></a>Physically based rendering (PBR)</h2><ul><li>Environment map：环境贴图有两个目的，第一是与反射贴图类似，在高反射的表面上可以看到映射。第二是为基于物理渲染的物体提供光照信息，给予它们一个真实的光照环境</li></ul><h2 id="Load-3D-objects"><a href="#Load-3D-objects" class="headerlink" title="Load 3D objects"></a>Load 3D objects</h2><ul><li>创建一个新的场景 ，使得骰子进入增强现实场景</li></ul><blockquote><p>initScene()</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let scene = SCNScene()</span><br></pre></td></tr></table></figure><ul><li>为 AR scene 准备一个 environment map 。现在 scene 已经为基于 PBR 的 3D 物体准备好了一个合适的 lighting environment map </li></ul><blockquote><p>initScene()</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scene.lightingEnvironment.contents = </span><br><span class="line">   &quot;PokerDice.scnassets/Textures/Environment_CUBE.jpg&quot;</span><br><span class="line">scene.lightingEnvironment.intensity = 2</span><br></pre></td></tr></table></figure><ul><li>创建一个数组，因为你刚刚创建了五个风格不一的 dice node</li></ul><blockquote><p>Properties</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var diceNodes: [SCNNode] = []</span><br></pre></td></tr></table></figure><ul><li>现在需要把这些 dice nodes 加载进入数组</li></ul><blockquote><p>Load Models</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func loadModels() &#123;</span><br><span class="line">  // 1      </span><br><span class="line">  let diceScene = SCNScene(</span><br><span class="line">    named: &quot;PokerDice.scnassets/Models/DiceScene.scn&quot;)!</span><br><span class="line">  // 2</span><br><span class="line">  for count in 0..&lt;5 &#123;</span><br><span class="line">    // 3</span><br><span class="line">    diceNodes.append(diceScene.rootNode.childNode(</span><br><span class="line">      withName: &quot;dice\(count)&quot;, </span><br><span class="line">      recursively: false)!)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol><li>加载 DiceScene.scn 并存储进 diceScene</li><li>循环五次</li><li>childNode() 搜索 diceScene.rootNode scene， 寻找所有的骰子，一旦发现，添加 dice node 到 diceNodes 数组</li></ol><ul><li>在一开始就调用方法</li></ul><blockquote><p>viewDidLoad()</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.loadModels()</span><br></pre></td></tr></table></figure><h2 id="Place-3D-objects"><a href="#Place-3D-objects" class="headerlink" title="Place 3D objects"></a>Place 3D objects</h2><ul><li>dice nodes 已被加载，准备放入增强现实场景中 </li></ul><blockquote><p>Properties</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var diceCount: Int = 5</span><br><span class="line">var diceStyle: Int = 0</span><br><span class="line">var diceOffset: [SCNVector3] = [SCNVector3(0.0,0.0,0.0),</span><br><span class="line">                           SCNVector3(-0.05, 0.00, 0.0),</span><br><span class="line">                           SCNVector3(0.05, 0.00, 0.0),</span><br><span class="line">                           SCNVector3(-0.05, 0.05, 0.02),</span><br><span class="line">                           SCNVector3(0.05, 0.05, 0.02)]</span><br></pre></td></tr></table></figure><ul><li>diceCount：计数手中还有多少骰子</li><li>diceStyle：代表不同风格的骰子</li><li>diceOffset：一组位置偏移</li></ul><blockquote><p>Helper Functions</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func throwDiceNode(transform: SCNMatrix4, offset: SCNVector3) &#123;</span><br><span class="line">    // 1</span><br><span class="line">    let position = SCNVector3(transform.m41 + offset.x,</span><br><span class="line">                              transform.m42 + offset.y,</span><br><span class="line">                              transform.m43 + offset.z)</span><br><span class="line">    // 2</span><br><span class="line">    let diceNode = diceNodes[diceStyle].clone()</span><br><span class="line">    diceNode.name = &quot;dice&quot;</span><br><span class="line">    diceNode.position = position</span><br><span class="line">    //3</span><br><span class="line">    sceneView.scene.rootNode.addChildNode(diceNode)</span><br><span class="line">    //diceCount -= 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>将转换后的数据和传入函数的数据联合创建了一个位置偏移量</li><li>克隆了一个被选中的 dice node，重新命名为 “dice” ，并且设置它的位置</li><li>克隆的 dice node 被放置于增强现实场景中，diceCount 自减表示手中少了一个骰子</li></ol><h2 id="Add-a-swipe-gesture"><a href="#Add-a-swipe-gesture" class="headerlink" title="Add a swipe gesture"></a>Add a swipe gesture</h2><blockquote><p>Actions</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@IBAction func swipeUpGestureHandler(_ sender: Any) &#123;</span><br><span class="line">    // 1</span><br><span class="line">    guard let frame = self.sceneView.session.currentFrame else &#123; return &#125;</span><br><span class="line">    // 2</span><br><span class="line">    for count in 0..&lt;diceCount &#123;</span><br><span class="line">      throwDiceNode(transform: SCNMatrix4(frame.camera.transform),</span><br><span class="line">                    offset: diceOffset[count])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol><li>currentFrame 是一个 ARFrame 对象，连接着增强现实场景，它包含最近捕捉的视频帧图像的，同时还有捕捉的深度数据，AR 相机，当前的环境估计光，锚，特征点，这行代码确保这有一个可用的画面</li><li>遍历了五个骰子，使用 AR 相机的转换矩阵，它包含关于相机位置和旋转的信息，一次抛出一个骰子进入 AR scene ，最后将会抛出你手中所有的骰子 </li></ol><h2 id="Change-dice-styles"><a href="#Change-dice-styles" class="headerlink" title="Change dice styles"></a>Change dice styles</h2><blockquote><p>Actions</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@IBAction func styleButtonPressed(_ sender: Any) &#123;</span><br><span class="line">    diceStyle = diceStyle &gt;= 4 ? 0 : diceStyle + 1</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="Chapter-5-Detect-Surface"><a href="#Chapter-5-Detect-Surface" class="headerlink" title="Chapter 5: Detect Surface"></a>Chapter 5: Detect Surface</h1><h2 id="Define-game-states"><a href="#Define-game-states" class="headerlink" title="Define game states"></a>Define game states</h2><blockquote><p>Game State</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum GameState: Int16 &#123;</span><br><span class="line">  case detectSurface  </span><br><span class="line">  case pointToSurface   </span><br><span class="line">  case swipeToPlay</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>detectSurface：ARKit 需要花费一点时间去理解它的环境，然后开始检测平面。只要游戏处于这个状态中，玩家就必须去扫描他们的环境以寻找合适的水平平面,一旦玩家对于 ARKit 所侦测到的平面满意，就可以进入下一阶段。</li><li>pointToSurface：玩家现在将设备指向侦测到的平面，出现一个准心光标，准心光标表示目标点，也就是骰子将会掷向的地方</li><li>swipeToPlay：一旦目标点出现，玩家向准心光标掷出骰子</li></ul><h2 id="Add-game-state-messages"><a href="#Add-game-state-messages" class="headerlink" title="Add game state messages"></a>Add game state messages</h2><blockquote><p>Properties</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var gameState: GameState = .detectSurface</span><br><span class="line">var statusMessage: String = &quot;&quot;</span><br></pre></td></tr></table></figure><blockquote><p>Helper Functions</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func updateStatus() &#123;</span><br><span class="line">  // 1</span><br><span class="line">  switch gameState &#123;</span><br><span class="line">    case .detectSurface:</span><br><span class="line">      statusMessage = &quot;Scan entire table surface...\nHit START when ready!&quot;</span><br><span class="line">    case .pointToSurface:</span><br><span class="line">      statusMessage = &quot;Point at designated surface first!&quot;</span><br><span class="line">    case .swipeToPlay:</span><br><span class="line">      statusMessage = &quot;Swipe UP to throw!\nTap on dice to collect it again.&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  // 2    </span><br><span class="line">  self.statusLabel.text = trackingStatus != &quot;&quot; ? </span><br><span class="line">    &quot;\(trackingStatus)&quot; : &quot;\(statusMessage)&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>SceneKit Management</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func renderer(_ renderer: SCNSceneRenderer, updateAtTime time: TimeInterval) &#123;</span><br><span class="line">    DispatchQueue.main.async &#123;</span><br><span class="line">      //self.statusLabel.text = self.trackingStatus</span><br><span class="line">      self.updateStatus()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="Anchors"><a href="#Anchors" class="headerlink" title="Anchors"></a>Anchors</h2><ul><li>ARKit 使用一个虚拟的锚去固定你的 3D 物体，当玩家在现实世界移动设备时，可以保持 3D 物体的位置</li><li><strong>ARAnchor 包含一个真实世界中的位置和朝向，并且不可见，它只是一个 ARKit 场景中的一个对象。ARKit 会默认给每一个 ARAnchor 配对一个空的 SCNNode，你要做的就是添加你的 3D 物体作为这个 node 的子对象</strong></li><li>ARPlaneAnchor 是一种特殊类型的锚，包含了一个真实世界的位置和朝向，并且还附加了平面信息，包括中心点，朝向，以及范围大小，你能够使用这些信息去创造一个 SceneKit plane node</li></ul><h2 id="Detect-surfaces"><a href="#Detect-surfaces" class="headerlink" title="Detect surfaces"></a>Detect surfaces</h2><blockquote><p>Initialization</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func initARSession() &#123;</span><br><span class="line">    guard ARWorldTrackingConfiguration.isSupported else &#123;</span><br><span class="line">      print(&quot;*** ARConfig: AR World Tracking Not Supported&quot;)</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    let config = ARWorldTrackingConfiguration()</span><br><span class="line">    config.worldAlignment = .gravity</span><br><span class="line">    config.providesAudioData = false</span><br><span class="line">    config.planeDetection = .horizontal</span><br><span class="line">    sceneView.session.run(config)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>ARKit 将会开始侦测水平平面，并且为每一个侦测到的平面自动生成 ARPlaneAnchor</li><li>通过使用 <code>.vertical</code> 代替，你还可以侦测垂直的平面</li></ul><h2 id="Create-new-planes"><a href="#Create-new-planes" class="headerlink" title="Create new planes"></a>Create new planes</h2><ul><li>当一个新的 plane anchor 被添加时，此函数可以创建一个对应的可视对象，这个函数接受 ARPlaneAnchor 以及 UIColor 作为参数，现在我们可以生成一个 SceneKit Plane node</li></ul><blockquote><p>Helper Functions</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func createARPlaneNode(planeAnchor: ARPlaneAnchor, color: UIColor) -&gt; SCNNode &#123;</span><br><span class="line">    </span><br><span class="line">    // 1 </span><br><span class="line">    let planeGeometry = SCNPlane(width: CGFloat(planeAnchor.extent.x),</span><br><span class="line">                                 height: CGFloat(planeAnchor.extent.z))</span><br><span class="line">    </span><br><span class="line">    // 2</span><br><span class="line">    let planeMaterial = SCNMaterial()</span><br><span class="line">    planeMaterial.diffuse.contents = &quot;PokerDice.scnassets/Textures/Surface_DIFFUSE.png&quot; //color</span><br><span class="line">    planeGeometry.materials = [planeMaterial]</span><br><span class="line">    </span><br><span class="line">    // 3</span><br><span class="line">    let planeNode = SCNNode(geometry: planeGeometry)</span><br><span class="line">    planeNode.position = SCNVector3Make(planeAnchor.center.x, 0, planeAnchor.center.z)</span><br><span class="line">    planeNode.transform = SCNMatrix4MakeRotation(-Float.pi / 2, 1, 0, 0)</span><br><span class="line">    </span><br><span class="line">    return planeNode</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol><li>使用锚的范围大小来生成 plane 的几何形状</li><li>创建一个新的材质，然后设置它的 diffuse.contents 属性</li><li>创建 plane node</li></ol><blockquote><p>第三步详解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 1 </span><br><span class="line">let planeNode = SCNNode(geometry: planeGeometry)</span><br><span class="line">// 2</span><br><span class="line">planeNode.position = SCNVector3Make(</span><br><span class="line">  planeAnchor.center.x, 0, planeAnchor.center.z)</span><br><span class="line">// 3</span><br><span class="line">planeNode.transform = SCNMatrix4MakeRotation(-Float.pi / 2, 1, 0, 0)</span><br><span class="line">// 4        </span><br><span class="line">return planeNode</span><br></pre></td></tr></table></figure></blockquote><ol><li>通过传入之前生成的 plane geometry，创建了一个新的 plane node</li><li>基于锚的中心点设置了 plane node 的位置</li><li>通过 SCNPlane 生成的几何形状默认是垂直的，所以你需要绕 X 轴顺时针旋转 90 度，使得 plane 平躺，当你直接创建垂直平面的时候，你可以直接忽略这一步</li><li>返回给调用者</li></ol><h2 id="Handle-new-plane-anchors"><a href="#Handle-new-plane-anchors" class="headerlink" title="Handle new plane anchors"></a>Handle new plane anchors</h2><ul><li>随着平面侦测的激活，ARKit 会自动为每一个它侦测到的水平平面创建 ARPlaneAnchors，当添加新的锚时，renderer(_:didAdd:for) 方法被调用。你需要去做的就是等待这个事件被触发，然后为锚创建一个对应的 SceneKit plane</li></ul><blockquote><p>Plane Management</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">func renderer(_ renderer: SCNSceneRenderer, didAdd node: SCNNode, for anchor: ARAnchor) &#123;</span><br><span class="line"> // 2</span><br><span class="line">    guard let planeAnchor = anchor as? ARPlaneAnchor else &#123; return &#125;</span><br><span class="line">    // 3</span><br><span class="line">    DispatchQueue.main.async &#123;</span><br><span class="line">      // 4</span><br><span class="line">      let planeNode = self.createARPlaneNode(planeAnchor: planeAnchor,</span><br><span class="line">                                             color: UIColor.yellow.withAlphaComponent(0.5))</span><br><span class="line">      // 5                                                        </span><br><span class="line">      node.addChildNode(planeNode)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol><li>注意这个委托方法接受了一个 SCNNode，这是一个新的 SceneKit node，会与接受到的 ARAnchor node 进行配对</li><li>你只关注 ARPlaneAnchors，因此将会筛选出这一类的锚</li><li>你只能在主线程里面创建可视对象</li><li>调用你刚刚创建的 createARPlaneNode()，传入锚的信息和颜色 </li><li>plane node 被添加作为 ARKit 所创建的 node 的子对象</li></ol><h2 id="Update-planes"><a href="#Update-planes" class="headerlink" title="Update planes"></a>Update planes</h2><ul><li>ARKit 一开始可能没有侦测到整个平面，随着玩家移动你需要去更新之前侦测到的平面</li><li>你需要使用全新的位置，朝向，尺寸大小去更新一个已经存在的 plane node</li></ul><blockquote><p>Helper Functions</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func updateARPlaneNode(planeNode: SCNNode, planeAchor: ARPlaneAnchor) &#123;</span><br><span class="line">  let planeGeometry = planeNode.geometry as! SCNPlane</span><br><span class="line">  // 1</span><br><span class="line">  planeGeometry.width = CGFloat(planeAchor.extent.x)</span><br><span class="line">  planeGeometry.height = CGFloat(planeAchor.extent.z)</span><br><span class="line">  // 2</span><br><span class="line">  planeNode.position = SCNVector3Make(planeAchor.center.x, 0, planeAchor.center.z)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>从 plane node 那取回了之前生成的 planeGeometry，然后基于之前的 planeAnchor 更新了它的宽度和高度信息</li><li>基于之前 planeAnchor 的位置信息更新 planeNode 的位置</li></ol><ul><li>如果之前侦测的平面有新的信息更新，ARKit 将会触发 renderer(_:didUpdate:for) 方法，</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">func renderer(_ renderer: SCNSceneRenderer, didUpdate node: SCNNode, for anchor: ARAnchor) &#123;</span><br><span class="line">  // 2</span><br><span class="line">  guard let planeAnchor = anchor as? ARPlaneAnchor else &#123; return &#125;</span><br><span class="line">    // 3</span><br><span class="line">    DispatchQueue.main.async &#123;</span><br><span class="line">      // 4</span><br><span class="line">      self.updateARPlaneNode(planeNode: node.childNodes[0],</span><br><span class="line">        planeAchor: planeAnchor)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>注意这个代理方法接受了一个 SCNNode，这是一个一直存在的 node，之前添你将 planeNode 添加到此 node 中</li><li>再一次，你只感兴趣 ARPlaneAnchors，所以将会筛选出此类的锚</li><li>你只能在主线程里更新可视对象</li><li>最后调用 updatePlane()，你正在传入第一个子 node，以及一个相关联的 plane anchor</li></ol><h2 id="Create-a-focus-node"><a href="#Create-a-focus-node" class="headerlink" title="Create a focus node"></a>Create a focus node</h2><ul><li>现在你的 AR 游戏正在侦测平面，当用户掷出骰子时你应该提供用户某样东西可以去参照，如何将 focus node 置于平面之上，也就是用户所指之处，答案就是 ray casting</li></ul><h4 id="load-focus-node"><a href="#load-focus-node" class="headerlink" title="load focus node"></a>load focus node</h4><blockquote><p>Properties</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var focusNode: SCNNode!</span><br></pre></td></tr></table></figure><blockquote><p>loadModels()</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let focusScene = SCNScene(</span><br><span class="line">  named: &quot;PokerDice.scnassets/Models/FocusScene.scn&quot;)!</span><br><span class="line">focusNode = focusScene.rootNode.childNode(</span><br><span class="line">  withName: &quot;focus&quot;, recursively: false)!</span><br><span class="line">sceneView.scene.rootNode.addChildNode(focusNode)</span><br></pre></td></tr></table></figure><ul><li>加载了新场景，然后保存到 focusNode 中去</li></ul><h4 id="Ray-casting"><a href="#Ray-casting" class="headerlink" title="Ray casting"></a>Ray casting</h4><ul><li>Ray casting 是当玩家搜寻 3D 物体时，从屏幕中心投射虚拟射线进入场景中。在这种特殊情况中，场景中的射线与 plane nodes 产生相交点，一旦相交，相交位置就被用来放置 focus node</li></ul><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fvgx0ii2eqj31kw115kjm.jpg" alt=""></p><h4 id="Create-the-focus-point"><a href="#Create-the-focus-point" class="headerlink" title="Create the focus point"></a>Create the focus point</h4><blockquote><p>Properties</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var focusPoint:CGPoint!</span><br></pre></td></tr></table></figure><blockquote><p>initSceneView()</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">focusPoint = CGPoint(x: view.center.x, y: view.center.y + view.center.y * 0.25)</span><br></pre></td></tr></table></figure><h4 id="Handle-orientation-changes"><a href="#Handle-orientation-changes" class="headerlink" title="Handle orientation changes"></a>Handle orientation changes</h4><blockquote><p>View Management</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@objc func orientationChanged() &#123;</span><br><span class="line">  focusPoint = CGPoint(x: view.center.x, y: view.center.y + view.center.y * 0.25)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>initSceneView()</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NotificationCenter.default.addObserver(self, </span><br><span class="line">  selector: #selector(ViewController.orientationChanged),</span><br><span class="line">  name: NSNotification.Name.UIDeviceOrientationDidChange,</span><br><span class="line">  object: nil)</span><br></pre></td></tr></table></figure><ul><li>当用户改变设备朝向的时候，NSNotification.Name.UIDeviceOrientationDidChange 被触发</li><li>现在每一次设备的朝向改变你都会得到通知，同时你也保持 focusPoint 一直更新</li></ul><h4 id="Update-the-focus-node"><a href="#Update-the-focus-node" class="headerlink" title="Update the focus node"></a>Update the focus node</h4><ul><li>基于屏幕的 focus point 持续地更新 focus node</li></ul><blockquote><p>Helper Functions</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func updateFocusNode() &#123;</span><br><span class="line">  // 1</span><br><span class="line">  let results = self.sceneView.hitTest(self.focusPoint, </span><br><span class="line">    types: [.existingPlaneUsingExtent])</span><br><span class="line">  // 2 </span><br><span class="line">  if results.count == 1 &#123;</span><br><span class="line">    if let match = results.first &#123;</span><br><span class="line">      // 3</span><br><span class="line">      let t = match.worldTransform</span><br><span class="line">     // 4</span><br><span class="line">      self.focusNode.position = SCNVector3( x: t.columns.3.x, y: t.columns.3.y,</span><br><span class="line">        z: t.columns.3.z)</span><br><span class="line">      self.gameState = .swipeToPlay</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 5</span><br><span class="line">    self.gameState = .pointToSurface</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>sceneView.hitTest() 执行一个 ray cast，你提供一个屏幕位置，也就是发射射线的位置，你也需要提供你正在寻找的对象的类型，.existingPlaneUsingExtent 具体说明了你只搜寻那些基于自身范围大小的已侦测到的平面，hits 被保存在 results 中。当然你还可以基于其他类型执行 ray cast，例如 featurePoints，estimatedHorizontalPlane，existingPlane.</li><li>你只需要寻找第一个 hit 结果，因此一旦发现，你要准备去更新 focus node</li><li>你将会使用 hit 结果的 worldTransform，这个矩阵包括位置，朝向，以及范围大小信息</li><li>你将基于 hit 结果 的 transform matrix 来更新 focus node 的位置，位置信息位于 transform matrix 的第三列</li><li>如果结果未被发现，游戏将会持续指导玩家去指向已被侦测到的平面</li></ol><blockquote><p>SceneKit Management</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func renderer(_ renderer: SCNSceneRenderer, updateAtTime time: TimeInterval) &#123;</span><br><span class="line">    DispatchQueue.main.async &#123;</span><br><span class="line">      //self.statusLabel.text = self.trackingStatus</span><br><span class="line">      self.updateStatus()</span><br><span class="line">      self.updateFocusNode()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>你现在应该看见了侦测到的平面，focus node 会立即弹出并且跟随你，随着你的指向而移动</li></ul><h4 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h4><ul><li>你可能会注意到有时候你的平面会部分重叠，ARKit 有时会合并多个侦测到的平面为一个平面，为了做到这个，ARKit 在创建新的之前需要去删除旧的平面，问题在于你还未执行 renderer(_:didRemove:for) 方法</li></ul><blockquote><p>Helper Functions</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func removeARPlaneNode(node: SCNNode) &#123;</span><br><span class="line">    for childNode in node.childNodes &#123;</span><br><span class="line">      childNode.removeFromParentNode()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>Plane Management</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func renderer(_ renderer: SCNSceneRenderer, didRemove node: SCNNode, for anchor: ARAnchor) &#123;</span><br><span class="line">    guard anchor is ARPlaneAnchor else &#123; return &#125;</span><br><span class="line">    DispatchQueue.main.async &#123;</span><br><span class="line">      self.removeARPlaneNode(node: node)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="Chapter-6-Add-Physics"><a href="#Chapter-6-Add-Physics" class="headerlink" title="Chapter 6: Add Physics"></a>Chapter 6: Add Physics</h1><h2 id="The-physics-body"><a href="#The-physics-body" class="headerlink" title="The physics body"></a>The physics body</h2><ul><li><p>为了使对象能够参与到 SceneKit 内置的物理模拟环境中，你必须要为 SCNode 新增SCNPhysicsBody</p></li><li><p>这里有三种基本的物理形态：</p></li></ul><ol><li>静态：本质上就是静止，例如城墙，在模拟环境中，其他物理形态物体将会和静态物体相互作用，但不会有任何反应，它将保持静止状态</li><li>动态: 完全被物理引擎所控制，在模拟环境中，动态物体可以四处移动与其他物理形态物体相互作用，例如骰子和球</li><li>运动态: 不被物理模拟环境所控制，被编程控制。允许你创建动态可移动的对象参与到物理模拟环境中去，例如越狱类游戏中的短浆</li></ol><h2 id="Controll-the-physics-world-speed"><a href="#Controll-the-physics-world-speed" class="headerlink" title="Controll the physics world speed"></a>Controll the physics world speed</h2><blockquote><p>initScene()</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scene.physicsWorld.speed = 0.05</span><br></pre></td></tr></table></figure><h2 id="Controll-the-physics-simulation-speed"><a href="#Controll-the-physics-simulation-speed" class="headerlink" title="Controll the physics simulation speed"></a>Controll the physics simulation speed</h2><blockquote><p>initScene()</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scene.physicsWorld.timeStep = 1.0 / 60.0</span><br></pre></td></tr></table></figure><h2 id="Recover-fallen-dice"><a href="#Recover-fallen-dice" class="headerlink" title="Recover fallen dice"></a>Recover fallen dice</h2><ul><li>为了防止骰子掉入无尽的深渊，你需要实时监视每一个骰子的位置，当位置低于特定的点时，骰子可以返回玩家手中</li></ul><blockquote><p>Helper Functions</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func updateDiceNodes() &#123;       </span><br><span class="line">   // 1</span><br><span class="line">   for node in sceneView.scene.rootNode.childNodes &#123;</span><br><span class="line">     // 2</span><br><span class="line">     if node.name == &quot;dice&quot; &#123;</span><br><span class="line">       if  node.presentation.position.y &lt; -2 &#123;</span><br><span class="line">         // 3</span><br><span class="line">         node.removeFromParentNode()</span><br><span class="line">         diceCount += 1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>你遍历了场景中所有可用的结点</li><li>你只对名字为 “dice”，且低于地面两米的骰子感兴趣</li><li>一旦你发现了符合条件的骰子结点，你将会把它从场景中移除掉，然后 diceCountOnce 增加 1 ，本质上就是骰子重新回到了玩家手中</li></ol><blockquote><p>SceneKit Management</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func renderer(_ renderer: SCNSceneRenderer, updateAtTime time: TimeInterval) &#123;</span><br><span class="line">    DispatchQueue.main.async &#123;</span><br><span class="line">      //self.statusLabel.text = self.trackingStatus</span><br><span class="line">      self.updateStatus()</span><br><span class="line">      self.updateFocusNode()</span><br><span class="line">      self.updateDiceNodes()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="Add-plane-physics"><a href="#Add-plane-physics" class="headerlink" title="Add plane physics"></a>Add plane physics</h2><blockquote><p>Helper Functions</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func createARPlanePhysics(geometry: SCNGeometry) -&gt; SCNPhysicsBody &#123;</span><br><span class="line">    // 1</span><br><span class="line">    let physicsBody = SCNPhysicsBody(</span><br><span class="line">        type: .kinematic,</span><br><span class="line">        // 2</span><br><span class="line">        shape: SCNPhysicsShape(geometry: geometry,</span><br><span class="line">          options: nil))</span><br><span class="line">    // 3</span><br><span class="line">    physicsBody.restitution = 0.5</span><br><span class="line">    physicsBody.friction = 0.5</span><br><span class="line">    // 4</span><br><span class="line">    return physicsBody</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>创建了一个运动态，除了你可以移动它之外，其他都与静态非常类似</li><li>第二个参数是一个物理形状，SCNPhysicsShape() 非常聪明，如果你提供对象的几何信息，它将会自动地为 3D 物体创建一个合适的形状，还有一个为 nil 的附加选项，由于你都是使用简单的平面，物理形状都会非常简单</li><li>调整平面的弹性和粗糙程度</li><li>返回结果给调用者</li></ol><blockquote><p>createARPlaneNode(planeAnchor:color:)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">planeNode.physicsBody = createARPlanePhysics(geometry: planeGeometry)</span><br></pre></td></tr></table></figure><ul><li>当创建 AR 平面结点时，你同时也需要为平面结点创建物理形态，现在，当 AR 平面结点被创建时，它会附有一个物理形态</li></ul><blockquote><p>updateARPlaneNode(planeNode:planeAchor:)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">planeNode.physicsBody = nil</span><br><span class="line">planeNode.physicsBody = createARPlanePhysics(geometry: planeGeometry)</span><br></pre></td></tr></table></figure><ul><li>通过设置 nil 来达到摧毁之前的物理形态的目的，然后重新创建物理形态，现在，当平面得到更新时，物理形态也同时更新</li></ul><h2 id="Randomize-rotation"><a href="#Randomize-rotation" class="headerlink" title="Randomize rotation"></a>Randomize rotation</h2><blockquote><p>throwDiceNode(transform:offset:)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let rotation = SCNVector3(Double.random(min: 0, max: Double.pi),</span><br><span class="line">  Double.random(min: 0, max: Double.pi),</span><br><span class="line">  Double.random(min: 0, max: Double.pi))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diceNode.eulerAngles = rotation</span><br></pre></td></tr></table></figure><h2 id="Add-force"><a href="#Add-force" class="headerlink" title="Add force"></a>Add force</h2><ul><li><p>Force 能够在一个特定的点上被施加，可分为有推动力的和无推动力的，有推动力的只能作用于物理形态上，比如投掷出一个骰子。无推动力的会作用于模拟环境的每一步，SceneKit 会将所有的力共同作用于物体并且加速物理形态，比如火箭的推进器，那里的力是持续的</p></li><li><p>Transform 是一个 SCNMatrix4，也就是 4 x 4 的数学矩阵，当你看到 m41 时，这就是指四行一列的矩阵，矩阵中的每一行都关联了一个 transform 值</p></li></ul><blockquote><p>throwDiceNode(transform:offset:)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">let distance = simd_distance(focusNode.simdPosition,</span><br><span class="line">  simd_make_float3(transform.m41,</span><br><span class="line">    transform.m42,</span><br><span class="line">    transform.m43))</span><br><span class="line">// 2        </span><br><span class="line">let direction = SCNVector3(-(distance * 2.5) * transform.m31,</span><br><span class="line">  -(distance * 2.5) * (transform.m32 - Float.pi / 4),</span><br><span class="line">  -(distance * 2.5) * transform.m33)</span><br></pre></td></tr></table></figure><ol><li>你需要施加一个方向不定的的力给骰子，这个力需要去包括筛子到 focus node 的距离，这行代码计算出了他们两者的距离</li><li>你想要去向前投掷出骰子，创建一个向前方向的矢量，包含你刚刚创建的距离，以及骰子的旋转</li></ol><blockquote><p>throwDiceNode(transform:offset:)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">diceNode.physicsBody?.resetTransform()</span><br><span class="line">// 2</span><br><span class="line">diceNode.physicsBody?.applyForce(direction, asImpulse: true)</span><br></pre></td></tr></table></figure><ul><li>更新了骰子物理形态的位置去匹配它实际的位置</li><li>给筛子施加了一个力，将它掷入到特定的方向，并伴随一个小的推动</li></ul><h2 id="Add-a-shadow-casting-light"><a href="#Add-a-shadow-casting-light" class="headerlink" title="Add a shadow-casting light"></a>Add a shadow-casting light</h2><blockquote><p>Properties</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var lightNode: SCNNode!</span><br></pre></td></tr></table></figure><blockquote><p>loadModels()</p></blockquote><ul><li>从 diceScene 中加载方向光，然后将它添加到 AR 场景</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lightNode = diceScene.rootNode.childNode(withName: &quot;directional&quot;, recursively: false)!</span><br><span class="line">sceneView.scene.rootNode.addChildNode(lightNode)</span><br></pre></td></tr></table></figure><h2 id="Light-estimation"><a href="#Light-estimation" class="headerlink" title="Light estimation"></a>Light estimation</h2><blockquote><p>initARSession()</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.isLightEstimationEnabled = true</span><br></pre></td></tr></table></figure><ul><li><p>允许 ARKit 基于侦测到的环境光强度来管理光的强度</p></li><li><p>当玩家在明亮的环境中，光的强度就会很高，当玩家在黑暗的环境中，光的强度将会变低</p></li></ul><h2 id="Suspend-AR-plane-detection"><a href="#Suspend-AR-plane-detection" class="headerlink" title="Suspend AR plane detection"></a>Suspend AR plane detection</h2><blockquote><p>Helper Functions</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func suspendARPlaneDetection() &#123;</span><br><span class="line">  // 1</span><br><span class="line">  let config = sceneView.session.configuration as!</span><br><span class="line">    ARWorldTrackingConfiguration</span><br><span class="line">  // 2</span><br><span class="line">  config.planeDetection = []</span><br><span class="line">  // 3</span><br><span class="line">  sceneView.session.run(config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>从 session 中得到了目前的配置信息</li><li>通过设置空数组清除了 planeDetection 属性 </li><li>重新运行，现在 ARKit 知道侦测更多的平面时该如何不去耗能</li></ol><h2 id="Hide-visible-planes"><a href="#Hide-visible-planes" class="headerlink" title="Hide visible planes"></a>Hide visible planes</h2><ul><li>显示所有被侦测的平面是无意义的，最好的办法是把它们移除</li></ul><blockquote><p>Helper Functions</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func hideARPlaneNodes() &#123;</span><br><span class="line">    // 1</span><br><span class="line">    for anchor in</span><br><span class="line">      (self.sceneView.session.currentFrame?.anchors)! &#123;</span><br><span class="line">      // 2 </span><br><span class="line">      if let node = self.sceneView.node(for: anchor) &#123;</span><br><span class="line">        // 3</span><br><span class="line">        for child in node.childNodes &#123;</span><br><span class="line">          // 4</span><br><span class="line">          let material = child.geometry?.materials.first!</span><br><span class="line">          material?.colorBufferWriteMask = []</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在 SceneView 遍历出所有可获得的锚，这一步是通过访问当前的 frame 来实现</li><li>得到当前锚相关联的结点</li><li>一旦你得到了相关联的结点，隐藏它和它的子对象</li><li>你只干星期第一个可获得的 material，一旦你得到它，你就能够通过设置空数组来清除它的颜色，这就简单地清除了结点 material 的所有颜色信息，最终达到隐藏结点的目的</li></ol><h2 id="Block-swipe-gestures"><a href="#Block-swipe-gestures" class="headerlink" title="Block swipe gestures"></a>Block swipe gestures</h2><ul><li>游戏还未开始，玩家不允许去投掷骰子</li></ul><blockquote><p>swipeUpGestureHandler(_:)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">guard gameState == .swipeToPlay else &#123; return &#125;</span><br></pre></td></tr></table></figure><h2 id="Start-the-game"><a href="#Start-the-game" class="headerlink" title="Start the game"></a>Start the game</h2><blockquote><p>Helper Functions </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func startGame() &#123;</span><br><span class="line">  DispatchQueue.main.async &#123;</span><br><span class="line">    self.startButton.isHidden = true</span><br><span class="line">    self.suspendARPlaneDetection()</span><br><span class="line">    self.hideARPlaneNodes()</span><br><span class="line">    self.gameState = .pointToSurface</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>startButtonPressed(_:)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.startGame()</span><br></pre></td></tr></table></figure><h2 id="Reset-the-game"><a href="#Reset-the-game" class="headerlink" title="Reset the game"></a>Reset the game</h2><blockquote><p>Helper Functions</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func resetARSession() &#123;</span><br><span class="line">  // 1</span><br><span class="line">  let config = sceneView.session.configuration as!</span><br><span class="line">    ARWorldTrackingConfiguration</span><br><span class="line">  config.planeDetection = .horizontal</span><br><span class="line">  sceneView.session.run(config,</span><br><span class="line">    // 2</span><br><span class="line">    options: [.resetTracking, .removeExistingAnchors])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过调整存在的 AR 配置来重新启动水平平面侦测</li><li>重新运行配置时，你传入了附加选项<ul><li>.resetTracking 本质上将会重启 ARKit</li><li>.removeExistingAnchors 将会摧毁之前侦测到的所有锚以及所有侦测到的平面结点</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func resetGame() &#123;</span><br><span class="line">  DispatchQueue.main.async &#123;</span><br><span class="line">    self.startButton.isHidden = false</span><br><span class="line">    self.resetARSession()</span><br><span class="line">    self.gameState = .detectSurface</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>resetButtonPressed(_:)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.resetGame()</span><br></pre></td></tr></table></figure><blockquote><p>sessionInterruptionEnded()</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.resetGame()</span><br></pre></td></tr></table></figure><ul><li>当出现问题的时候，这一招会特别好用， 例如当用户切换到另一个 App 时，或者是玩游戏的时候接了一个电话，这些情况发生时，直接重置游戏</li></ul><h2 id="Add-interaction"><a href="#Add-interaction" class="headerlink" title="Add interaction"></a>Add interaction</h2><ul><li>Hit test：有专门的函数可以执行 hit test，你需要做的只是提供用户触摸屏幕时的位置，SceneKit 将会发射一束射线进入增强现实场景，被射线所命中的物体将会被认为是 “hit” </li></ul><blockquote><p>Actions</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">override func touchesBegan(_ touches: Set&lt;UITouch&gt;,</span><br><span class="line">  with event: UIEvent?) &#123;</span><br><span class="line">  DispatchQueue.main.async &#123;</span><br><span class="line">    // 1</span><br><span class="line">    if let touchLocation = touches.first?.location(</span><br><span class="line">      in: self.sceneView) &#123;</span><br><span class="line">      // 2</span><br><span class="line">      if let hit = self.sceneView.hitTest(touchLocation,</span><br><span class="line">        options: nil).first &#123;</span><br><span class="line">        // 3</span><br><span class="line">        if hit.node.name == &quot;dice&quot; &#123;</span><br><span class="line">          // 4</span><br><span class="line">          hit.node.removeFromParentNode()</span><br><span class="line">          self.diceCount += 1</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>获得用户触摸屏幕的位置</li><li>使用被触摸的点作为 hit test 的开始点</li><li>你只感兴趣玩家触摸的是否是骰子</li><li>如果玩家确实触摸的是一个骰子，把它从场景中移除掉，并且通过增加 diceCount 来达到返回到玩家的手中的目的</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Chapter-3-Basic-Session-Management&quot;&gt;&lt;a href=&quot;#Chapter-3-Basic-Session-Management&quot; class=&quot;headerlink&quot; title=&quot;Chapter 3: Basic Session
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>七月七</title>
    <link href="http://yoursite.com/2018/07/08/loser/"/>
    <id>http://yoursite.com/2018/07/08/loser/</id>
    <published>2018-07-07T16:00:00.000Z</published>
    <updated>2018-07-08T02:52:31.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>I made every mistake, I felt the shame rise in me, and even now I lie awake.</p></blockquote><p>带了伞，却没下雨</p><p>话到嘴边，变了味道</p><p>我知道我守不住</p><p>我总是一边走一边丢</p><p>这下又把你弄丢了</p><p>原本以为看场喜剧能洗洗心</p><p>片尾曲响起——“人聚又人散，放过对错才知答案”</p><p>我不想知道答案，对错都交给时间</p><p>我准备好了很多东西想给你看</p><p>跟你聊聊我最后一年的规划</p><p>跟你聊聊我都在忙些什么</p><p>以及我的遗憾</p><p>怎奈，又多了一个遗憾</p><p>愿我们都能抵达梦中之地</p><p>路途遥远，务必珍重</p><p>月明星稀，乌鹊南飞</p><p>绕树三匝，何枝可依</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;I made every mistake, I felt the shame rise in me, and even now I lie awake.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;带了伞，却没下雨&lt;/p&gt;
&lt;p&gt;话到嘴边，变了味道&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>中文字体</title>
    <link href="http://yoursite.com/2018/06/30/chineseTypeface/"/>
    <id>http://yoursite.com/2018/06/30/chineseTypeface/</id>
    <published>2018-06-29T16:00:00.000Z</published>
    <updated>2018-09-19T14:23:14.608Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文整理自《中文字体应用手册 Ⅰ 》</p></blockquote><h2 id="字说"><a href="#字说" class="headerlink" title="字说"></a>字说</h2><ul><li><p><strong>字体设计是对文字造型进行有目的的艺术设计行为</strong>。中文字体设计深受书写工具和技术的影响，其造型的演变贯穿于整个汉字发展的过程。在这个过程中产生了一个独立的艺术门类：中国书法。</p></li><li><p>中文字体设计与书法同宗同源，二者都有着漫长的历史。随着时间的推移，字体设计与书法的目的逐步分化，虽然<strong>字体设计重在字形的整饬（chì）和信息的优化，书法则重在情意的表达</strong>，但是它们两者之间的关系却是血脉相连的。实践中形成的书写规则对字体设计具有直接的启示，设计思维也与书法创作有着精神上的贯通。“宋体字”便是在传统楷书基础上发展而来的，成为设计与书写高度结合的典范。</p></li><li><p>汉字的文字学分类以结构为本，如“甲骨文、篆、隶、楷”，而字体设计则可以在一个文字学类别之下演绎出万千风格，所谓的 “宋黑仿楷” 均属于文字学的楷书范畴。</p></li></ul><h2 id="甲骨文"><a href="#甲骨文" class="headerlink" title="甲骨文"></a>甲骨文</h2><ul><li>甲骨文是<strong>殷商时期</strong>刻在龟甲和兽骨上的一种文字，清末发现于河南安阳殷墟，是相当成熟的文字体系。</li><li>内容大多是 “卜辞”，也有少量记录事件的 “记事刻辞” 和记录历法的 “干支表” 。</li><li>文字较小，笔画纤细，起止尖锐，多直少曲。</li></ul><h2 id="大篆"><a href="#大篆" class="headerlink" title="大篆"></a>大篆</h2><ul><li><p>广义的大篆是<strong>对小篆之前汉字的统称</strong>，包括春秋战国时期的各国文字。另有商周时期铸刻在青铜器上的文字 “金文”，也属大篆。</p></li><li><p><strong>金文</strong>本质上是一种工艺性文字，多数为铸造而成，线条圆浑饱满。</p></li></ul><h2 id="小篆"><a href="#小篆" class="headerlink" title="小篆"></a>小篆</h2><ul><li><p>秦统一中国之后，推行 “书同文” 。李斯受命以秦大篆为基础，制定了一整套新的标准字形，即小篆，是<strong>汉字历史上第一种系统规范的字体</strong>。</p></li><li><p>字形略长，笔画婉转匀净，字形结构平衡对称，上紧下松，象形成分大大减弱，文字更加符号化。</p></li></ul><h2 id="隶书"><a href="#隶书" class="headerlink" title="隶书"></a>隶书</h2><ul><li><p>隶书源于秦代民间和下层官吏对篆书的简便书写，在汉代被官方认可为正式用字，是<strong>自下而上</strong>的文字演变。</p></li><li><p>由篆书发展到隶书的过程，被称为 “<strong>隶变</strong>” ，是汉字演变的重要转折点，汉字自此<strong>由古文字时代进入今文字时代</strong>。 </p></li><li><p>较之小篆，字形宽扁，变曲为直，“蚕头燕尾，燕不双飞” 。</p></li></ul><h2 id="楷书"><a href="#楷书" class="headerlink" title="楷书"></a>楷书</h2><ul><li>楷者，楷则也，即<strong>规范</strong>的意思。诞生于东汉后期，源自于对隶书的简便书写。楷书至唐初走向成熟，楷书四大家 “欧、颜、柳、赵” 中，前三位都是唐代人。</li><li><strong>楷书至今一直被作为汉字的规范形态</strong>，今天印刷字体中通行的宋体，仿宋体、黑体，都属于楷书范畴。</li></ul><h2 id="草书"><a href="#草书" class="headerlink" title="草书"></a>草书</h2><ul><li>草书因其难于辨认，基本脱离使用领域，而成为艺术表现对象。值得一提的是，通行的简化字字形有许多源于 “草写简化” 。</li></ul><h2 id="行书"><a href="#行书" class="headerlink" title="行书"></a>行书</h2><ul><li><strong>行书是对楷书的快写</strong>，介于草书和楷书之间，按潦草程度来说，写得接近楷书的称为 “行楷” ，接近草书的称为 “行草” 。</li></ul><h2 id="宋体"><a href="#宋体" class="headerlink" title="宋体"></a>宋体</h2><ul><li><strong>宋体字是对楷书的概括和程式化</strong>，是雕版刻工在雕刻楷书的过程中根据工艺需要逐步创造出来的，雏形出现于宋代，直至明代中期才成熟定型，如今已成为排版的主流字体，在日本和韩国被称为 “明朝体” 。</li><li>笔形统一规则，横细竖粗，带饰角（类似拉丁字母中的衬线）</li></ul><h2 id="仿宋体"><a href="#仿宋体" class="headerlink" title="仿宋体"></a>仿宋体</h2><ul><li>顾名思义是仿宋版书写字体的意思，当代印刷字体中的仿宋体就是以 “华丰真宋” 为蓝本发展而来的。</li><li>横竖笔画接近，略强调笔画的起止转折，字形取斜势，清秀挺拔，独具韵味。</li></ul><h2 id="黑体"><a href="#黑体" class="headerlink" title="黑体"></a>黑体</h2><ul><li>是 19 世纪末受西方<strong>无衬线字体</strong>的影响产生的一种新字体。</li><li>没有对笔画的起止、转折予以修饰，简洁醒目，富有现代感。</li><li>广泛用于标题、广告标语、屏幕显示，笔画细的黑体也逐渐成为正文用字。</li></ul><h2 id="中文字体术语"><a href="#中文字体术语" class="headerlink" title="中文字体术语"></a>中文字体术语</h2><p> <img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fsteevrxwhj31kw14okjl.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文整理自《中文字体应用手册 Ⅰ 》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;字说&quot;&gt;&lt;a href=&quot;#字说&quot; class=&quot;headerlink&quot; title=&quot;字说&quot;&gt;&lt;/a&gt;字说&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>软技能</title>
    <link href="http://yoursite.com/2018/06/26/softSkills/"/>
    <id>http://yoursite.com/2018/06/26/softSkills/</id>
    <published>2018-06-25T16:00:00.000Z</published>
    <updated>2018-06-28T05:20:48.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文整理自《软技能：代码之外的生存指南》</p></blockquote><h2 id="像企业一样思考"><a href="#像企业一样思考" class="headerlink" title="像企业一样思考"></a>像企业一样思考</h2><ul><li><p>企业需要持续不断地改进和完善自己的产品，你也应该这么做。作为一名软件开发人员，你提供的服务具备有形价值，你要传达的不仅是这款软件的价值是什么，还有它与别的成千上万款软件开发人员提供的服务有何不同。</p><p>如此这般，我们就把自己推向了<strong>营销</strong>，有一点很重要：你需要认识到仅有服务和产品是不够的。想赚到钱，你就必须能让潜在的客户了解该产品和服务。全世界的公司都认识到了商业社会的这一核心真理，这也是他们在市场营销上投入重金和精力的原因。作为一名提供服务的软件开发人员，你也要关注市场营销。产品营销做得越好，你就能给服务定越高的价格，也越有机会吸引更多的潜在的客户。</p></li><li><p>你需要做到：</p><blockquote><p>专注于你正在提供怎样的服务，以及如何营销这项服务；<br>想方设法提升你的服务；<br>思考你可以专注为哪一特定类型的客户或行业提供特定的服务；<br>集中精力成为一位专家，专门为某一特定类型的客户提供专业的服务；</p></blockquote></li></ul><h2 id="换位思考"><a href="#换位思考" class="headerlink" title="换位思考"></a>换位思考</h2><ul><li>停止用 “我” 和 “我想要什么” 来思考。你应当开始思考<strong>对他人而言</strong>什么才最重要，什么才是他们需要的。</li></ul><h2 id="为他人增加价值"><a href="#为他人增加价值" class="headerlink" title="为他人增加价值"></a>为他人增加价值</h2><ul><li><p>你提供的内容应该直接瞄准你所选定的领域，为该领域带来价值，如果你通过自己生产的内容解决了一个真实的问题，或者能让别人关注你文章的内容，那你就会<strong>为他人创造真正的价值</strong>。</p><blockquote><p>Try not to become a man of success, but rather try to become a man of value.</p></blockquote></li></ul><h2 id="有效运用社交媒体"><a href="#有效运用社交媒体" class="headerlink" title="有效运用社交媒体"></a>有效运用社交媒体</h2><ul><li>你的社交媒体应用策略应该主要聚焦于构建稳定的受众群体，并逐步提升活跃度。你应该想方设法让人们从关注者变为粉丝，这样他们就会更加关注你的内容，会与别人分享，也会积极地推荐你，这也是你打造业界声望的方法。</li></ul><h2 id="演讲"><a href="#演讲" class="headerlink" title="演讲"></a>演讲</h2><ul><li>演讲和举办某种形式的培训是连接普罗大众和自我营销的最有效的方式之一，虽然这一方式在扩散速度上比不上其他媒介，但是站在目标受众面前，直接面对他们侃侃而谈，却是最能打动他们的方式。</li></ul><h2 id="寻找导师"><a href="#寻找导师" class="headerlink" title="寻找导师"></a>寻找导师</h2><ul><li><p>拥有一名导师可以说是巨大的财富，一名优秀的导师能够让你无需亲身经历现实的重重考验就拥有丰富的经验。你也可以从导师的失败中汲取经验，优秀的导师可以帮助你迅速地掌握一门技术。</p></li><li><p>寻找导师时的检查单:</p><blockquote><p>他做到了我想要去做的？<br>他曾经帮助他人做到了我想要做的?<br>他现在取得了什么可以展示的成就？<br>你能和这个人和睦相处吗? 他充满智慧吗？</p></blockquote></li></ul><h2 id="必为人师"><a href="#必为人师" class="headerlink" title="必为人师"></a>必为人师</h2><ul><li><p>教学通常需要正规的资质，<strong>而教学的真谛则是与他人分享知识</strong>。</p></li><li><p>在你的知识合集里面，总有一部分知识你并没有理解到可以向别人解释，而“教”的过程能够迫使你面对这一部分，在教别人的时候，你迫使自己面对课题中的难点，深入探索，从只知皮毛变成完全理解。</p></li><li><p>在教别人的过程中，你需要重新组织大脑中的所有数据，当我们刚开始学新东西的时候，通常都是些零散的知识点，这种在大脑中存储信息的方式非常低效，这就是当别人来问你问题时，你明明知道答案，但说出来却前言不搭后语，你自己知道，却无法解释地一清二楚。在你试图教别人的时候，你强迫自己重新组织大脑中的资料，要教别人，你得先把自己教会，传道授业解惑为何是卓有成效的学习方法，原因正是如此。 </p></li></ul><h2 id="快速掌握一门技术"><a href="#快速掌握一门技术" class="headerlink" title="快速掌握一门技术"></a>快速掌握一门技术</h2><ul><li><strong>如何开始</strong>——要想开始使用自己所学的，我需要掌握哪些基本知识？</li><li><strong>学科范围</strong>——我现在学的东西有多宏大？我该怎么做？在开始阶段，我不需要了解每个细节，但是如果我能对该学科的轮廓有大致的了解，那么将来我就能发现更多细节。</li><li><p><strong>基础知识</strong>——不止在开始阶段，要想使用一项特定的技术，我需要了解基本的用户案例和最基本的问题，也需要知道自己学的哪 20% 就能满足 80% 的日常应用。</p><p>熟知这三点之后，可以高效地学习一门技术，无须通晓全部细节，能够随着学习的深入学会所需的其他知识，如果想提前掌握所有知识，那只是在浪费时间，因为真正重要的内容会湮没在那些细枝末节中。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文整理自《软技能：代码之外的生存指南》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;像企业一样思考&quot;&gt;&lt;a href=&quot;#像企业一样思考&quot; class=&quot;headerlink&quot; title=&quot;像企业一样思考&quot;&gt;&lt;/a&gt;像企业一样思考&lt;/h
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>现代艺术 150 年</title>
    <link href="http://yoursite.com/2018/02/25/modernArt/"/>
    <id>http://yoursite.com/2018/02/25/modernArt/</id>
    <published>2018-02-24T16:00:00.000Z</published>
    <updated>2018-06-28T05:16:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文整理自《现代艺术150年：一个未完成的故事》 </p></blockquote><h2 id="泉-1917"><a href="#泉-1917" class="headerlink" title="泉 1917"></a>泉 1917</h2><ul><li><p><strong>马赛尔·杜尚</strong>（1887-1968）相信自己发明了一种新的雕塑形式，即艺术家可以选择任何已有的、批量生产且不具有明显美感的物件，通过解除其实际功用，通过给它命名，通过改变通常被观看的角度和背景，使它变成一件事实上的艺术品。他把这种新的艺术形式称为“现成品”：一件原本已经制成的雕塑。</p><p>杜尚认为，应该由艺术家决定什么是艺术品，什么不是，如果一名艺术家说某件东西是艺术品，且对其背景和含义施加了影响，那么它就是一件艺术品。那些媒介——油布画、大理石、木头或石头——直到现在还在支配着艺术家将要或者能够制作什么样的艺术品，媒介总是第一位的，只有先具备了媒介，艺术家才可以通过油画、雕塑或素描将他的理念呈现出来，杜尚认为，媒介是第二位的，最首要和最重要的是理念，只有在艺术家确定并发展出一种理念之后，他才可以选择媒介，而这一媒介则应该是最能成功表现这一理念的。</p><p>杜尚还想揭露一种广泛存在的看法的虚假性：在某种程度上，艺术家在人类社会中属于高级一点的物种，因为他们被认为具有非凡的聪颖、洞察力和智慧，杜尚觉得这很荒谬，艺术家太把自己当回事儿，别人也太把他们当回事儿。</p></li><li><p>《泉》是一件“现成的”雕塑，从未公开展出过，可它却成为 20 世纪产生的最具影响力的一件艺术品，它所体现的理念对多次重大的艺术运动产生了直接的影响，包括达达主义、超现实主义、抽象表现主义、通俗艺术和观念艺术。在当今现代艺术家中，从艾未未到达米恩·赫斯特，马赛尔·杜尚无疑是最受尊敬和被提及最多的艺术家。 </p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fosgystbr7j30m80nib29.jpg" alt=""></p><p>杜尚重新定义了艺术是什么和艺术可以是什么。不错，艺术仍然包括绘画和雕塑，但它们仅仅是无数表达艺术家思想的媒介中的两项。无疑，杜尚应当对整个“这是艺术吗？”之争负责，而这场争论当然又恰是他有意为之。对他来说，一名艺术家在社会中的作用与哲学界相近，他或她能不能作画甚至都无关紧要。一名艺术家的工作不是给人以美感上的愉悦——设计师可以做这事，艺术家的工作是从尘世中撤出一步，通过展示理念，使世界可以理喻或对世界进行评论。而这些理念除了它们本身之外，并无实际用途。他对艺术的这一解释，随着 20 世纪 50 年代末 至 60 年代的约瑟夫·博伊斯等行为艺术家的出现，被推向极致，他们不仅成为了理念的创造者，同时也是表达理念的媒介。</p></li><li><p>杜尚在现代艺术史中脱颖而出，但他并不是这一时代的开启者。这一时代开启于 19 世纪，当时他甚至还没出生。那时，各种各样的世界大事在巴黎发生，使它成为地球上最令人震撼的知识之都。这是一座处处令人兴奋的城市：空气中弥漫着革命的气味。这种气味不断被一群冒险的艺术家所吸纳，他们即将推翻艺术权威们陈旧的世界秩序，迎来一个艺术的崭新时代。</p></li></ul><h2 id="前印象派：走向真实-1820—1870"><a href="#前印象派：走向真实-1820—1870" class="headerlink" title="前印象派：走向真实 1820—1870"></a>前印象派：走向真实 1820—1870</h2><ul><li><p>印象派是现代艺术的“主义”之一，我们大部分人会对它感到相当的自信和舒服。与那些更加现代的艺术相比，得承认这些印象派的绘画可能有些落伍，不致引起争议，或许还有点令人生疑地赏心悦目。这是些可爱画作，用具象的手法来描绘出尚能被辨认的风景，我们怀着毫不掩饰的浪漫主义精神，观赏印象派艺术家 19 世纪末的作品：那些在公园里优雅野餐的巴黎人，在酒吧喝着苦艾酒的酒鬼，还有被蒸汽围绕、奔向光明前程的火车。比较传统的人认为，在现代艺术的范畴内，印象派艺术家是创作“正当艺术”的最后一批人。他们没有涉足任何“概念化的胡说八道”以及后来出现的“无意义的抽象涂写”，他们的绘画主题清晰，画面优美，清新无害。</p><p>实际上，这并不完全正确，起码当时人们并不这样认为。在整个艺术史中，印象派画家是最激进、最反叛、最能突破障碍和开创新纪元的一群人。在对自己的艺术视野孜孜不倦的追求的过程中，他们经受了人生的磨难和业内的嘲讽。他们扯碎了那些规则手册，就好像脱下裤子，集体朝艺术保守派扭屁股，煽动了我们现在称之为现代艺术的全球革命。许多 20 世纪的艺术运动，比如 1990 年代的英国艺术运动，会被贴上具有破坏性和无政府主义。但实际上它们远不够格。而那些看来令人尊敬的 19 世纪的印象派画家，其实才是最初的反叛者，他们才是真正的无法无天。</p></li><li><p>印象派艺术家通过拆除工作室与实际生活之间的壁垒而改变了游戏规则。其他的艺术家也会走出工作室去观察和素描他们的题材，尔后再回到室内，将他们的见闻编绘成小说般的画面。而印象派艺术家主要就是在室外工作的，在那里开始并完成他们关于现代大都市生活的绘画。他们认为，新的主题内容需要一种新的技法。而在当时，官方唯一批准和接受的绘画方法是文艺复兴时期达·芬奇、米卡朗基罗和拉斐尔的“高贵风格”，在法国的榜样之一是尼古拉斯·普桑。制图术就是一切，艺术是关于精确的东西。</p></li><li><p>印象派还不算是最早对学院感到绝望的艺术家，这一机构令人窒息的保守主义已经引起了<strong>泰奥多尔·席里柯</strong>的不满，一位杰出的年轻画家。 席里柯英年早逝，不过在去世前创作出了 19 世纪最重要的画作之一：《美杜莎之筏》，它描绘了一名无能的法国船长因过近地驶向塞内加尔海岸，造成了可怕的后果，画的中央，面朝下躺着一个肌肉发达的男人，他死了，但据说席里柯作画时的模特却是一个大活人，而且也作画。他是一名来自巴黎社会上层的年轻艺术家，名字叫<strong>欧仁·德拉克洛瓦</strong>（1798—1863）。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fosh1id009j30zk0oau0y.jpg" alt=""></p><p>德拉克洛瓦的创新对印象派艺术家具有巨大的影响，显然他的绘画有点偏重历史题材，但他在所有印象派艺术家出生之前便意识到，可以用敏捷而充满活力的笔触，在某种程度上将法国革命生活的巨大能量重塑出来。</p><p>《自由引导人民》今天被认为是浪漫主义时代的杰作，现悬挂在巴黎卢浮宫，画中的主人公是一名坚定的妇女，一个自由的化身，她一手挥舞法国革命的三色旗，另一只手则握着带刺刀的滑膛枪，引导战士们踏着倒下的尸体前进，这一场面暗指波旁王朝查理十世在 1830 年 7 月被推翻的事件，政治上颇为老练的德拉克洛瓦对这一事件显然是有站队的。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fosh2n5bipj30sg0mu4qq.jpg" alt=""></p><p>该画的主题是当代的，但女神的形象却被浪漫化了，金字塔的构图起到了提升女神的英雄主义精神的作用。正是德拉克洛瓦对自由化身的想象，后来成为那座法国赠送给美国的著名地标性建筑——自由女神像的灵感来源，这里还有一个典故，那穿着褶布般的女神暗示着另一尊著名的希腊风格雕塑，萨莫色雷斯的胜利女神，这使得这幅画染上了亲民主的强烈政治气息。</p><p>《自由引导人民》展现了一名艺术大师的现代绘画技巧，包括采用生动的色彩、对光线的关注和明快的笔画，这一切都是四十多年后印象派运动的核心要素。然后，德拉克洛瓦画的是一个虚构的场景，而印象派艺术家寻求的却是真相，且仅仅是真相，在这一方面，他们的灵感来自于另一位不那么复杂的人物。</p></li><li><p>如果德拉克洛瓦是法国最伟大的浪漫主义画家，那么<strong>古斯塔夫·库尔贝</strong>（1819—1877）则是最成功的现实主义艺术家，年级较轻的库尔贝敬慕德拉克洛瓦，后者也敬慕前者，但他无暇关注浪漫主义时期绘画里出现的那些古怪的假象和典故。他希望能现实一点，描绘学院和上流社会觉得粗俗的题材，比如穷人。</p><p>他的画作《世界的起源》是艺术史上最声名狼藉的作品之一，库尔贝作为一名艺术家，不仅举止粗野，作风硬朗，还耽于杯中物。但他对自己这一名声沾沾自喜，像个斗士一样喜好冲突。他是最早的谈话节目主持人，是民众的代表，他知道自己在同胞中的声望可以让他狠狠打击和刺激艺术保守派，当学院派说他自负，他只是耸耸肩。当他们因为他的作品比例不对，或是描绘了当代法国常见的、受压迫的场景而对其进行批判，他就走开，接着创作出更多同样题材的画作。</p><p>德拉克洛瓦的浪漫主义将生动的色彩和敏锐的洞察力引入绘画，库尔贝的现实主义则带来了普通百姓生活中的那种无拘无束、非理想主义的真实。两位艺术家均抵制学院派的僵硬刻板和新古典主义复兴风格，但对于印象派艺术家来说，出现的时机尚未成熟。在他们领导艺术进入一个新时代之前，首先需要一位能把德拉克洛瓦精湛的绘画技艺和库尔贝毫不退缩的现实主义融为一体的艺术家。</p></li><li><p>这一重任落到了<strong>爱德华·马奈</strong>（1832-1883） 这位最不情愿的反抗者肩上。他的父亲是一位法官，其教育让他尤为倾向于站在法律的正确一方。可是，一位标新立异的叔叔略施援手，使马奈的艺术之心战胜了循规蹈矩的头脑。</p><p>《喝苦艾酒的人》描写了生活在底层的巴黎人，一个处于社会边缘的穷困潦倒的醉鬼，一个城市现代化进程中的牺牲品。沙龙委员会不屑地拒绝了这幅画，马奈对学院的拒绝深感不安，但不打算向他们的武断屈服。他继续沿着自己的道路前进，1863 年，他拿出了《草地上的午餐》，该画充满了对学院必然认可的过往作品的参照和引用，学院再次拒绝了这幅画作。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fosh7jylnuj30m811ze81.jpg" alt=""></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fosh8nmm6cj30zj0rmkjm.jpg" alt=""></p><p>然而，并不只是他一人的作品被拒，还有令人难以置信的三千多件艺术品也遭此同一命运，进步派和学院之间的矛盾开始升温，甚至拿破仑三世都感到了它的热量，为了展示自己更加开明的一面，他坚持在学院沙龙的对面设立第二个展览，大众由此可以评判哪一方对艺术的理解更好，1863 年，这个相对的展览就叫“落选展览”。</p><p>与此同时，马奈完成了另一幅或许能够入选沙龙的作品《奥林匹亚》（1863），他又一次通过引用历史上的艺术作品将一个裸体体裁包裹起来。在正常情况下， 这样一幅描绘裸体女人的作品应该使学院派感到高兴，因为他们认为，对一个理想化的裸体进行古典化的描绘是一名艺术家毕生作品的顶点，可是马奈并没有将笔下的裸体理想化。实际上，马奈以提香《乌尔比诺的维纳斯》（1583）中的神话美人为原型，但把她转变成了一个妓女。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1foshbj5sxfj30zk0o2u0x.jpg" alt=""></p><p>马奈的《奥林匹亚》被沙龙接受了，却引起了巨大的争议，画中显然是一个以库尔贝那种“恬不知耻”的现实主义手法描绘出来的现代娼妓，画中充满了性暗示，一个黑猫，一只脱下的拖鞋，一束花，以及别在头上的那朵兰花。</p></li><li><p>1863 年对现代艺术来说是突破性的一年。“落选沙龙”、马奈的《奥林匹亚》、艺术界反文化的第一波浪潮，所有的这一切为居住在巴黎或周边的年轻画家们，造就了一个得以打破束缚的社会环境。同年还发生了一件重要的事，它对印象派艺术家们也产生了深远的影响。法国诗人、作家、评论家<strong>夏尔·波德莱尔</strong>写了一篇散文，题目叫《现代生活的画家》。</p><p>乱世之中，经常有那么一个人，观察着事态的发展，并将当中的精髓提炼成文字，成为受压迫者的指南。对于那些以巴黎为大本营、在 19 世纪下半年叶与学院派作斗争而深感失望的艺术家来说，《现代生活的画家》便是这样的文字。在这一篇散文发表之前，波德莱尔已经花了很多的工夫，以一名受尊敬的诗人和作家的身份，支持那些被大多数人嘲讽和拒绝的艺术家。</p><p>他在《现代生活的画家》中所提出的许多观点不断被收录为印象派的基本原则，波德莱尔强烈认为，记录他们的时代是在世艺术家义不容辞的责任，并借此认识到一个天才画家或雕塑家自己所处的独特位置，他激励艺术家们于现代生活中“从短暂发现永恒”，他认为，这才是艺术的根本意义——在日常之下抓住普遍的法则。</p><p>实现这一目标的方法就是把自己沉浸在大都市的日常生活中：观察，思考，感觉，最后记录。这一艺术理念给予马奈以蔑视学院的勇气，贯穿整个现代艺术史，杜尚是一名“浪荡子”，沃霍尔也是，还有许多如今仍在创作的艺术家。但马奈确是第一个，也是最伟大的“浪荡子”，或者，如他自称，一个现代生活的画家。他在 1860 年代创作的两幅主要作品，《奥林匹亚》和《草地上的午餐》，现在被称赞为堪与人类历史上最伟大的艺术作品比肩的杰作。</p><p>马奈反感自己被“扮演”成反对正统派的角色，但是艺术史还是决定让马奈扮演反抗者的角色，因此尽管不情愿，他还是成了一群异见艺术家的首领，这些艺术家包括劳德·莫奈、卡米耶·毕沙罗、皮埃尔-奥古斯特·雷诺阿、阿尔弗雷德·西斯莱和埃德加·德加，这群人将组成印象派——通常被认为是现代艺术中的首次运动的核心。</p></li></ul><h2 id="印象派：现代生活的画家-1870—1890"><a href="#印象派：现代生活的画家-1870—1890" class="headerlink" title="印象派：现代生活的画家 1870—1890"></a>印象派：现代生活的画家 1870—1890</h2><ul><li><p><strong>莫奈</strong>是以一名漫画家的身份开始其艺术生涯的，在遇见<strong>欧仁·布丹</strong>（1824-1898）后他改变了他的创作志向，布丹鼓励他到室外去作画。莫奈把他的新路子与他在艺术学院遇到或通过学院认识的朋友分享。卡米耶·毕沙罗、皮埃尔-奥古斯特·雷诺阿、阿尔弗雷德·西斯莱和保罗·塞尚，他们观察、聆听莫奈的分享，然后也走上了同一条道路。</p><p>莫奈把在伦敦的大部分时间用在研究英国现代风景画艺术家的作品上，一位艺术家颇具艺术格调的绘画真正燃起了他想象的火焰。<strong>特纳</strong>也是一位对自然光的效果着迷的画家，《雨、蒸汽和速度》描绘的是一列快速行驶的蒸汽火车正高速穿过一座横跨伦敦西边泰晤士河的壮观新桥，这是工业现代化的一个缩影。特纳对这幅画的处理手法如同这幅画的题材一样领先，阳光下的金黄雨雾像幔帐一样斜斜地冲刷着画面，使几乎所有的细节都模糊不清，在特纳创作出《雨、蒸汽和速度》后一百年，美国抽象主义艺术家将借此成名。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1foshch5nx1j30zk0qkkjm.jpg" alt=""></p><p>《威斯敏斯特下的泰晤士河》这是一张粗略到到几乎没有焦点的绘画，也正是莫奈的重大成功，这幅画是印象派的典范，无论建筑物、河水及天空怎么化为一片模糊的景物，缺乏精巧的清晰度倒为画面注入了生机，激起观众的丰富想象，就像一部电影把观众带入画中的故事。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1foshd5mmbxj30m80ea1dt.jpg" alt=""></p><p>影响了莫奈的人物有很多：有巴比松派风景画家、马奈、康斯太勃尔、特纳和惠斯特，等等，或许令人惊奇的是另一灵感来源是日本绚丽的、二维的浮世绘木板雕刻。浮世绘大师<strong>歌川广重</strong>（1797-1858）和<strong>葛饰北斋</strong>（1760-1849）同样受到马奈的尊崇。正是他们平面化的绘画作品的影响下，如葛饰北斋著名的《神奈川巨浪》（约 1830-1832）——画中的富士山在有着巨大白色浪尖的海浪面前变得矮小，马奈开始在他的绘画中大大缩短透视中的远景，这从《奥林匹亚》和《草地上的午餐》都可以看出。而今，莫奈正在更多地吸收他们的方法。《威斯敏斯特下的泰晤士河》采用不同的构图法。把大部分主题内容安排在画面右方，这是浮世绘用以激发情感张力的一种标准技巧。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1foshedvotmj31hc0zv4qu.jpg" alt=""></p></li><li><p>在绘画上，受日本木刻板影响的法国现代艺术家并非只有马奈和莫奈两位，所有印象派画家都喜爱它们的风格鲜明与漫画般的简洁，<strong>埃德加·德加</strong>更为典型，他的画作有许多都应归功于浮世绘艺术家创作的形象。他尤其敬重<strong>安藤广重</strong>，后者创作了数百幅版画，包括描绘江户与京都之间 290 英里公路上 53 个车站的系列作品。其中一幅《大津站》（约 1848-1849），展现的是正在忙活的旅行者的日常生活情景，这没什么特别的，但观察的角度和构图却值得注意。整个画面沿左下角至右上方的斜线进行安排，将目光带出框外，带往一个单一的、想象中的尽头。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1foshfkjcmmj31jk114e85.jpg" alt=""></p></li><li><p><strong>杜兰-鲁埃</strong>数十年形成的高度灵敏的视觉触角，能够在瞬间辨认出与众不同的绘画天才，他购入莫奈和毕沙罗的绘画，并且决定不等学院的年度沙龙打开市场，而是自己主动参与，亲自为他们创造市场，实际上成为了两位艺术家的代理人，给他们提供月薪维持生计，使他们摆脱学院束缚，不仅承诺直接购买他们的大部分作品，而且还要创造出他们作品的商业需求，以此来改变艺术市场的运作模式。</p><p>时刻留心的杜兰-鲁埃也看出，现代艺术市场正在改变，革命与机械化催生了一个被称为资产阶级的新的社会阶层，他猜测这些中产阶级可能会要求一种不同的艺术。这一计划基于对他受赞助人作品风格的信任，也基于他的猜测，最终打破了学院对巴黎艺术家生涯的禁锢，这些有天赋却被拒之门外的艺术家，在商业上有了另外的选择，而且杜兰-鲁埃使他们经济独立，能够不受干扰地追寻自己的目标，这直接推动了现代艺术的萌生和快速发展。</p><p>1886年，杜兰-鲁埃在美国举办了一场大规模的印象派展览，印象派的名声正式确立，也正是这届展览之后，由于艺术理念、地理位置和个人性格方面的差异，最终导致了这些被合称为印象派的艺术家逐步走向分裂。</p></li></ul><h2 id="后印象派：拓展领域-1880-1906"><a href="#后印象派：拓展领域-1880-1906" class="headerlink" title="后印象派：拓展领域 1880-1906"></a>后印象派：拓展领域 1880-1906</h2><ul><li><p>“后印象派艺术家”在他们（文森特·梵高、保罗·高更、乔治·修拉和保罗·塞尚）离世后很长一段时间才被创造出来。</p></li><li><p>梵高与表现主义：</p><p>没有人比荷兰人<strong>文森特·梵高</strong>（1853-1890）对表现主义发掘得更多，他的故事也许比现代艺术经典中的其他任何艺术家的故事还要广为人知：他的疯狂，割掉的那只耳朵，他的向日癸，还有自杀。卡沙罗曾用一句话概括梵高：“这个人将来要么发疯，要么超过我们所有人”。</p><p>文森特和<strong>保罗·高更</strong>（1848-1903）这两位自学成才的艺术家从巴黎时期起就是朋友，他们相互竞赛和劝诱，两人都成功完成了艺术上的使命，文森特为一种更具表现力的新运动奠定了基础，而高更则朝着更加奇异的方向走去。</p><p>今天我们对梵高的艺术就像对他的生平一样熟悉，而他活着的时候却不为人所知。但是这种熟悉并不能让你在第一次接触他的绘画时就做好接受的准备。这就像你第一次去听柏林爱乐乐团的演出或在狂欢节期间参观里约：当面对伟大的生命力量，另一种维度被添加了进来。这些事物的本质只有不经任何媒介才能真正体会到，换而言之就是，必须身处其中。对于梵高而言，这种本质就是他所表现的对象，因为梵高许多杰出的绘画不单单是画，它们更像是雕塑。</p><p>他用强墨重彩，更具表现力和戏剧性。通过严格客观描绘所见，印象派画家力图彰显真实，而梵高则要更近一步，他要展现关于人类境遇的更深刻的真理，不仅描绘所见，还有他对所见的感受。他开始扭曲他笔下的形象以表达感情，追求效果而极力夸张。他就是以这样的做法促成了 20 世纪意义最为深远和经久不衰的艺术运动——表现主义。</p><p>画完《去往塔拉斯孔路上的画家》之后两年，梵高离开人世。他刚刚三十七岁，正处于创作的旺盛时期，死于此前两天他朝自己胸部开枪所造成的创伤。陪在他身边的是敬慕他的弟弟提奥，数月之后，提奥也离世，持续了十年的伙伴关系就此结束，也正是因为这种关系才产生了这些最伟大的艺术作品。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1foshm90gx7j30m80oq1ky.jpg" alt=""></p><p>在他去世三年内，挪威艺术家<strong>爱德华·蒙克</strong>（1863-1944）创作出《呐喊》（1893），模仿了梵高“扭曲”形象的方法来传递他心灵深处的情感，成为表现主义的经典之作。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1foshmz3y2wj30m70sb4qq.jpg" alt=""></p></li><li><p>高更与象征主义：</p><p>“我是一个伟大的艺术家，而且我知道这一点。”保罗·高更自夸道。在另一个场合他还说过，梵高“受益于我的知道，每一天他都为此感谢我。”1880年代末，高更决定挑战印象派艺术家所严格遵守的自然主义信条，用鲜艳的用色和离巣自立的题材表明他开始脱离印象派。</p><p>《布道后的幻象》或称《雅各与天使搏斗》（1888），是高更在后印象派阶段的一个早期作品，描绘了一群布列塔尼的乡下妇女在教堂听完布道不久后经历的一场神圣幻想——雅各与一名天使搏斗的圣经故事，为了反映妇女们所经历的宗教梦幻，他选择放弃真实，将青草地画成了一种青紫的橘红色。由于圣经故事的加入、非自然颜色的分层和充斥着神话典故的画面，这一场景被夸大了，比如那根斜穿画面，将其一分为二的树干，是为高更的叙述策略服务的，树干的左边是现实世界，而右边则是她们想象的虚构故事。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1foshnzosaqj30zk0s27wj.jpg" alt=""></p><p>高更《布道后的幻想》中的梦幻状态将成为超现实主义的先兆，布列塔尼妇女生活的温和自然是高更有关塔希提人绘画中原始主义的先导，激发了巴勃罗·毕加索、亨利·马蒂斯、阿尔伯特·贾科梅蒂和亨利·卢梭的灵感，而画面中大片使用纯色抹去一切阴影的手法，是从日本版画里挪用过来的。</p><p>高更是冥顽不化的，他认为印象派艺术家缺乏智力上的严谨，无法看到现实之外的任何东西。他认为他们对生活的理性看法否定了艺术最重要的元素：想象力。他对他们的厌倦并未止于其艺术观点，他开始讨厌他们最重要的主题：现代生活，它开始启程前往塔希提岛，在质朴的自然中更新自己。</p><p>远在百步之外，你就能发现高更的作品，色彩斑斓的金赭色、混杂的绿色、巧克力褐色、鲜亮的粉色、红色和黄色，对比鲜明，下笔胸有成竹，这确实不是能学来的。他的绘画，还有他的雕塑，立即就能吸引人们的目光，却也出人意料地复杂。它们是心理剧，揭露出折磨着描绘对象的那些忧郁和创伤，也折磨着我们所有人。他反抗印象派，使艺术回归想象的王国，一代又一代的艺术家对此无不心怀感激。</p></li><li><p>修拉与点彩画派：</p><p><strong>乔纳森·艾维</strong>带给苹果公司产品的简洁，如同海明威词句的简短、巴赫大提琴乐章的清晰，都是通过弄清对象内在杂乱和复杂性的意义是什么，通过将其形状与功能以完美的方式统一而实现的。这将是整个 20 世纪里艺术家们将奋力争取的那种简洁，例如，<strong>彼得·蒙德里安</strong>的荷兰风格派运动（1917-1931）的垂直和水平网格，以及 1960 年代<strong>唐纳德·贾德</strong>的矩形雕塑的极简风格。</p><p>印象派艺术家中的第三名，这位男人像梵高一样认真，但不那么情绪化，与感情奔放的花花公子高更相比，更是截然不同，尽管在个性和背景方面存在差异，但三人一致决心要使艺术冲破他们眼中的印象派的樊篱。十分遗憾的是，这三位艺术家都英年早逝，高更最长寿活到了五十五岁，其次是梵高，他在三十七岁的时候自杀身亡，这则噩耗压垮了修拉，他在一年后也撒手人寰。</p><p>如果通过艺术这种模棱两可的东西，在这个世界上建立秩序与稳固，这是一直困扰修拉的问题，修拉是一名对自己、对生活、对艺术都非常认真的艺术家，他也是一个高度神秘、反对社交的人物，只为了使自己能脱身到画室中来，这里才是他真正的创作领地，而不是在露天的室外作画。他会在外面“面对描绘对象”绘制一些草图，但之后将回到画室完成画面的主要部分。不像莫奈，他对猎取稍纵即逝的瞬间不感兴趣，修拉的目标是为印象派带来秩序与纪律，吸收他们在用色上的创新并予以整理，让他们的客观性带有更多科学方法论的说明。</p><p>他是德拉克洛瓦的粉丝，并与这名浪漫的艺术家一样对颜色理论感兴趣。他认为，现代艺术所需要的是将前辈大师们的精准与印象派艺术家对颜色和现代生活的研究结合起来，修拉摈弃印象派那种即兴的画法，代之以将点状颜料大量细致地涂于画布的做法，他经常从色轮相对的两边挑选，以加强他们的活力。</p><p>《大碗岛的星期天下午》（1884-1886）是世界上最受认可的绘画之一，足以看出修拉精细绘制的彩点闪耀出的辉煌色彩，那些形成反差的纯色彩点，像玻璃杯里的香槟酒在你眼前嘶嘶冒泡一样，使画面充满活力，但那些在周日打扮潇洒、在太阳下愉快地散步的巴黎人却并非如此。他们死板而没有生气，看起来就像纸片人一样。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1foshqbzrg0j31hb0zinpi.jpg" alt=""></p><p>1886 年《大碗岛的星期天下午》在最后一届印象派展览上展出，标志这一运动发生了巨大的变化。它是一副非常典型的后印象派绘画。它没有任何印象派艺术家那种“转瞬即逝的瞬间”，它更像奏乐小人的游戏，其中的人物形象被凝固在那里，音乐停止后还保持他们的姿势。虽然这幅画描绘的是 19 世纪后期现代城市生活的一个典型场景，但其构图的和谐、简洁、重复使用的几何图形和大块的阴影均将时光折回到文艺复兴的年代，使人想起古典时期的文物和埃及的饰带。圆点预示着像素化的数字时代，而几何图形的和谐一致则与现代的产品设计相呼应，乔纳森·艾维的设计中有修拉的某些因素。</p></li></ul><h2 id="赛尚：吾人之父-1839-1906"><a href="#赛尚：吾人之父-1839-1906" class="headerlink" title="赛尚：吾人之父 1839-1906"></a>赛尚：吾人之父 1839-1906</h2><ul><li><p>他是这群人中最年长、最古怪的一位，他早在印象派运动刚开始便参与其中，他是整个现代运动中最伟大的艺术家，甚至连毕加索都称他为“吾人之父”。  </p><p>“他是第一位使用双眼作画的艺术家。” <strong>大卫·霍克尼</strong>（1937 年生）说道。塞尚牺牲了待在巴黎的快活，而在位于法国南部普罗旺斯地区的家乡艾克斯附近，自愿度过了将近四十年与世隔绝的生活。如同在吉维尼的莫奈，或者在阿尔勒的梵高，塞尚也沉迷于研究当地独特的风景。这位艺术家决心搞清楚画家如何才能丝毫不差的反映创作对象：不是印象派风景画中的转瞬即逝的瞬间，不是照片那样“一景对众人”的精确，而是对主题进行严密观察后把它真实反映出的精准，被问及自己最大的愿望是什么的时候，他的回答是“确定”。塞尚选择进一步将问题深化，他还关心自己怎么看，在一百三十年前就意识到，眼见不一定为实，这样的哲学洞见把启蒙运动的理性时代末期与20世纪现代主义时代连接到了一起。</p></li><li><p>塞尚推论说，我们人类具有双眼视觉：我们有两只眼睛，而且我们的左右眼记录的并不是相同的视觉信息。并且在观察一个客观对象的时候，我们会四下活动，但是迄今为止的艺术几乎完全被创造成如同透过一个静止的单镜头进行观察的样子。这就是塞尚的推断，没能反映出我们的真实所见，通往现代主义的大门就此开启。</p><p>以《有苹果和桃子的静物》为例，这是塞尚静物作品中的经典之作，塞尚从两个不同的视角画了这只水罐：一个是平视，另一个是从上方俯视瓶颈。画小木桌也是如此，塞尚使桌面朝观众倾斜约 20 度，以显示更多的苹果和桃子，呈现出了不同角度的综合体。从多个角度观看物体并统一进行构图，两者的结合将导致画面的扁平化，通过将桌面向观众倾斜，塞尚牺牲了三维空间的视觉效果，以增加绘画所提供的视觉信息量。 互不混合的冷暖色调施于画布，蓝（冷）黄（暖）在色轮中正好截然相对，一旦用错，会画出非常刺眼的图像，但塞尚技巧高超，使得作品对比鲜明，这幅画完美展示了一个和谐的画面，色彩在其中扮演着和弦的角色。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1foshtxzcjkj30sg0mu1ky.jpg" alt=""> </p><p>《有苹果和桃子的静物》这件作品展示了塞尚如何永远地改变了艺术，他对传统视角的摒弃、致力于画面的总体设计以及双视角的应用，将艺术直接引用向了立体主义、未来主义、构成主义和马蒂斯的装饰主义，而塞尚并未就此止步，他对观察方式的孜孜探索使他有了另一发现，而这最终将把艺术带进革命性且极具争议的抽象艺术范畴。</p></li><li><p>像他的后印象派同伴一样，塞尚最终也是在印象派上陷入了僵局，修拉继续前行，因为他向往的是纪律和结构。梵高和高更决绝地离去，因为他们感到描绘客观现实这一要求束缚了自己。而塞尚却感到印象派客观地不够，在追求现实主义方面不严谨。他认为老大师绘画的严肃性和结构应该与印象派在室外直面描绘主题的主张结合起来，尽力将真实的生活真正再现于画布之上，这项任务特别适合他的性格——半保守半革命。</p><p>梵高通过变形这种手法来表达他对某种题材的感受，而塞尚通过线描和色彩来做到这一点，在《圣维克多山》中，并未按精确的透视法来画，而是将其拉近，给人以离山底只有几块田地之近的感受，但实际上却有大约十三公里，塞尚部分解决了如何准确反映视觉感受的问题，却仍不满意，当我们观察一个自然景观时，实际上看得不是细节，而是形状。塞尚开始把土地、建筑、树木、山峦甚至人物都缩减成一系列的几何图形，以此作为自己分析方法的基础，二十五年后这种方法导致的结果就是：完全抽象。隐士般的塞尚在艾克斯自我放逐，远离巴黎的先锋派，却对 20 世纪的艺术产生如此广泛的影响，出人意料的是，塞尚还没有就此罢手。他还需要再进一步，把“印象派转变为更坚实更持久的事物，就像博物馆里的艺术那样。”如此一来，简化风景的想法最终落实为一群群相互连接的形状，然后更进一步，引入一种近似于严格的网格系统的东西。抒情地来讲，“地平线的平行线提供了广度，而与地平线垂直的线条则给画面带来了深度”。在《圣维克多山》中，他用田地、铁路的高架屋顶搭建了一个由数条地平线的平行线组成的框架，为了制造纵深感，他在画面的左边加入了一颗树干，贯穿画面上下，但透视大大缩短。有一根树枝竟在树干的中间伸出来，塞尚利用树枝上的叶子来把远景和近景融合了起来，通过“视角转换”的技术将层层颜色重叠、整合，从而融合了时间与空间，他所追求的，是既要反映“自然之和谐”，同时又要真实反映我们观看事物和空间的方式，这既不是仅有一个固定的一个视角，也并不是在缺少知识储备的情况下所能做到的。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1foshwajvc2j30zj0q9kjn.jpg" alt=""></p><p>当开始尝试“以新的方式去接续”过去的艺术的时候，塞尚无意间微微推开了通向现代主义的大门。他那些类似网络的结构和将细节简化成几何图形的理念，可以从勒·柯布西耶的建筑、包豪斯棱角分明的设计和皮埃特·蒙特里安的艺术中体现。</p></li><li><p>塞尚死于 1906 年 10 月，享年六十七岁，此前一个月，他曾在信中写道：“我在路上奋斗了这么久，最终能够到达终点吗？”语气中充满极度的绝望和沮丧，同时也打上了这个男人的烙印，他对艺术的奉献是全身心的、毫不动摇的，他给自己设定了知识和技术上的挑战目标，而他感到自己从未实现过，但是在他坚定不移的努力下，他还是取得了比同辈人都大的成就。 </p><p>1907 年，巴黎秋季艺术沙龙举办了塞尚纪念展，世界各地的艺术家前来观看这位艾克斯主人毕生的作品，来者肃然起敬，深感震撼，他们惊讶地发现，为了推进自己的创作，塞尚是如何回溯到老大师身上的。这次展览举办之时，恰逢一群有才华的年轻艺术家开始从现代世界的浅薄中醒悟过来，他们开始考虑，假如回望得更远——回望到现代文明之前，他们能学到什么。</p></li></ul><h2 id="原始主义-1880-1930-野兽派-1905-1910：原始的呐喊"><a href="#原始主义-1880-1930-野兽派-1905-1910：原始的呐喊" class="headerlink" title="原始主义 1880-1930 野兽派 1905-1910：原始的呐喊"></a>原始主义 1880-1930 野兽派 1905-1910：原始的呐喊</h2><ul><li><p>原始主义贯穿了整个现代艺术，它指的是那些模仿或借用了古代原始文化所创造的手工制品、雕刻和图像的西方现代绘画与雕塑。这一称谓隐含帝国主义色彩， 开化的文明欧洲人充满优越感地创造了这个词。</p><p>生活于世纪之末巴黎的年轻艺术家认为，这些图腾雕刻所达到的质朴直率的境界是他们无法企及的，因为他们的原始激情早就被艺术学院磨得干干净净，他们认为“原始”艺术是从尚未受到物质主义西方文化玷污的灵魂中诞生的，这些灵魂可以直抵人内心如孩童般的自我，创造出天真且极其真实的作品。</p></li><li><p>将年轻一代引导到这条道路上，艺术家<strong>莫利斯·德·弗拉芒克</strong>（1876-1958）功不可没，他在巴黎郊外的咖啡馆看到了三个非洲面具，他从咖啡馆老板手里买走了面具，展示给了那些和他一样狂热的朋友。<strong>亨利·马蒂斯</strong>和<strong>奥德烈·德兰</strong>（1880-1954）被打动了，这三位艺术家从中领会到一种西方艺术里缺失的自由，之前的艺术训练教导他们追求理想化的美，而这些非洲手工制品则无意于此，甚至背道而驰，常常描绘畸形的事物。面具促使他们采用了一种新画法，即色彩和情感的表达要优于忠实的再现。</p><p>同年秋天，三位艺术家觉得，他们已经有了足够多的好作品，去参加 1905 年的秋季沙龙，颇具影响力的艺术评论家路易斯·沃克赛尔趣味保守，轻蔑地说这些绘画是野兽的作品。又一次，评论家的谴责不仅命名了一场新的艺术运动，而且成为了其发展的推动力。对于一个仍妥协于印象派和后印象派的艺术界而言，野兽派浓重的用色一定显得极其粗俗浮华，但其实马蒂斯和粗俗浮华根本就搭不上边。</p><p>他是三个孩子的父亲，为人认真，衣着朴素，仍像他当律师时那样行事，做过唯一一件“疯狂的事”就是违背父亲的意愿，弃法从艺。1905 年的秋季沙龙也正是马蒂斯的《戴帽子的妇人》引起了最大的风波，将盛行的特立独行之风提升到了新高度，用色如此自由散漫，看起来就好像是随意涂鸦而成。《戴帽子的妇人》最终被一个叫雷欧·斯坦因的美国侨民买下，他和他妹妹就是当时备受尊敬的<strong>斯坦因兄妹</strong>，他们的公寓成为了造访或居住在巴黎的艺术家、诗人、音乐家和哲学家的核心据点，他们通过购买的方式鼓励艺术家继续努力，在接下来的一年中又购买了马蒂斯另一幅有争议的作品《生之欢乐》（1905-1906），《生之欢乐》是典型的野兽派作品，创作了一幅充满享乐之愉悦的画面——做爱、音乐、舞蹈、日光浴、采花和休闲——在一片点缀着橙色和绿色树木的亮黄色沙滩上，这幅高度个人化的作品见证了，马蒂斯正进入他的全盛时期。画中形状对比所造成的和谐效果，以及构图的统一性，在绘画史上现有匹及者，碰巧的是，那些可以与他比肩的少数几位天才，有一位就在当时的巴黎。 </p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fosi13id7kj30m80u9e82.jpg" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fosi1oxcz9j30u80lsb2a.jpg" alt=""></p></li><li><p><strong>巴勃罗·毕加索</strong>（1881-1973）是为成名较早的年轻西班牙艺术家，1900 年的他尚为少年，第一次去巴黎就迅速崭露头角，到 1906 年，他已在这座城市立稳脚跟，成了一位先锋艺术家明星，是斯坦因兄妹公寓中的常客。不久前塞尚去世，“当今最伟大的艺术家”这个头衔处于空缺状态，马蒂斯和毕加索都意识到，两人将会有一场正面的战斗。</p><p>两位艺术家于斯坦因兄妹发展起立的友谊，促成了现代艺术史上最伟大的进步之一，因为马蒂斯手中把玩的一个非洲雕刻，毕加索前往巴黎民族志博物馆去看非洲面具藏品，艺术史上有许多号称“大爆炸”的时刻，这些时刻戏剧化地永远改变了绘画和雕塑的进程，在几个小时里，这位艺术家明白了自己为何是一名画家，为何是孤零零的一个人，在博物馆中，印第安人的玩偶，落满灰尘的人体模型，在那时，《亚维农的少女》就在心中埋下了种子。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fosi3xc3ejj30sg0the82.jpg" alt=""></p><p>正是《亚维农的少女》促使了立体主义的出现，后者转而又引领了未来主义、抽象主义，迄今为止，同时期的艺术家还认为它是有史以来影响最深远的一幅画。</p></li><li><p><strong>亨利·卢梭</strong>是个简单的人，没受过多少教育，总是一副无辜天真的样子，被人起了一个“关税员”的外号，因为他的工作是收税，他只是在四十多岁的时候开始把绘画当做周日下午的业余爱好，更要命的是，他真不是艺术家的类型，他就是一个普通的中年男人，无明显特征，在芸芸众生中过着乏味的生活。</p><p>1886年，卢梭决定参加独立沙龙的展览，乐观地希望以此作为一名真正艺术家的生涯的开端，但进展并不顺利，卢梭成了整个展览上的笑话，他的《狂欢节之夜》受到了可怕的抨击，人们评论说“我五岁的孩子都能这样”，这幅画算是这句话出现的早期例子，然而卢梭技巧和知识上的欠缺，反而促成了一种极其与众不同的风格，就像你在孩子图画本里见到的那种简单图案，但同时又具有日本木版画二维图像的明晰，这种惊人力量的结合，赋予他的绘画以冲击力和独特性。卢梭的朴实还有另外一个好处，就是他对批评不那么敏感，自从他开始后半生事业的那一刻起，他就相信自己一定会弄出点名堂，什么也劝阻不了他。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fosi56muv0j30m80tb1ky.jpg" alt=""></p><p>1905年，卢梭以作品《饿狮猛扑羚羊》参加秋季沙龙，就技巧而言，此画依然相当拙劣，但他风格化的图像里面有点什么东西吸引了这个西班牙人及其周围的圈子，那就是卢梭的画里流露出来的稚嫩的天真。对远古和神秘之物着迷的毕加索感到这位关税员的艺术已超越了对自然世界的描绘，而进入了超自然的领域。这位年轻艺术家怀疑卢梭有一条直达冥界的通道，他的天真使他直抵深埋于我们所有人的人性的核心，而教育使得大多数艺术家无法企及。毕加索偶然发现《一个女人的肖像》（1895）时的情形，更是加强了他的这种直觉。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fosi7ux1xjj31hc0zdnpi.jpg" alt=""></p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fosi7e0lmvj31kw2egx73.jpg" alt=""></p><p>毕加索曾谨慎地说：“他花了四年的功夫学着像拉斐尔那样画画，而学习像孩子那样画画却花了他一生”，从这个角度说，卢梭是他的老师。</p></li><li><p>这位关税员死于 1910 年，墓志铭被一位叫做<strong>康斯坦丁·布朗库西</strong>（1876-1957）的雕刻家刻在石头上，他也是卢梭之夜的出席者之一，与绝大多数人相比，他与卢梭的艺术和态度更相近。两人都是局外人，法国人卢梭从未被巴黎艺术界权威们完全接受，罗马西亚人布朗库西很受欢饮，但有意保持距离。两位艺术家都擅长将自己包裹在自我的神话里，卢梭喜欢谈一些子虚乌有的海外大冒险，而布朗库西把自己说成一个贫困潦倒的农名手艺人，经历了一次史诗般的艺术超生，从农舍走到了艺术界的心脏——巴黎。</p><p>高更早已去世，布朗库西接过“农民着装艺术家”的衣钵，穿木底鞋、工作服和白色罩衫，开始接受现代雕塑之父——奥古斯特·罗丹（1840-1917）的指导，罗丹著名的《吻》（1907-1908）的诸多成功因素之一，在于它的双重幻象，那一块大理石，既是两位年轻恋人优美的身体，又是他们拥吻时所坐的岩石。当布朗库西在创作自己的《吻》时，成功使用了相同的诀窍，并且抛弃铸模环节，直接在原料上雕刻。他相信这种做法会在艺术家、创作对象和观众建立更真诚的联系。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fosiej302uj30m80vd4qq.jpg" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fosif1lnf5j30m80tjngl.jpg" alt=""></p></li><li><p>2010 年，<strong>阿尔伯托·贾科梅蒂</strong>（1901-1966）的《行走的人》拍出了惊人的1.04亿美元，创下了当时艺术品拍卖的最高价格，有力证明了贾科梅蒂的表现主义雕塑作品所拥有的持久的生命力。这个高六英寸的任务骨瘦如柴、憔悴不堪，造型强调了垂直线条，正如塞尚在半个世纪前指出的那样，这会增加观众对空间深度的感受。贾科梅蒂在他艺术生涯的早期就搬到了巴黎，他也是在那里发现了布朗库西的雕塑，从而追随这位罗马尼亚人对非西方艺术的兴趣。</p><center><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fosig6nmr9j30e90n6jrs.jpg" alt=""></center></li><li><p>对原始事物抱有好奇，并随之产生的简化雕塑形态的愿望，并非只有生活在巴黎的艺术家才有，在英国，雕塑家<strong>芭芭拉·赫普沃斯</strong>（1903-1975）从小就痴迷于史前和原始时期，结识了同学<strong>亨利·摩尔</strong>（1898-1986），两人的友谊和共同的艺术视野，将对雕塑世界产生巨大的影响，他们去过巴黎，和毕加索、布朗库西和其让人建立了友好的联系，并开始将旅途中的想法融进作品之中，这种种影响共同引起了 20 世纪 30 年代早期的重大突破，开辟了雕塑艺术新局面，他们提出了在立体艺术品上打孔的概念。</p></li><li><p>毕加索、马蒂斯、卢梭、布朗库西、贾科梅蒂、摩尔以及许许多多的艺术家，都为部落和远古艺术而倾倒，被其无拘无束的直率和简单造型中蕴含的情感力量深深吸引，这些现代艺术家和那些与人类同样古老的故事从此紧紧地相连在一起，他们的作品回溯过去，也通向未来。</p></li></ul><h2 id="立体主义：另一种视角-1907-1914"><a href="#立体主义：另一种视角-1907-1914" class="headerlink" title="立体主义：另一种视角 1907-1914"></a>立体主义：另一种视角 1907-1914</h2><ul><li><p>作为最令人瞩目的、前途无量的今日艺术之星，毕加索的地位受到同行马蒂斯的威胁，在那位野兽派画家于 1906 年创作出《生之欢乐》后，这种潜在的担心变成了真真切切的忧虑，但他同时也为 1907 年举办的塞尚纪念展激动不已，使他决心要追随这位艾克斯大师，继续对透视和观看方式进行探索。毕加索在《亚维农的少女》中倾注了极大的心血，这幅基于塞尚观点而创作的作品，开启了立体主义之门，题中的亚维农是指一条以色情业闻名的巴塞罗那街道。为了和马蒂斯竞争，毕加索进一步推进塞尚的工作的同时，也从过往的作品中汲取灵感，他的话——<strong>“糟糕的艺术家复制作品，好的艺术家窃取灵感”</strong>，被人广泛引用。</p></li><li><p><strong>乔治·布拉克</strong>和毕加索一样，看过塞尚的展览之后大为震动，两位年轻艺术家建立了亲密而富有创造力的合作关系，这段始于 1908 年的合作关系，随着第一次世界大战的降临而结束。 </p></li><li><p>乔治·布拉克与毕加索合作一年之后创作了《小提琴与调色板》（1909），此时是立体主义的第一阶段，被人们称为分析立体主义（1908-1911）——该名字源于他们对表现对象及其所占空间近乎痴迷的分析，有史以来不再把画布假装是一扇窗户，而是被当做表现对象本身。布拉克将小提琴分解成不同的部分，再将它们重新组装，每个组装的部分描绘一个不同的观察视角，这样就可以同时展现所有角度，这种直接的表现不是相机或对以往艺术的模仿所能胜任的，而是一种描画和观看乐器的全新方法，为静止的对象注入了活力。</p><center><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fosnfjusq3j307p0goand.jpg" alt=""></center></li><li><p>这种观察世界的新视角是对近年来科技领域突破性大发展的反思和回应，1905 年，生于德国、居住在瑞士的年少成名的科学家阿尔伯特·爱因斯坦提出了相对论，这使得将事物拆分互相联系碎片的立体主义观点看起来完全合乎逻辑。 在实验室之外，人们为莱特兄弟全新的航空愿景感到兴奋，再加上西格蒙德·弗洛伊德饱受争议的潜意识心理分析，在此之前或之后，都没有这样一起时期，文明所依赖的众多真理受到了质疑或被证明为谬误。</p><p>彻底的抽象是立体主义无法避免的的走向之一，几年后，俄国的至上主义和构成主义，以及荷兰的风格派艺术家，创作出只由圆形、三角形、球体和方形构成的绘画和雕塑，他们完全无意，描绘已知的世界，然而这并不是立体主义的目的，毕加索曾说，他一生从未画过一张抽象画，他和布拉克选择如此生活化的主题——烟斗、桌子、乐器、瓶子——的部分原因就是为了让观者能更容易地从复杂建构物中辨认出不不同的组成部分。</p><p>布拉克的壁纸和毕加索的油布或许是微不足道的日常材料，但就艺术史而言，这是观念艺术的开端，它们就像炸药，塞尚推开了通向现代主义的大门，而这两位年轻的艺术家把门框给炸飞了，分析立体主义向综合立体主义转变，后者是用于正式称呼毕加索和布拉克所引入的“拼贴”手法，意味粘贴或胶合，这两位伟大的艺术先锋创造了拼贴画。</p><p>在接下来的两年里，他们像一对爵士乐组合，用形形色色的材料即兴创作，借用彼此的想法。他们那些混合各种介质的发明创造，使卑微材料与高贵的艺术作品融合在一起。马塞尔·杜尚，曾经的巴黎立体主义者，创作了《泉》（1917），一个改造过的小便池。20 世纪的大量的艺术和设计中，我们都可以发现它的身影，从塞尚发展而来的棱角分明、精简、强调空间意识的立体主义美学，经过布拉克和毕加索之手，直接发展为棱角分明、精简、强调空间意识的现代主义美学。勒·柯布西耶优雅而朴素的建筑，1920 年代的装饰风格，可可·香奈儿简洁的设计，都应该归功于这两位年轻艺术家。</p></li><li><p>立体主义的遗产或许千秋万代，但这个运动本身持续了不到十年，美好的年代即将被第一次世界大战所取代。面对这两位年轻艺术家的成就，人们只有惊叹，这对下一个艺术运动来说并不适用，未来主义有着迥然不同的议题和更加黑暗的遗产。</p></li></ul><h2 id="未来主义：快进-1900-1919"><a href="#未来主义：快进-1900-1919" class="headerlink" title="未来主义：快进 1900-1919"></a>未来主义：快进 1900-1919</h2><ul><li><p>1905—1917 这十二年，见证了现代艺术运动的兴起，那时仍默默无闻的团体纷纷标榜自己是新的艺术先驱，它们来自法国（野兽派、立体主义、俄耳甫斯主义）、德国（桥社、青骑士）、俄罗斯（辐射主义）和英国（旋涡主义）。流派之间相互影响，一群群诗人、艺术家、哲学家、小说家在快速现代化的城市里聚会、畅饮、交流思想，上个世纪的疾病和城市的肮脏已成为历史，响彻欧洲大地的呼喊是：辞旧迎新。至少，<strong>菲利波·托马索·马里内蒂</strong>（1876-1944）一位富有煽动性的意大利诗人和小说家的确是这么说这么写的。二十岁出头，他在意大利的米兰定居下来，随即认为这个国家的真正遗憾是没有在现代艺术上争得一席，他提出一个崭新的概念——未来主义，从一开始就与政治挂钩，并且叫嚣着要改变世界，通过法国著名报纸《费加罗报》向全世界展示了未来主义的宣言。借助新闻报道，精心策划的展览，富有刺激性的演讲，公开论战，宣言，公告，计划书和其他效果显著的宣传方式，画家或画家群体被拉入其中。意大利艺术家<strong>翁贝托·薄丘尼</strong>（1882-1916）、卡拉·卡拉（1881-1966）、吉诺·塞维里尼（1883-1966）、贾科莫·巴拉（1871-1958）都被收入麾下。</p><p>虽然未来主义者称自己的绘画并非“固定在某一时刻”，像布拉克和毕加索冷静捕捉到静止的内在世界那样，但他们的作品确实抄袭了从多角度观察单个事物这一概念，实际上，未来主义是加速了的立体主义。未来主义的雕塑和绘画在很大程度上要归功于立体主义在技法和构图上的创新，两者都把时间和空间破坏，然后融进一个形象里，采用了相似的重叠技巧和断裂的平面来创造效果，不过立体主义者认为他们艺术的主题就是艺术，而未来主义者则期望激起真真切切的情感反应，他们想要发出政治申明，并在所描绘的真实世界的物体之间造成一种动态的张力。 </p></li><li><p>实际上，两个阵营——立体主义和未来主义——里的艺术家一直在互相观察、学习、影响。法国立体主义画家<strong>罗伯特·德劳内</strong>（1885-1941）就是其中之一，他一直在观察他的意大利同行的成果，他的《加迪夫队》（1912-1913）显示了很多立体主义和未来主义的特征。为了不在米兰人面前丢脸，<strong>阿波利奈尔</strong>索性为立体主义——未来主义这个混血儿造出了一个新词，他判定，德劳内的《加迪夫队》是一个新艺术运动的开端，命名为俄耳甫斯主义（俄耳甫斯用触及灵魂的音乐让众神陶醉）</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fosnki2ffzj30ih0p0b29.jpg" alt=""></p></li><li><p>未来主义者的秀场从巴黎走向了全欧洲，全世界都开始骚动，未来主义者打破了巴黎对现代艺术发展的牢固控制，从 1912 年开始，世界上各座城市都谱写着艺术史的新篇章，他们对立体——未来主义作出各自的回应，彼此间平起平坐。</p><p>在英国，艺术家及作家<strong>温德姆·刘易斯</strong>（1882-1957）领导了一个新艺术运动，被称为“漩涡主义” ，第一次世界大战的爆发致使这一运动尚未得到充分的发展就消亡了，其中最具震撼力的作品是<strong>雅各·爱泼斯坦</strong>（1880-1959）的《凿岩机》（1913-1915）。</p><center><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fosnl3sdl9j30cd0gnnac.jpg" alt=""></center></li><li><p>马里内蒂的未来主义继续大步向前，它不停地宣告、鼓动和战斗，全欧洲的不满民众非常乐意听到“辞旧迎新”这样一个未来主义式的口号，共产主义即将到来，法西斯也是。在大多数人眼里，艺术总是左翼自由主义者的游戏，然而， 菲利波·马里内蒂的行为却反转了这种观念，1919 年他参与撰写了意大利的法西斯宣言，这距他发表《未来主义宣言》正好十年。</p><p>若说未来主义直接导向了法西斯主义，未免言过其实，但是如果无视艺术对于政治惊人的影响，就是在回避这些尴尬的事实了，未来主义将永远不可避免地于法西斯主义联系到一起。 </p></li></ul><h2 id="康定斯基-俄耳甫斯主义-青骑士：音乐之声-1910-1914"><a href="#康定斯基-俄耳甫斯主义-青骑士：音乐之声-1910-1914" class="headerlink" title="康定斯基/俄耳甫斯主义/青骑士：音乐之声 1910-1914"></a>康定斯基/俄耳甫斯主义/青骑士：音乐之声 1910-1914</h2><ul><li><p>当爱德华·马奈于 19 世纪中期从他的画中，比如《喝苦艾酒的人》（1859），去除形象化的细节时，骑士已经开启了抽象艺术之门，随后，每一代艺术家，去掉更多的视觉信息以捕获富有情调的光线（印象派），强调色彩的情感特质（野兽派），或从多重角度观察某一题材（立体主义）。回顾历史，这一不断去除的过程最终将不可避免的导致所有细节的消失和抽象艺术的来临，所有这一切都打着“艺术进步”的旗号，1910 年，距他们开始这场重新为艺术和艺术家定位的革命五十年之后，他们终于与传统决裂了。</p></li><li><p><strong>弗朗齐歇克·库普卡</strong>（1871-1957）是巴黎立体-未来主义运动中的一员，阿波利奈尔称这一运动为俄耳甫斯主义，《第一步》（约1910）是他在抽象艺术领域最大胆的实验之一，不描述任何事情，完全抽象，是对我们与外太空及宇宙关系所进行的一次探究。两年后，因创立俄耳甫斯主义的艺术家<strong>罗伯特·德劳内</strong>以一幅极具影响力的作品迈入了抽象艺术的领域——《共时的圆盘》。和修拉一样，德劳内也对色彩理论着迷，自从得出了“现实毁坏了色彩秩序”的结论后，他就将颜色作为绘画的唯一主题，他试图创作出一副激荡着“和声”与“音色”的作品，它不啻一段音乐，这也是俄耳甫斯主义的目的，它隐含在于这一运动同名的希腊诗人和音乐家俄耳甫斯身上，艺术与音乐紧密相连，这一看法在先锋艺术家当中十分流行。这一观察有助于理解这些抽象艺术先驱的作品，那些五彩斑斓的涂抹并不是为了将装饰品打扮成艺术品来愚弄大众，如同音乐一样，当不伴随演唱或歌词时，是一种完全抽象的艺术形式，只不过艺术家是用颜色和形状来完成他们的排布。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fosnnnntajj31jk0z0x6q.jpg" alt=""></p><center><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fosno6j44oj306o06mtck.jpg" alt=""></center></li><li><p>杰出的 19 世纪德国浪漫主义作曲家<strong>理查德·瓦格纳</strong>早在半个世纪前就看到了将音乐和艺术融合的可能性，他的愿景是创造出“Gesamtkunstwerk”，意味“总体艺术品”，这一想法旨在将不同的艺术形式统一起来，以成就一个崇高而创新的艺术整体，可以改变生活，为社会做出有益贡献。</p><p>这位作曲家实现“总体艺术品”的雄心壮志一定以某种方式进入了他作品的灵魂，因为一位年轻的俄国法学教授正是在莫斯科大剧院观看他的歌剧《罗恩格林》时发现自己也抱有同样的想法。三十岁的<strong>瓦西里·康定斯基</strong>辞掉了莫斯科大学法学院的讲席，前往慕尼黑——欧洲艺术和教育的中心，在通往绝对抽象的道路上，在康定斯基的整个生涯中，音乐对他的艺术和生活的影响如影随形，他很快了解了印象派、后印象派和野兽派的绘画方法，迅速在德国先锋艺术中站稳了脚跟。与此同时，库普卡和德劳内正在巴黎，踏上类似的抽象之路，去追寻俄耳甫斯主义。20 世纪早期的先锋艺术已从法国扩展至德国、意大利、俄国、荷兰和英国，但毕竟只有一小群艺术家参与其中，许多人互相认识，生于莫斯科的康定斯基以慕尼黑为基地，但也在巴黎待过，正是在那结识了格特鲁德·斯坦因，并了解了她收集的马蒂斯和毕加索的作品。同时，德劳内也认识了富有天分的乌克兰艺术家<strong>索尼娅·泰克</strong>（1885-1979），并娶她为妻。1911 年康定斯基到慕尼黑去听饱受争议的维也纳作曲家阿诺德·勋伯格的无调性音乐，康定斯基被深深打动了，当晚就创作了《印象3》作为回应，此时的艺术家与绝对抽象之间的距离非常接近了，而勋伯格则促成了这一突破，康定斯基立即写信给这位音乐家，并提出“绘画可以发展处和音乐一样的活力”。勋伯格则积极回应，由此开始了两位伟大艺术家之间一生的友谊。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fosnsuw6k6j30kq0g1avr.jpg" alt=""></p><p>1911 年对康定斯基的生活和他正从事的创作而言都是不平凡的一年，首先是勋伯格的音乐会，然后是开创性的《带圆的画》，再接下来是著作的出版，不过，更精彩的还在后面，这位俄国艺术家和他那些慕尼黑先锋艺术界的德国同行闹翻了，他开始建立一个名为“青骑士”的跨领域的共同体。“青骑士”向罗伯特·德劳内和阿诺德·勋伯格发出邀请，两人都接受了，“青骑士”中的“青”对团队成员来说有重要意义，他们相信这个颜色充满了独一无二的精神特质。这些艺术家都喜欢马，他们将这种动物的原是天性与自己冒险、自由、依照本能行动、抗拒现代商业社会的艺术目标联系在一起。《作曲7》（1913）是他《作曲系列》和整个生涯的顶峰。康定斯基断然拒绝提供任何可指向已知事物的提示，挫败了人们尝试解读图像的天然倾向，使得对此画的研究既令人兴奋，又令人精疲力竭。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fosnt7jt08j30h00jp7wh.jpg" alt=""></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fosnu663bbj30tr0jsb2a.jpg" alt=""> </p></li><li><p>生于瑞士的德国艺术家<strong>保罗·克利</strong>（1879-1940）观看了这幅作品，并对康定斯基的精湛技艺表示赞赏，他也曾在慕尼黑学习，尝试过德国表现主义和象征主义，相信艺术可以帮助人类建立与环境和精神自我的联系，而且对音乐有深厚的感情。康定斯基邀请这位比自己年轻的艺术家加入青骑士，正是这一举动造就了他的成功。</p></li><li><p>伴随着耳边回荡的音乐，库普卡、德劳内、康定斯基和克利一同向抽象进发，他们创作的作品切断了与一切世界的联系，以唤醒观众的感官和灵魂，冲破现实的枷锁，为达到这一目的，他们以色彩和音乐为自己艺术的主题，显然这已是抽象艺术的终点，还能去哪儿？  </p></li></ul><h2 id="至上主义-构成主义：俄国人-1915-1925"><a href="#至上主义-构成主义：俄国人-1915-1925" class="headerlink" title="至上主义/构成主义：俄国人 1915-1925"></a>至上主义/构成主义：俄国人 1915-1925</h2><ul><li><p>其实还存在另一种传统以外的的选择，它不从音乐的角度来理解抽象艺术，它要彻底抛弃对象这一概念，要达到此目的，需要从艺术中去除叙事性的因素，即使是康定斯基和德劳内的抽象艺术，也给观众提供和了叙述的某些方面，要么是以音乐象征和圣经寓言的形式（康），要么是某个像色轮一样实在的出发点（德）。要想纯粹专注于一件艺术品的技巧性和材料性，以及它与生活、宇宙和任何事物的关系，就有必要对艺术的角色和观众的期待重新进行一次综合性的评判，这意味着要与艺术的那种可以追溯到史前岩画的隐喻传统决裂，而这一决裂要在一系列特殊的条件才能发生。</p><p>灾难与动荡也往往孕育出伟大的艺术，无怪乎现代艺术诞生于法国，这一次与传统的决裂，将要发生在一个同样居住着先锋派知识分子的国度里，叛逆的领袖在国内引起阵阵骚乱，把这些知识分子圈入国内的动荡中。</p><p>当托洛茨基、列宁和斯大林谋划着建立一种迄今为止从未被尝试和检验过的平等主义的政府形式之时，这个国家的先锋艺术家也在思索着创造出一种不曾想象过的艺术类型——非客观艺术。就世界影响力和生命力而言，俄国艺术家要比政治家更胜一筹，苏联陷入冷战，最终解体，然而非客观艺术催生了 20 世纪的现代设计，并为五十年之后的美国极简主义奠定了基础。</p></li><li><p>到了 1913 年，激进的俄国艺术家已经赶上了他们的西欧对手，现在是立体未来主义的拥护者，开始质疑他们的西方朋友，他们推出了一部难以理解的未来主义主题歌剧《征服太阳》，随之开始了艺术上的征程。作曲家邀请了<strong>卡济米尔·马列维奇</strong>来为歌剧设计布景和服装，马列维奇创造出一套立体未来主义风格的豪华之作，但在歌剧接近尾声时的一处场景除外，这是一块普通的白色幕布，马列维奇在上面画了一个黑色的正方形，他的本意是将其作为整个舞台布景的一部分而非单独的艺术作品，但事实结果并非如此。</p><p>一块白布上的简单黑色正方形，将成为艺术史上一个令人震撼的伟大时刻，可以和几何透视、塞尚的双目视觉探索和杜尚的小便池相提并论。这是一种真正原创的艺术表达风格，他将其称为至上主义，它是一种纯粹抽象的形式，一种彻底非描述性的绘画风格，他将所有通向已知世界的视觉线索都丢掉了，这样观众就可以享受“非客观的体验，纯粹感觉的至高无上”。</p><p>马列维奇以他惯有的方式，通过创作一幅体现这一艺术新方向的“宣言”绘画，来开始新的艺术征程，受自己在《征服太阳》中舞台设计的启发，他选择了一张 2.5 平方英尺的画布，将整张都涂成白色，然后在中间画了一个巨大的黑色正方形，命名为《黑色正方形》（1915）。他认为这张双色画象征着宇宙中的地球，经历着光明与黑暗、生命与死亡，而且，和所有至上主义绘画一样，这张作品没有画框，因为这样受边界的束缚。相反，白色的背景融入了挂画的白墙，给人以无限的力量。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fosnyny6bgj30sg0skhdt.jpg" alt=""></p><p>当人们说“那看起来很酷”的时候，通常都在指某个受了马列维奇抽象艺术影响的设计师的作品，汤姆·福特的“看”系列，铂傲的产品、工厂唱片公司的封面、伦敦地铁标志、巴西利亚、无边界泳池，它们都有相同的蓝本，那就是至上主义的几何抽象艺术，去除芜杂，简化形状，精简颜色，专注于形式的纯洁性，而简约的外表其实是智慧、深思、现代性和精密性的象征。</p></li><li><p>马列维奇 1913-1915 年间的作品展览后来成了一个传奇，“最后的未来主义展览：从 0 到 10。”这是俄国实验艺术家向全世界发出的信号，宣告意大利未来主义的终结。和马列维奇一起参加展览的还有他的乌克兰同胞<strong>弗拉基米尔·塔特林</strong>（1885-1953），两人都是俄国先锋艺术中备受尊敬的人物，共同带领创作走向非客观艺术，本可能成为东欧的布拉克和毕加索，但是巨大的分歧却造成了彼此间白热化的争论和巨大的厌恶。</p><p>塔特林的艺术里没有那种超凡脱俗的做派，一就是一，二就是二，以一种和建筑家没什么两样的路径进入艺术，塔特林的兴趣在于他所使用的材料的物理特性以及它们的组合方式，两人的非客观艺术有许多共同的关注点：空间中的物体，违抗重力规则，质地，重量，张力，格调与平衡。</p><p>这次展览将马列维奇的至上主义和塔特林的构成主义推向了世界，尽管要到 1921 年《结构主义宣言》发表之时，塔特林领导的这一运动才被正是命名和开始，其实，从 1917 年左右马列维奇恶意贬称其为“构成艺术”起，构成主义就开始广为流传。</p><p>处在一个现代艺术中少见的联盟关系里，这些俄国艺术家并没有反对当权派，而是全新全意地支持他们，对于布尔什维克来说，想要推广他们新的生活方式，还有什么比拥抱这个国家最激进的艺术家还要好的方式呢？构成主义者从此将先锋艺术与左派联系到了一起。</p></li><li><p>年轻的<strong>诶尔·利西茨基</strong>（1890-1941）沉浸在俄国革命后的狂热中，在自己的艺术道路上不断成长，国家陷入内战，反布尔什维克的白军试图驱逐列宁的社会主义政权，利西茨基运用了几何图形、重叠平面、以及至上主义风格的黑、白、红色。《以红楔攻打白军》成为了有史以来最具偶像型的海报之一，利西茨基的图像和风格随后影响了众多设计师和一些流行音乐团体。</p><center><img src="https://ws4.sinaimg.cn/large/006tNc79gy1foso1b6s2cj30fq0cgahn.jpg" alt=""></center></li><li><p>利西茨基海报的影响力和不朽的遗产显示了非客观艺术的力量，它穿透了现代生活的喧嚣，描述更深刻，意义更为深远的东西。那些仅由基色修饰的硬邦邦的形状虽然简单，却带有一种磁性的、吸引人的力量，这关乎平衡和光学、张力和质地，不过它更多地关乎无意识，这是一种我们喜欢但不知为何喜欢的艺术。马列维奇、塔特林、罗琴科、波波娃和利西茨基是出色预言家，是最早的纯粹抽象艺术的先锋。</p><p>不过他们并不不孤单…</p></li></ul><h2 id="新造型主义：网格-1917-1931"><a href="#新造型主义：网格-1917-1931" class="headerlink" title="新造型主义：网格 1917-1931"></a>新造型主义：网格 1917-1931</h2><ul><li><p>艺术家选择以视觉语言来交流，或许因为他们觉得用文字或谈话难以组织起自己的思想。不过这里有个悖论，在我的经验里，正是那些抽象艺术家——那些将生命用于剥离细节以揭示普遍真理的人——最爱用辞藻华丽而含糊不清的语言来描述自己的作品，马列维奇大谈宇宙飞船和宇宙事件，康定斯基则谈论聆听绘画之声，即使是务实的塔特林，也对作品体积的“物质性”和三维空间带来的“张力”这些概念反复申说。但就解释自己的抽象艺术而言，最佳“迷惑奖”则非荷兰画家<strong>皮埃特·蒙德里安</strong>（1872-1944）莫属。</p><p>这个因“格子”画而出名的人，曾以绕来绕去的叙述手法来解释自己的作品，蒙德里安的动力来自来自于血腥的第一次世界大战，他在战争肆掠的 1914-1918 年间形成了一种关于一种新艺术——新造型主义——的想法，他的目的是为了帮助整个社会以一种和谐优先于个性的全新姿态重新开始。他总结道，为了达到这一结果，必须将艺术减至最基本的元素：色彩、形状、线条和空间，颜色仅限于三原色，有正方形和长方形两种集合形状供选择，只能使用黑色的水平线或垂直线，绝对没有立体感，通过和谐地平衡宇宙间所有对立的力量，就能找到生命的意义。</p><p>《构成C（第 3 号），红黄蓝》（1935）是典型的蒙德里安作品，平衡、张力、平等就是蒙德里安所有的创作内容，他的构图总是不对称的，蒙德里安说：“新造型主义代表平等，因为…各个部分之间虽然存在不同，它却能使每一部分都拥有像其他部分一样的价值”。这是一个有启发性的评论，它突出了蒙德里安的新造型艺术和康定斯基、马列维奇、塔特林的抽象艺术之间的差异，在这位艺术家的生涯中，个体元素从不混用，它们永远自足，并且没有重叠的平面或色调的过度，蒙德里安在定义一种新的社会秩序。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1foso314cerj30m80mc1cd.jpg" alt=""></p></li><li><p>他的事业不断演进，在这个节点上，傲慢的蒙德里安遇到了一位热情奔放的荷兰艺术家、作家、设计师和赞助人<strong>特奥·凡·杜斯伯格</strong>（1883-1931），1917 年，他们共同创造了一份杂志，命名为“De Stjil”，意为“风格”。和之前的现代艺术运动不同，风格派从一开始就雄心勃勃地向全球进发，运动发起者在 1918 年以四种语言发表了他们的宣言，开启战后新生活的愿望激励着他们，创作出“促进生活、艺术和文化的国际性统一”。</p><p>风格派是围绕蒙德里安的新造型主义三原色网格而建立起来的，运动前景有点类似乐高积木，所有参与者都可以使用这套原件，并适用于从建筑到产品设计的各种艺术形式。唯一真正重要的是创作出在色彩、空间、线条和形式的关系间找到统一的作品。</p></li><li><p>这一点被风格派的早期参与者、荷兰家具木工及建筑师<strong>赫里特·里特费尔德</strong>（1888-1964）所证实。美国人弗兰克·劳埃德·赖特棱角分明的建筑，苏格兰艺术与工艺运动设计师查尔斯·雷尼·麦金托什，里特费尔德当时从上述这些设计师中汲取养分，活跃于当代设计的最前沿。正是麦金托什著名的“梯形背靠椅”（1903）激发了里特费尔德的灵感，不过，里特费尔德的“扶手椅”（1918）更简洁，五年后，里特费尔德已沉浸在风格派美学当中，但这一次他将蒙德里安新造型主义的原色和黑色线条也被包含了进去，“红蓝椅”（1923）看起来就像三维版的蒙德里安绘画。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1foso6t9ma3j30k60o6nbp.jpg" alt=""></p></li><li><p>蒙德里安美学图景的力量一直影响着建筑和设计师，他的艺术原则是一种“少即是多”的哲学。在经过几次和凡·杜斯伯格的争吵之后，这位新造型主义的奠基者于 1925 年退出了风格派运动，无论如何，凡·杜斯伯格已做好改变的准备，他周游欧洲，传播风格派的福音，他将蓄意创作的非客观艺术，包括风格派、构成主义和至上主义，定义为“理性抽象”，反之，康定斯基更加象征性的作品是“冲动抽象”（关于抽象表现艺术的两种不同模式在 1950 年代也有类似的划分：“行动绘画”为本能的，“色域绘画”是预先构想的）。</p><p>凡·杜斯伯格精炼的评判是艺术史上一个非凡十年的最终成果，全欧洲的艺术家殊途同归：抽象，创造并定义一个崭新的、更好的世界，这一相似的目标激励着他们。在 20 世纪进入第三个十年的时候，这些艺术家中有许多人将聚集在德国魏玛，成为<strong>沃尔特·格罗佩斯</strong>充满传奇色彩的包豪斯的组成部分。</p><p>在两次世界大战的这一刻，乐观和冒险的气氛飘荡与德国乡村的这片土地上，艺术家、建筑家和设计师们在此共同努力，力求为整个世界创造出一种统一的视觉“速记”。</p></li></ul><h2 id="包豪斯：校园重聚-1919-1933"><a href="#包豪斯：校园重聚-1919-1933" class="headerlink" title="包豪斯：校园重聚 1919-1933"></a>包豪斯：校园重聚 1919-1933</h2><ul><li><p>19 世纪晚期，德国和英国是欧洲的两大工业力量，德国领导人将羡慕的目光投向英国，派遣一名叫<strong>赫尔曼·穆特休斯</strong>（1861-1927）的官员前往英国打探消息，不久便发现英国资本主义蓬勃发展的魔法要素就是刚刚去世的设计师<strong>威廉·莫里斯</strong>（1834-1896），他是艺术与工艺运动的创始者，也是一位公开的社会主义者。</p><p>莫里斯于 1861 年创立了自己的同名公司，希望发掘艺术的价值，使艺术的价值观念重新运用到手工艺品。这种做法的灵感来源于 19 世纪英国艺术史家和左翼知识分子<strong>约翰·拉斯金</strong>，拉斯金控诉资本主义制造分裂的本质和利润至上的冲动，公开宣布对现代文明的憎恨。</p><p>莫里斯和拉斯金相信，过往对今日具有丰富的启示，比如基于中世纪手工行业的培训系统，一个人从学徒开始做起直至成为手艺大师，莫里斯相信美和思想的民主化，为了所有人的艺术。</p><p>穆特休斯先生回国后系统阐述了自己对于英国艺术与工艺运动的看法，他思考，如果将莫里斯的理念以工业规模来应用，将会怎样？1907 年，德国工艺联盟成立，这是他们以莫里斯的理想为基础所做的一次大胆尝试，一个由艺术届和商业届重要代表组成的委员会由此诞生。</p><p>这些人中，有以柏林为主要活动基地的建筑家<strong>彼得·贝伦斯</strong>（1868-1940），贝伦斯出任德国通用电气公司的艺术顾问，他也是世界上第一个艺术顾问，他常说，他的工作不应该被视为点缀、而是要把产品的内在性格表现出来，这个观点很吸引人，但并非原创，美国建筑家<strong>路易斯·沙利文</strong>在《从艺术角度看高楼大厦》里曾表述过类似的观点，他格外关心摩天大楼对城市居民的社会影响和情感影响，这使得他创造出了时下著名的说法“形式服从功能”。</p><p>“阿德勒&amp;沙利文”建筑师事务所设计建造了温莱特大厦，这是全世界最早的高层大楼之一，它体现了沙利文的设计哲学，贝伦斯在设计德国通用电气公司涡轮机工长时也遵循了类似的原则。贝伦斯名声渐隆，吸引着建筑界最优秀的年轻思想者，这些人的名单就像是一次现代建筑巨人的点名，密斯·凡德罗和勒·柯布西耶都为贝伦斯工作过，还有阿道夫·梅耶，他与<strong>沃尔特·格罗佩斯</strong>（1883-1969）共同创建了一家新公司，而后者也是贝伦斯的弟子，并将成为世界上最著名艺术学校的创办人。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fosog4biicj30m80owhdt.jpg" alt=""></p></li><li><p>一战来了，沃尔特·格罗佩斯应征入伍，他亲眼目睹了战争的破坏力，并感到厌恶，这段经历迫使他去做点什么，德国新时代的曙光点燃了他的热情，即 1919-1933 的魏玛共和国，他想要创立一座新型艺术学院，以求建立一个更加文明、更少自私的社会，这将是一所扮演社会改良者角色的艺术与设计学校，命名为“魏玛包豪斯国立学校”。包豪斯诞生于 1919 年，包豪斯在德语中是“房屋建造”的意思。格罗佩斯宣布它将成为一所“运用现代理念的艺术教育重镇”，他拒绝德国工艺同盟那套工业化大规模生产的政策，而是按照莫里斯那套以行会基础的中世纪学徒模式，为学生设计了教育发展结构。</p><p>让人惊叹的是，包豪斯只存在了十四年，更令人惊讶的是，它所代表的朴素、节制、优雅的设计和这所机构创始时所提倡的创造性精神完全不同，此时的它随处可见理想主义的学生和导师，早期这里更像是一个嬉皮士社区，而非后来那所功能设计方面的专业化机构。这一点可在包豪斯第一份计划书上的图案看出，这是一副由<strong>莱昂内尔·法宁格</strong>（1871-1965）创作的木板画，描绘了一座被参错的光束包围的三塔尖哥特式教堂，这是一幅充满象征意味的图画，在格罗佩斯的构想中，包豪斯就是一座大教堂，将激发这个萧条乏味的世界的能量。</p><p>包豪斯的学生生涯是从为期六个月的预备课程开始的，课程由一位瑞士艺术家和理论家<strong>约翰·伊登</strong>（1888-1967）制定和负责，伊登和包豪斯最初回归自然的工艺信条相一致，学校里的整体氛围是一种反功利主义，带有德国表现主义的哥特式精神色彩，这不足为奇，约翰·伊登和莱昂内尔·法宁格都来自德国战前就成立的表现主义派学校。</p><p>德国表现主义中的畸形形象、神秘精神、自由意志主义和哥特特质都扎根于包豪斯最初的风貌中，因此很多年后，当瓦西里·康定斯基和保罗·克利来到包豪斯接受教职时，立刻觉得如鱼得水。</p></li><li><p>新的共和国四分五裂，格罗佩斯决定感到了压力，他要证明包豪斯的价值，在学校内部，格罗佩斯喊除了“艺术与科技，全新的统一”的口号，为了取代伊登，格罗佩斯决定不再聘用带有德国表现主义背景的导师，而是选择了一位具有构成主义思想的匈牙利艺术家——<strong>拉斯洛·莫霍利-纳吉</strong>（1895-1946），并与<strong>约瑟夫·亚伯斯</strong>（1888-1976）共同教授伊登的预备课程。</p><p>亚伯斯和莫霍利-纳吉将包豪斯变成现代主义的源泉，今天的包豪斯正是因此得名，他们的事业得到了风格派杜斯伯格的帮助，他的教学是伊登的对立面，纪律和精准是风格派的游戏规则，以最少的工具，产生最大的影响，少即是多。</p><p>至此，格罗佩斯已将抽象艺术各个流派的代表人物聚集到了魏玛，“青骑士”的康定斯基、克利和法宁格，风格派与新造型主义的杜斯伯格，以及拥护俄国非客观主义的亚伯斯和莫霍利-纳吉，这个又小又穷的机构吸引了一群具有开创性的艺术天才，正像是文艺复兴时期的佛罗伦萨和十九世纪末的巴黎。</p></li><li><p>包豪斯的生活又一次回到了正规，然后又一次被外界毁掉，德国拖欠了战争赔款，恶性通货膨胀和大面积失业接踵而来，包豪斯得到的经费大幅缩减，包豪斯在魏玛的日子结束了，但是转机也随之而来，美国借给德国政府足够的资金。不久后，包豪斯又将在魏玛以北的德绍开业。</p><p>为了迎接师生们的到来，沃尔特·格罗佩斯设计出了现代建筑史上最伟大的作品之一：一个真正的包豪斯。一个包含作坊、学生宿舍、剧院、公共空间和导师住所的综合体。1928 年，格罗佩斯辞职，前往柏林追求他的建筑事业，推荐了<strong>路德维希·密斯·凡德罗</strong>（1886-1969），一位曾经共事过的德国先锋建筑家。凡德罗欣然接受，1929 年巴塞罗那世界博览会德国馆的面世，巩固了他作为现代建筑杰出实践者的声誉，德国馆是所有抽象艺术运动在建筑领域的集大成者。</p></li><li><p>1933 年，当希特勒的政治地位稳固之后，强行关闭了包豪斯，并且举办了“Entartete Kunst”（堕落艺术）展，命令自己的党羽彻底搜查全国的把博物馆，移除一切 1910 年以后创作的现代艺术品，以混乱无序的方式陈列，并配以讥讽的文字，以鼓励民众嘲笑“堕落艺术”。</p><p>二战即将来临，沃尔特·格罗佩斯、路德维希·密斯·凡德罗、拉斯洛·莫霍利-纳吉、约瑟夫·亚伯斯、马赛尔、布劳耶、莱昂内尔·法宁格、皮埃特·蒙德里安将一路西行，前往自由之地：美国。</p></li></ul><h2 id="达达主义：混乱的秩序-1916-1923"><a href="#达达主义：混乱的秩序-1916-1923" class="headerlink" title="达达主义：混乱的秩序 1916-1923"></a>达达主义：混乱的秩序 1916-1923</h2><ul><li><p>一位拒服兵役的德国年轻作家<strong>雨果·鲍尔</strong>（1886-1927）在一战期间逃往中立的瑞士，为了给“独立于战争和民族主义之外的人”提供“为其理想而生活”的空间，鲍尔开了一家艺术俱乐部。另一位叫做<strong>特里斯坦·查拉</strong>（1896-1963）的罗马尼亚诗人和鲍尔成为了朋友，一个“正负相吸”的例子，鲍尔安静而具有颠覆性，查拉喧闹而倾向虚无主义，他们两人将引领一次无政府主义的艺术运动，催生了垮掉的一代，赋予朋克灵感，并成为观念艺术的基础。 </p><p>他们把自己宣传为艺术少年犯，反对一切：反权威，反社会，反宗教，特别是反艺术，他们否定且鄙视现代艺术，比如未来主义，虽然他们自身也是由此发展而来。达达主义必须处于艺术世界中，它所传达的信息才能产生影响，那些反叛的达达主义者对这样的游戏规则心知肚明。</p></li><li><p>艺术家<strong>让·阿尔普</strong>（1886-1966），达达主义运动的发起人之一，他的达达主义创作起点和毕加索和布拉克的拼贴画相关，《根据随机法则排布的正方形的拼贴画》（1916-1917）正是这种技法的早期实例。当战争结束，阿尔普在回程途中穿过欧洲，在路上遇到了当时尚默默无闻的艺术家<strong>库尔特·施维特斯</strong>（1887-1948）并向他介绍了达达哲学，事实证明，这次偶遇成就了施维特斯。施维特斯创作了上百件拼贴画，给他们冠以统一的名称“梅尔兹”，意图很简单，用丢弃的废料，使艺术和真实世界合而为一。之后，他从“放在画框里呈现、打算挂在墙上展示”转移到了“梅尔兹堡”里，这是一种杂合体创作物，部分雕塑、部分拼贴画、部分建筑。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fosombo6xyj313c1jkqv7.jpg" alt=""></p></li><li><p>把不讨好的日常物件化为艺术作品的实践并不新鲜，但当<strong>马赛尔·杜尚</strong>于 1917 年把一个小便池变为自己“现成的”雕塑《泉》之时，他将这个概念推到了极致，这一举动让杜尚成了“达达主义之父”。 这位法国人不会放过任何一个打破各种社会屏障的机会，他将一张印有《蒙娜丽莎》的明信片画上了小胡子和一撮山羊胡子，这就是著名的《L.H.O.O.Q.》。在他看来颠覆个人性格也理所当然成为了他的目标，1920年，他开始以女性形象盛装出现，化名罗丝·瑟拉薇。</p><center><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fosomwkkcmj308c0d6qa0.jpg" alt=""></center><p>杜尚马上跑到在纽约的达达主义者，美国艺术家、摄影师<strong>曼·雷</strong>（1890-1976）的工作室里，让他为罗丝拍照，不久后，杜尚将照片中罗丝的面部剪下来，放进另一件艺术作品中，又一次，出发点是已经存在的物件，这回的现成品是空的里高（Rigaud）香水瓶，杜尚把原有的商标替换为自己的创作，《美丽气息》是一件典型的杜尚式达达主义的反艺术作品，瓶中并无香水，它是对物质主义、虚荣、宗教和艺术的批判，这些东西在杜尚眼里都是没有安全感、没有信心或无知愚昧的人所崇拜的“假上帝”。</p><center><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fosonm6bnbj30eo09pdmx.jpg" alt=""></center></li><li><p>这也证明，尽管达达主义以纽约、柏林和巴黎为前沿阵地，成功地展开了一场世界性的反艺术运动，但还是不可不避免的走向了失败。事实是，我们生活的社会比鲍尔、查拉、杜尚所试图改变的世界还要贪婪得多。1923 年，达达主义转化成了超现实主义。</p></li></ul><h2 id="超现实主义：以梦为生-1924-1945"><a href="#超现实主义：以梦为生-1924-1945" class="headerlink" title="超现实主义：以梦为生 1924-1945"></a>超现实主义：以梦为生 1924-1945</h2><ul><li><p>在所有的艺术运动中，有一个大多数人都自以为相当了解的：超现实主义。这是因为，和其他艺术运动不同的是，超现实主义的精神延续至今，一代又一代的艺术家接过达利和曼·雷的火炬继续前进。这个词是由法国诗人纪尧姆·阿波利奈于 1917 年发明的，一次是为了他的戏剧《蒂蕾西娅的乳房》，另一次是为了俄罗斯芭蕾舞团上演的芭蕾舞剧《展示》。</p></li><li><p>几年后，心高气傲的巴黎年轻诗人<strong>安德烈·布勒东</strong>（1896-1966）对自己全力支持的达达主义运动愈感失望，他正寻找一种新的艺术表现形式，好让他把西格蒙德·弗洛伊德的精神分析法注入到达达主义的模式中区。他四处寻觅这次运动的名字，最终在阿波利奈的作品中发现了“超现实主义”一词。</p><p>依照现代艺术运动的经典模式，超现实主义运动以对整个社会彻头彻尾的抨击拉开了序幕，布勒东想要把“理智的”现实和”完全下流的”现实放在一起，造成不安，他曾当过精神病科护理员，这使得他对堕落和精神失常怀有浓厚兴趣。他将超现实主义称为用以改变世界的“新疾病”</p><p>我们知道马列维奇、康定斯基、蒙德里安这样的艺术家已经探索过无意识在艺术中所起的作用，但和他们以抽象绘画激活我们潜意识里的乌托邦不同，布勒东的超现实主义力图让我们面对触目惊心的词语和意象，从而揭露我们思想里的堕落。</p><p>达达主义没有祖先，而布勒东则非常乐意将许多伟大的艺术家化为超现实主义所有。毕加索创作了《三个舞蹈者》并同意布勒东将其发表在关于绘画的超现实主义论述中，毕加索将这三个四肢舒展的人画成二维的几何形状，手法和他用来画《少女》中的那些妓女的原始-立体主义相类似，他们跳的不是欢乐之舞，而是死亡之舞，这幅画可以被解读为命中注定的三角恋故事。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fosopil8qij30sg16oqv6.jpg" alt=""></p></li><li><p>目光转向另一位西班牙艺术家<strong>胡安·米罗</strong>（1893-1983），他的作品《小丑的狂欢节》（1924-1925）成了超现实主义首次展览的热点话题，布勒东形容超现实主义为“最纯粹状态下的精神的不自觉”，这就导致米罗的作品缺乏一个明确的构图。《小丑的狂欢节》成了艺术家潜意识的一次大喷发，通向无意识深处的路径打开，揭露了我们头脑中黑暗而危险的真相，性堕落、谋杀等种种念头如潮水般涌来。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fosoqimx18j319g0xchdx.jpg" alt=""></p></li><li><p>米罗位于蒙马特的工作室毗邻德国艺术家<strong>马克斯·恩斯特</strong>（1891-1976），超现实主义的推手，年轻的恩斯特总是寻觅着各种思想和境况，将自己的视野拓展到乡间生活以外，弗洛伊德的《梦的解析》（1900）的出现，解救了这个男生。不久后，他跟艺术家让·阿尔普一见如故，恩斯特加入阿尔普的队伍，在达达主义运动中扮演了重要角色。他很快和查拉和布勒东熟识，两人都很欣赏他的作品和态度。</p></li><li><p>当恩斯特和米罗创造着他们的无意识图像时，<strong>萨尔瓦多·达利</strong>（1904-1989）正计划从另一角度实现超现实主义。他对现实主义的理解是通过对“梦境”的描绘，但这些“梦境”不是用米罗和恩斯特的自发联想得到的，而是使自己变得恍惚，达到“偏执临界”状态，布勒东是他的粉丝，两人都遵循弗洛伊德的“梦境更加现实”路线。达利创作的大量作品中最有名的一副是《记忆的永恒》（1931），其中的调色技巧如同文艺复兴大师般精妙。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fosorbw6ysj31jk146b2c.jpg" alt=""></p></li><li><p><strong>勒内·马格里特</strong>（1898-1967）采取了一种稍微不同的方法来表示逼真的梦境，他认为平常的事物之下潜藏着不平常的邪恶，在超现实主义事业额的早期，他就通过《受威胁的暗杀者》（1927）证明了这一点，这一个毛骨悚然的画面，带有犯罪电影的氛围。他的绘画灵感来自于流行文化，和大多数超现实主义者一样，他的灵感也来自意大利乔治·德·基里科（1888-1978），布勒东还是学生的时候，基里科就已经在创作狂野的超现实主义图像了，鉴于“超现实主义”这个词还不存在，因此他称之为“形而上的”。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fososbhfwwj31jk16b1l0.jpg" alt=""></p></li><li><p>1921 年，<strong>曼·雷</strong>移居巴黎，将自己的创作精力集中在摄影上，他不断对摄影过程进行实验，力求让创作出来的影像具有绘画的光彩和力量，意外发明了“中图曝光”，并创作出了《物质相对于思想的第一性》，回答了超现实主义中的诸多话题:性、梦… </p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fosot9ti3ij311g0qe7wh.jpg" alt=""></p></li><li><p>现代艺术公认的典范中缺乏女艺术家的身影，回到 1936 年，很少有人能够意识到这个问题，然而不多的人当中就有偶像破坏之王：马赛尔·杜尚。1943 年，佩姬·古根海姆——一位富裕的美国收藏家和艺术经纪人——请杜尚在她新开的纽约世纪艺术画廊办个展览，杜尚提出了一个惊人的建议：何不来一次只有女艺术家的展览。</p><p>1943 年初，”31 位女性的展览”在纽约开幕，隆重推出一件后来成为超现实主义标志之一的作品。《物体》（皮毛餐具）是一组由皮毛作衬的茶杯、茶碟和勺子，1936 年由瑞士艺术家<strong>莫瑞特·奥本海姆</strong>（1913-1985）创作，她创作《物体》时才 22 岁，但已是巴黎那群人里公认额的宠儿，她当过曼·雷的助手。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fosouo5vg9j31jk15gu0z.jpg" alt=""></p><p>奥本海姆并不是唯一在超现实主义团体里“兴风作浪”的女艺术家。<strong>弗里达·卡罗</strong>曾是一个早熟的墨西哥知识分子，在国立大学学医，一次车祸让她决定成为一名艺术家，而不是医生，并且很快就开始创作贯穿她一生的主题：自己。当你观赏一副卡罗的作品时，就会明白为什么布勒东要把这位火一般的墨西哥艺术家招募进超现实主义的阵营。</p><p>而卡罗的朋友，英国超现实主义者<strong>利奥诺拉·卡灵顿</strong>的故事和卡罗一样充满戏剧性，她二十岁就创作出了重要的现实主义作品《自画像：黎明马客栈》，并且在聚会上认识了超现实主义艺术家马克斯·恩斯特，此时，恩斯特已婚，并且比她大二十六岁，但放荡不羁如卡灵顿，她成功俘获了她的男人。她把这幅画送给了恩斯特，后者于 1939 年战争开始后遭到拘禁，卡灵顿开始精神失常并被关进了精神病院。</p><p>千方百计逃出来的恩斯特回到家中，却发现了她已不在，之后，恩斯特到了马赛，找到一处安全的住所，佩姬·古根海姆也住在附近，当多情的佩姬见到了受了情伤的恩斯特时，立刻被这位艺术家所吸引，并于 1942  年与他结婚。</p><p>好景不长，马克斯·恩斯特出席了“31位女性的展览”开幕式，无可救药地爱上了一位美国超现实主义<strong>多萝西娅·坦宁</strong>（1910-2012），和古根海姆离婚后，恩斯特于 1946 年在一个联合婚礼上与坦宁结为夫妻。在同一个婚礼上结婚的还有曼·雷和他的伴侣朱丽叶·布劳内。</p></li><li><p>欧洲的超现实主义者和达达主义者已经集结到了美国，还有前来避难的还有包豪斯成员、风格派与俄国构成主义，这些艺术家成功与美国本土的先锋派融为一体，纽约成为了世界现代艺术的新中心。</p></li></ul><h2 id="抽象表现主义：宏大的姿态-1943-1970"><a href="#抽象表现主义：宏大的姿态-1943-1970" class="headerlink" title="抽象表现主义：宏大的姿态 1943-1970"></a>抽象表现主义：宏大的姿态 1943-1970</h2><ul><li><p><strong>佩姬·古根海姆</strong>是个富有激情的女人，对三种事物的热爱贯穿了她的一生：钱、男人、现代艺术，她对钱的热爱继承当实业家的父亲，她对男人无止境的欲望则是自己开发的。至于对现代艺术的爱，来自一颗永远好奇的心和追求冒险的喜好。</p><p>迫于二战，她想在伦敦建离一个现代博物馆的想法落空， 于是，她回到曼哈顿决定开一家以当代艺术见长的画廊——本世纪艺术画廊。正是在佩姬的画廊里，欧洲和美国的艺术界碰撞出了火花，点燃了现代艺术史上一次新的运动。展览开幕前夜，佩姬发现蒙德里安蹲在地上全神贯注地盯着一副等待展出的作品，这位荷兰艺术家停顿了一下，说：“这是我见过的美国人画的最有意思的作品，你应该留意他”。<strong>杰克逊·波洛克</strong>（1912-1956）所画的《速记人物》并非一张抽象画，也没有任何迹象显示他后来会发明滴画法以成名。这幅画很大程度上应归功于毕加索、马蒂斯和米罗——波洛克最为崇拜的三位欧洲画家。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fosowxxnn0j31jk13pnpi.jpg" alt=""></p><p>波洛克常常无法控制自己的情感，体内藏着过于庞大的感情发动机，对此，他试图以酒精加以控制，醺酒让事情变得更糟，使他开始寻求医疗帮助，心里治疗使他了解到了弗洛伊德和超现实主义都认为从无意识中可以发现自我，他开始尝试无意识的行为，自发地描画进入他脑海的任何事物，将颜料以一种更加自由而富有变现力的方式涂抹到画布之上。</p><p>当时他已经对大规模作画产生了兴趣，而这受到墨西哥壁画家迭戈·里韦拉（卡罗的丈夫）的启发，因此。 1943 年，当佩姬委托他创作壁画时，他已踌躇满志。六个月过去了，画布上还是一丁点颜料都没有，直到最后一晚，一整晚的疯狂画画和激情中，他完成了这次创作，在毫无知觉的情况下开启了下一次被称为“抽象表现主义”的新艺术运动。</p><p>《壁画》(1943)具有早期抽象表现主义的诸多特征，在这个阶段，它还是画家将颜料运用到画布上使所留下的原始物理痕迹或“姿态”。后来的风格更加沉静、更加深沉。波洛克认为架上绘画已走到穷途末路，艺术家前进的方向应当是在墙上作、在地上作画。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fosoxpk3wfj318g0hy4qr.jpg" alt=""></p><p>支持波洛克、委托他创作《壁画》、卖出《母狼》以及为他举办 1943 年的个人展，是佩姬事业里迄今为止最伟大的成就之一。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fosoykbbwnj31jk0yhb2e.jpg" alt=""></p><p>1948 年，全世界第一次见识了波洛克的伟大创新：他将画布铺在地上，以充满活力的方式把普通颜料滴落、倾倒、轻弹在整张画布上，他穿过画布，站在中央，用毛巾、小刀和棍子操纵颜料，再加入沙子、玻璃或烟头。对这些材料的应用显然从布拉克和毕加索的拼贴画与施威特斯的“梅尔兹”中得到了启发，《满五英寸》是他早期的滴画作品之一。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fosozfcwulj30wk1jknpi.jpg" alt=""></p><p>在出生于德国的摄影师<strong>汉斯·纳缪斯</strong>（1915-1990）的推动下，波洛克的地位从纽约艺术界的反叛者上升为世界级的明星，有史以来第一次拍下了波洛克绘画时的作画方式和出于本能的动作编排（这些图像称为行为艺术的先驱），公众和媒体被这些照片迷住了，人们开始重新评价他的作品，他变成了世界上最有名的艺术家之一，波洛克死于一场醉酒驾车，年仅 44 岁。</p></li><li><p>另一位与波洛克一样享有神话般地位的，也同样被视为抽象主义发起人之一的<strong>威廉·德·库宁</strong>，德·康宁的画是一首视觉诗歌，在某种意义上和蒙德里安的作品有异曲同工之妙，两位荷兰艺术家都创造出了具有完美平衡感、带给人愉悦的画作。这一点能在《挖掘》中体现。不过，对于生命阴暗面的感受是的·康宁艺术的一部分，它抵消了作品中和谐的美感。他所创作的《女人》系列证实了这一点，创作动机是为了回顾更新女性裸体的观念，然而和马奈的《奥林匹亚》一样，刚刚问世之时便受到攻击，被指责厌恶、不尊重、大大伤害了美国现代女性。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fosp0xbxacj316r1jkqvc.jpg" alt=""></p><p>在德·库宁的《女人》和波洛克的滴画作品中，你都能感受到艺术家的体力和生机，通过大胆的绘画姿态和富有进攻性的笔触宣告他们的存在，这是抽象主义的一面，而另一群正好相反的艺术家构成了另一面，这些人是抽象表现主义中的色域派画家，他们的作品流畅而平静，他们更喜欢将单色颜料大面积地均匀铺开。</p></li><li><p><strong>巴尼特·纽曼</strong>（1907-1970）是色域画家的领军人物之一，发明了自己赖以成名的绘画方法，波洛克有滴画，纽曼有“拉链”：一道垂直线。这道垂直线有两个作用，一是为了暗示光线，它将影响 1960 年代的极简艺术家，二是为了作为他独特的签名，</p></li><li><p><strong>马克·罗斯科</strong>（1903-1970）是色域画家中最著名的一位，也是他们当中最容易被制成海报贴在全世界卧室或艺术教室墙上的一位。1949 年，他创作出了成熟风格的早期代表作《无题》（《白与红上的紫罗兰色、黑色、橙色和黄色》），这幅画以水平长方形为特点，色调温柔相融，大胆的色彩让人想起野兽派的用色风格，这将成为他的标记，就像“拉链”之于纽曼。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fosp28tonkj30r80xo7wh.jpg" alt=""></p><p>罗斯科对抽象画中几何形状的处理，与俄国构成主义和至上主义者大不相同：他们线条精准犀利，而罗斯科的则柔和和模糊。他也不追求在形状之间创造张力，他希望创造出的是颜色间的和谐，而且他所用的颜色范围大大超过构成主义者所依赖的原色。 </p><p>就罗斯科而言，这不是对形状和颜色的研习，而是对人类基本情感的探究，1949 年的《赭石》（《赭石，红上之红》）是对这一观念的体现。1950 年代后期开始，他的调色板呈现出忧郁而悲伤的风貌，深紫和血红混在一起，肃穆的棕色和暗淡的灰色融合，在艺术生涯之初，他的用色体现了马蒂斯式的旺盛生命力，而现在则离死神更近一步。</p></li><li><p>罗斯科曾说他的艺术由“对复杂思想的简单表达”构成，这是解释抽象表现主义的好办法，至少这是解释二维抽象表现主义的好办法，不过，加入三维的抽象表现主义却走向了完全相反的方向：一个简单的思想可能有相当复杂的外表。<strong>大卫·史密斯</strong>（1906-1965）的《澳大利亚》（1951）是一件不锈钢杆制成的雕塑，看起来就是三维的“波洛克”，那些不可预知的线条对空间的切割正像是波洛克滴落的颜料之于画布。他并不承认雕塑与绘画之间的界限，他将这个理念传给了他的英国学生<strong>安东尼·卡洛</strong>，后者回到英国后，不再以亨利·摩尔交给他的方式创作具体雕塑，而是毫不犹豫地转向抽象表现主义，创作出了《一天清晨》（1962）一个由金属杆和横梁组成的畸形构造，意在通过最基本、最普遍的事物来建立和我们的联系，它的成功让人觉得不可思议，就像每每我们遇到的一件伟大的抽象现实主义作品时所发生的那样。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fosp3gfbffj31jk15nhdt.jpg" alt=""></p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fosp3vk3h8j316o0v2qv6.jpg" alt=""></p></li></ul><h2 id="波普艺术：零售疗法-1956-1970"><a href="#波普艺术：零售疗法-1956-1970" class="headerlink" title="波普艺术：零售疗法 1956-1970"></a>波普艺术：零售疗法 1956-1970</h2><ul><li><p>1947 年，23 岁的<strong>爱德华多·保罗齐</strong>（1924-2005）来到巴黎追寻他的梦想，沉浸在达达主义和超现实主义的理念之中，就在这一年，他创作出了《我是一个有钱人的玩物》：一幅由时尚杂志剪裁下来的各种图像组成的拼贴画，画面基调放肆，充满暗示，性感女郎，樱桃暗示女性生殖器，手枪则具有阴茎崇拜色彩。这幅画具有波普主义运动的所有特征，即使十年后这一运动也尚未正式形成。这张拼贴画体现出了波普艺术的基本精神，即相信高端文化和低端文化是同一种东西。保罗齐已经认定了名人、品牌商品和广告在消费主义的新时代里所具有的力量。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fosp5cqfxjj30so16okjn.jpg" alt=""></p><p>并不只有他对消费文化痴迷，他的一些英国朋友也有着相同的兴趣，这一帮驻扎在伦敦的艺术家、建筑师和学者，后来被称作“独立团体”。其中有一位名叫<strong>理查德·汉密尔顿</strong>（1922-2011）的人，在定义英国早期波普艺术理念和范畴上发挥了核心的作用。《是什么让今天的家庭如此不同、如此富有魅力？》（1956）在制作方式上与保罗齐早期拼贴画有异曲同工之妙，这幅今天已盛名远扬的拼贴画，是基于亚当和夏娃的故事创作而成的，只不过将他们从伊甸园搬到了战后 20 世纪的轻松生活。1957 年，汉密尔顿以非凡的远见将流行文化定义为：流行（为大众设计）、短暂（短期解决方案）、可消耗（容易被忘记）、低成本、大量生产、年轻、诙谐、性感、噱头、刺激性、大事件。</p><center><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fosp6enfb3j309o0a0n65.jpg" alt=""></center></li><li><p>这清楚地表明，波普艺术不是艺术家为幼稚公众创造肤浅艺术品的愚蠢阶段，而是一个高度政治性的运动，它敏锐地捕捉到了社会中隐藏的邪恶和危险。在美国，同样有两位年轻的艺术家<strong>贾斯培·琼斯</strong>（1930 年生）和<strong>罗伯特·劳申伯格</strong>（1925-2008）抱有同样的想法，他们在纽约经历过消费文化之梦，看到其黑暗的一面，并且认为抽象表现主义与现实失去了联系，他们希望反映现实和讨论他们单调乏味的现实生活，那就是 1950 年代的美国。这两个志同道合的艺术家之间的互帮互助让他们的创作为安迪·沃霍尔和罗伊·利希滕斯坦——美国两大波普艺术领头人——铺平了道路，但在这个阶段劳申伯格和琼斯是被称为新达达主义者。</p><p>琼斯经常会选择日常的题材，他的绘画迫使我们重新审视平凡之物，从这点来说他的艺术是外向型的，与抽象表现主义对内心情感的大胆叙述形成鲜明对比。劳申伯格也是一样，他认为罗斯科及其同伴过于死板和伪英雄主义，他认为不仅创作出的艺术要根植于消费主义美国所遗弃的下脚料，而且干脆用它们创作艺术。与劳申伯格的《字母组合》的初次相遇或许令人困惑，《字母组合》将艺术油画和雕塑及拼贴画混合在了一起，劳申伯格彻底背叛了他在学院里被教导的那套艺术创作方式，创作出了一系列《白色绘画》（1951），对抽象表现主义戏弄了一番。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fosp7rx80qj31jk1jknpf.jpg" alt=""></p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fosp8alw0wj31jk15fhdt.jpg" alt=""></p><p>劳申伯格将德·库宁的作品用橡皮擦除创作了《擦除的德·库宁的绘画》（1953），在一个评论家和收藏家被抽象表现主义奴役的时代，劳申伯格特立独行的勇气不应被低估，这幅作品被视为行为艺术的早期作品，激励着 1960 年代期间的一整代艺术家，并且《白色绘画》作为极简派艺术的先驱，促使作曲家——劳申伯格的好朋友——约翰·凯奇写了了他著名的非音乐《4’33’’》，理查德·汉密尔顿应披头士乐队之邀为其《白色专辑》设计封面时，《白色绘画》一定也萦绕在他脑中。</p><center><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fosp94vv9hj30fz0ihk06.jpg" alt=""></center></li><li><p>劳申伯格和琼斯——即是朋友——也是爱人——成功将现代艺术从抽象表现主义的冷酷控制中解放出来，他们的流行文化形象和对流行文化的挪用不再被视作一个玩笑，此刻，有一位三十出头的时尚插画艺术家迫切想要进入艺术界，此人是<strong>安迪·沃霍尔</strong>（1928-1987），他一边观看劳申伯格和琼斯的作品，一边感到绝望，他区区一个广告界的艺术家如何和这两位勇敢的艺术家相比。这些年，他尝试过了各种主题，仍然没有找到自己的主题和风格，它他开始将目标定在那些极受欢迎、具有广泛吸引力的形象上。直到他回到家中，吃着他二十年来一直吃的东西：一片面包和一听金宝汤罐头。</p><p>1962 年，在欧文·布卢姆的画廊中展出了安迪·沃霍尔的 32 幅《金宝汤罐头》（1962），它们由 32 块独立画布组成，每一块描绘一款不同风味的金宝汤系列食品。作为一件统一的作品，《金宝汤罐头》不仅让沃霍尔一跃成为一名艺术家，而且还将确立波普艺术，对大规模生产和消费文化的极度痴迷也将成为波普艺术的显著特征。沃霍尔用《金宝汤罐头》有意的的单调性来挑战艺术应该是独创的这一规矩，这一决定既是对艺术界把艺术家拔高为无所不见的天才的一种杜尚式的非难，也是对在大规模生产的同质化世界中个体工人的地位不断削减的一种关注（约翰·拉斯金和威廉·莫里斯曾在 19 世纪唤起这一关注）。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fospbf9lnrj31jk0xchdw.jpg" alt=""></p><p>沃霍尔对大企业和大众传媒的运作方式以及我们它们所传递的信息作何反应很感兴趣，没有别的艺术家能比安迪·沃霍尔更好理解消费主义，也很少有人能同时如此痴迷名人和病态，他在《玛丽莲双联画》（1962）中把二者合二为一，这也是沃霍尔丝网印刷技术的一个非常早期的实例。画中左边的图像明亮欢快，而右边的图像却展现出一种恐怖的氛围，这是沃霍尔最具标志性的艺术品之一。安迪·沃霍尔是一位非凡的艺术家，他选择了以消费社会作为主题，并以消费社会的法则对其进行利用。</p><center><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fospcahfsoj30af07dq9w.jpg" alt=""></center></li><li><p><strong>罗伊·利希腾斯坦</strong>（1923-1997）曾一度涉足艺术领域，同沃霍尔一样，没有找到让他满意的风格。直到他无意间看到了卡通漫画，漫画成为迅速崛起的波普艺术运动艺术家们探索的领地，1960 年代，彩色漫画采用一种使用本戴制版法的印刷技术， 利希腾斯坦复制了这一系统，无意间发现了一种风格，可以让自己的绘画立马就能够被辨认。</p></li><li><p>美国艺术家<strong>克拉斯·欧登伯格</strong>（1929 年出生）天才般地实现了模糊艺术和商业的想法，它在纽约租下一处房产并布置为“商店”（1961），但是“商品”由铁丝网、石膏、棉布做成，这是将波普艺术的哲学理念经过逻辑推理后的一种样式，一年后的 1962 年，沃霍尔和利希腾斯坦都取得了突破，建立了波普艺术的主流地位。当罗伊·利希腾斯坦就是否坚持自己的本戴式点风格犹豫不决时，正是<strong>艾伦·卡普罗</strong>（1927-2006）对他说：<strong>“艺术并非看起来像艺术才是艺术。”</strong>一个全新的艺术运动将从中诞生。</p></li></ul><h2 id="观念主义-激流派-贫穷艺术-行为艺术：心灵游戏-1952至今"><a href="#观念主义-激流派-贫穷艺术-行为艺术：心灵游戏-1952至今" class="headerlink" title="观念主义/激流派/贫穷艺术/行为艺术：心灵游戏 1952至今"></a>观念主义/激流派/贫穷艺术/行为艺术：心灵游戏 1952至今</h2><ul><li><p>在现代艺术的范畴中，我们对观念艺术往往持有怀疑的态度，它们是在现代艺术里一个观念至上的领域内运作的，不怎么关乎事物的创造，因此叫做观念艺术。只有观念出色，观念艺术才会出色。</p><p>马赛尔·杜尚是观念艺术之父，1917 年的小便器导致了与传统的决裂，引起了对什么是艺术和什么应该被认为是艺术的重新评价，杜尚认为艺术家不应该被限于如此严格的媒介范围内来表达他们的理念和情感，概念应该第一位的，然后才考虑什么是表达概念的最好形式。观念艺术中的有一分支名为行为艺术，可以将艺术家自己的身体作为媒介。</p></li><li><p>2010 年，纽约现代博物馆举行了<strong>玛莉娜·阿布拉莫维奇</strong>（1946 年生）回顾展，在当时世界最大的现代艺术博物馆里，行为习俗不可能成为主流。现代艺术博物馆保留了其创始人的精神，挑战习俗，举办了展演。该作品很恰当地被称为《艺术家在现场》（2010），这件作品是：阿布拉莫维奇坐在现代艺术博物馆宽大中庭中央的一把木椅上，面前放着一张小桌子，在桌子的另一端，放着一把空木椅。</p><center><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fospec5y1aj30d108o43j.jpg" alt=""></center><p>结果表明，玛莉娜·阿布拉莫维奇的回顾展绝不小众，它是曼哈顿现代艺术圣殿有史以来举办的最成功的展览之一，它与毕加索、沃霍尔和梵高回顾展一同跻身于该机构历来极为成功的展览的名单之一。</p></li><li><p>从源头看，这一运动历史颇长,最早克追溯到 1950 年代初期北卡罗来纳州黑山学院上演的即兴演出，艺术家罗伯特·劳申伯格和他的朋友，作曲家、音乐家约翰·凯奇，以及他的挚友、舞蹈教练梅尔塞·康宁汉——均是即兴演出团体的领导者，凯奇在同年黑山展，献上了传奇色彩的《4’33’’》，凯奇的回复是，《4’33’’》并不关于无声的，而是关于聆听，关于凯奇的评论很快蔓延开来，很多人发现了凯奇的可贵之处，组成了一个艺术家粉丝俱乐部。</p></li><li><p>他的崇拜者之一——<strong>艾伦·卡普罗</strong>,试图开始一次开辟艺术新时代的冒险时，他的想象力被点燃了，他在文章《杰克逊·波洛克的遗产》中阐述了很多观点，认为波洛克是最具天赋的画家，但同时他只是一名碰巧使用颜料的行为艺术家，问题在于波洛克被方形画布所限制。卡普罗还说：“将来人们不必称自己为一名画家或者诗人和舞蹈家，只需称作艺术家。”</p><p>1959 年秋，艾伦·卡普罗在纽约鲁本美术馆展示了一个活动，其中包含了他的许多理念，他在美术馆内建造了三个相互连接但用半透明板墙分隔的空间，这一作品称为《6 处 18 次即兴演出》，按计划分为六幕，每一幕有三个即兴表演。</p><p>在卡普罗进行尝试的同时，约翰和劳申伯格正在创建美国的波普艺术，他们都有一颗连通艺术和生活的雄心，约翰和劳申伯格的方法是把商业转化为艺术，而卡普罗则是通过把老百姓变成艺术的一分子。</p></li><li><p>新现实主义</p><p>卡普罗的求知欲使得他获得了很多灵感，尤其是从法国艺术家<strong>伊夫·克莱因</strong>（1928-1962）那里，他以大量大幅的抽象单色表达了他对“虚空”的神秘而富有哲理的情感，不久，所有的绘画都以深蓝色绘成，命名为国际克莱因蓝（IKB）并申请了专利。</p><p>伊夫·克莱因是法国新现实主义运动的一分子，这一运动与当时观念主义艺术的其他流派一样，都将超越“人体测量”作为自己的目标，克莱因的做法是用一系列舞台作品将注意力转向行为艺术，当他 1962 年死于心脏病时，年仅 34 岁，他短暂的一生在很大程度上为观念艺术及行为艺术的未来定下基调。</p><p>意大利艺术家<strong>卢齐欧·冯塔纳</strong>（1899-1968）也对虚空和空间感兴趣，和克莱因有着相同的雄心，要考研、挑战画布的局限和力量，克莱因用单色颜料不断描绘他的画布，冯塔纳则对他的画布用起了剃须刀片，他称其为空间主义，他的作品时些不被切割的画布，其中有许多被冠以“空间概念”的标题。</p></li><li><p>贫困艺术</p><p>卢齐欧·冯塔纳使用最少材料获取最大效果的做法，引发新一代意大利艺术家继续构建贫困艺术运动，贫困艺术是指在艺术制作中使用基本材料，在从毕加索到波洛克的现代艺术故事中，这一做法得广泛运用。</p><p>随着二战结束，意大利曾经有过短暂的繁荣，从此便陷入崩溃，贫困艺术就是在此背景中诞生的，与未来主义派艺术家——意大利现代主义之祖——不同，他们的兴趣在于把现代生活于过去连接起来，试图根除艺术与生活之间的阻隔，还有不同艺术流派的阻隔。这些意大利人认为，一名艺术家应该能在绘画、雕塑、拼贴画、行为艺术和装置艺术间游刃有余并使他们融合在一起。</p><p><strong>米开朗基罗·皮斯特莱托</strong>（1933 年生）是这以运动的创始人，他希望把艺术从博物馆和美术馆这些神圣的场所中解放出来。他创作了雕塑《破衫中的维纳斯》（1967），他在维纳斯的雕塑周围堆满了废弃的二手衣服，通过这种方式，艺术家揭示并批判了消费文化那种一次性的肤浅本质。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fospgfc1m4j316o0xinpe.jpg" alt=""></p><p>同为贫穷艺术流派的艺术家<strong>简尼斯·库奈利斯</strong>（1936 年出生）将这一运动利用“卑微材料”的反资本主义路线，推向施耐特和劳申伯格所代表的极端，他用来制作艺术品的材料包括旧床架、煤袋、衣架、甚至是活牲畜。</p></li><li><p>激流派</p><p>德国艺术家和政治活动家<strong>约瑟夫·博伊斯</strong>（1921-1986）用一辆大众牌野营车制作了一件艺术品，24 具雪橇翻滚下来，每一具上都捆着一个救生包，里面有一块动物脂肪、一只手电筒和一卷毛毡，他将这一作品称为《一群》（1969），博伊斯是 20 世纪下半叶诞生的最重要的艺术家之一。他曾担任过纳粹德国的空军飞行员，他通过一系列讲演、对政治直接的兴趣来直面对自己和德国所作所为的内疚。纳粹在艺术创作上提倡乏味的统一性和不朽性，而他的作品是它的对立面。</p><center><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fosph7t4jxj30dw0ijqo3.jpg" alt=""></center><p>他找到了一个灵魂伴侣<strong>乔治·马修纳斯</strong>（1931-1978），一名立陶宛—美国艺术家，对马赛尔·杜尚、卡普罗的即兴演出、新现实主义和达达主义感兴趣，使他对一场新达达主义艺术运动发展出自己的理念，他称之为激流派，起草了《激流派宣言》（1963），允诺激流派将“促进生活艺术，把文化、社会及政治革新的骨干融合为统一的战线和行动。”</p><p>另一位激流派艺术家<strong>小野洋子</strong>（1933 年生），《切片》是一部惊人的、强大的作品，它以令人不安的后果展现了观众如何能够成为艺术品中的固有元素。它揭露了有关人性和人际关系、攻击者与受害者、施虐狂与受虐狂的真相，在我们能想到的绘画或雕塑中很少有能够达到这样效果的。</p></li><li><p>观念艺术</p><p>不倾向于在观众面前现场展示的观念艺术家，同样利用表演和他们的身体作为传递信息的媒介，像<strong>布鲁斯·瑙曼</strong>（1941 年出生）这样的艺术家，记录下自己的行为，再以照片和视频的形式在画廊和博物馆展出，从而建立起职业生涯。他曾自问“为什么艺术应该是一件产品而不是一项活动？”因此，瑙曼开始对艺术创作的过程怀有浓厚的兴趣，仿佛它就是最终成品，不久后，他创作出一幅名为《未能在工作室飘浮》（1966）的摄影作品，记录了他对尝试去完成不可能之事并失败的记录。我们将太多时间花在了对美术馆的走马观花上，在匆忙买一杯咖啡或一张明信片的路上瞧一眼梵高的绘画，绊倒一具芭芭拉的雕塑，瑙曼不想让这样的事发生，他的艺术涵盖许多事物，但排在首位的是意识。</p><center><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fospi93e8rj30ci0aftfc.jpg" alt=""></center><p>随着观念艺术在当代艺术舞台上的分量越来越重要，这一主题开始大量出现，<strong>弗朗西斯·阿里斯</strong>（1959 年出生）就创作了受到高度赞扬的全身“行动”，这些行为包括他围绕着他现今居住的墨西哥城散步，它所强调的问题是，我们大部分人因为太忙而忽视了我们身边的环境。</p><p><strong>理查德·郎</strong>（1945 年出生）也喜欢散步和观察我们对周边环境的影响，他为贫瘠的土地拍照，创作出了《走出来的线》（1967)，他决定在田野的中间来回走动直到踩出一条明显的路径，而后把它拍下来，这是一幅简单动人的作品，通过精心的设计来展现人类的存在。使人想起先前诸多现代艺术运动，从杰克逊·波洛克用脚画出的有力笔触，到巴内特·纽曼的“拉链”画，以及包豪斯朴素的设计。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fospj4e633j316o0u1k7x.jpg" alt=""></p><p>这是场景艺术的一个早期的例子，它是概念艺术的一个分支，于 1960 年代 70 年代初开始盛行，该流派最著名的代表当推<strong>罗伯特·史密森</strong>(1938-1973)的《螺旋形的防波堤》（1970），它是坐落在犹他州大盐湖的一座纪念碑式的土方工程雕塑，由当地已有的黑色玄武岩制成。史密森认为，博物馆里的展览已走到了生命的尽头，他选择在大自然中创作艺术。《螺旋形的防波堤》从根本上是关于人类与环境的关系，这一作品大部分时间都被水淹没，只有当干旱来临时，它才会突破水面。《螺旋形的防波堤》已成为世界上最大的晴雨表，为我们与环境关系的状况和我们周边的结构——消费主义和全球化——如何影响我们的行为提供了参照系。正如索尔·勒维特所说：“只有观念出色，观念艺术才会出色。”《螺旋形的防波堤》是一个极为出色的观念。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fospjp0x0pj30m80cih6j.jpg" alt=""></p></li></ul><h2 id="极简主义：无题-1960-1975"><a href="#极简主义：无题-1960-1975" class="headerlink" title="极简主义：无题 1960-1975"></a>极简主义：无题 1960-1975</h2><ul><li><p>极简主义是在许多影响下诞生的，从宾西法尼亚的铁路，到安德烈·布勒东的超现实主义。在极简主义的混合体中，有许多包豪斯冷静的现代主义美学，还有大量俄罗斯的构成主义，由于这些雕塑具有被动性，它们实际上与行为艺术有很密切的联系，我们并非仅仅欣赏它们棱角分明的优雅，而且还意识到它们的存在如何改变了我们以及我们所在的环境。</p><p>由极简艺术家的创作的艺术，从某种意义上说，与其他任何时期创作出的任何艺术并无不同。艺术，永远是关于如何从杂乱中理出条理，它可能是风格派网格体系有条不紊的构成原则，也许是立体主义互有关联的平面，即使是达达主义的无政府虚无主义，也旨在消除世界上的衰败与颓废以建立一种新的世界秩序。其总目标是相同的：希望掌控生活。极简艺术家在这一点上起到比过去艺术运动更大的作用，这一运动人员名单上全都是美国人，均为男性，都是白人。</p><p>这又是现代艺术中的一个“男士俱乐部”，参与其中的艺术家喜欢创作具有机械般冷酷特性的严肃作品，他们对这些作品的细枝末节的关注程度之高堪称痴迷。他们的工作更像建筑师：制定计划，下达指令，监督生产。如同美国的波普艺术家一样，他们想抹去所有的痕迹，去掉座屏中任何表露个人情感、主观性或作者身份的迹象。</p></li><li><p>他们的目的是迫使参观者集中精力应对面前的事物，而不是把注意力分散到作者的个性上，有些艺术家如<strong>唐纳德·贾德</strong>（1928-1994）甚至不给作品取名，因此我们遇到的贾德的大量作品都拥有统一的名称——无题。</p><p>贾德起初是一名创作大型抽象表现主画作的艺术家，他的画作经常使用到一种称作镉红的血一般的颜料，他离开画布的理由来自他的极简主义哲学，他认为观众难以将画布和上面的图像看做一个整体，而贾德所追求的是“统一性”和“整体性”，他将在雕塑中找到答案。</p><p>《无题》（1972）是一只敞开的、经过磨光的铜箱，贾德在内壁涂上了他钟爱的镉红色瓷釉。它不象征任何东西，也不暗示任何意义，但它是一件艺术品。贾德一直在抵制那些可能干扰材料性质或干扰观众纯粹视觉体验的因素。贾德的雕塑目的就是要让观众进入现在时，没有需要弄懂的故事和寓言，没有让人分心的东西，贾德认为，波洛克作品中充满了偶然性的泼洒，完全实现了艺术家对于“偶然”概念的全部探索，而贾德简化作品的原因则在于：“去掉偶然”。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fospnecvz1j316o1014qp.jpg" alt=""></p><p>尽管如此，他还是用他的“堆叠块”抓住了偶然，如 1967 年的《无题》（《堆叠》），类似十几块无支撑的搁板，一块高于一块从墙上伸出来。所有一切都由某种不可见的东西拢在一起——这正是贾德的才华所在，他称之为极化作用，我叫它张力。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fospo5atj8j318g1jknpd.jpg" alt=""></p></li><li><p>相似的理念可以在<strong>弗兰克·斯特拉</strong>（1936 年生）的绘画中找到，早年以抽象表现主义起家，23 岁决定从事简化版抽象表现主义的创作。坎宁正在为博物馆策划一次展示美国先锋派艺术家新兴趋势的展览，决定将斯特拉的作品列入其中，此次被称为“16 位美国人”的展览将成为一个重要节点，自此以后，现代艺术开始挣脱早期抽象表现主义情绪化绘画的束缚。斯特拉对于极简主义的影响是巨大的，他给贾德以才智上的激励，他对雕塑家<strong>卡尔·安德烈</strong>（1935 年生）的评价改变了这位艺术家的一生。</p><p>安德烈在雕刻完一面木头之后，被斯特拉告知与没雕刻的另一面一样好，安德烈同意，并且说如果再有一块木头，他不会去雕刻它，而是用来切割空间。安德烈掘弃了基座，将作品直接放在地板上。最著名的作品可能是《等量物 8》（1966），把 120 块耐火砖摆成两层的矩形，泰特美术馆因在 1976 年展出这些作品而饱受媒体的抨击，这一雕塑展现了安德烈极简主义作品的特点，尽可能使用工业原料，各组成部分之间或构成图内没有等级之分，完全抽象，直白简洁，排列对称，艺术家尽可能不带个人色彩。安德烈不像其他极简艺术家，他不使用螺栓、胶水、油漆或者捆绑，也会发生参观者把安德烈雕塑中的一块藏在衣袖中带走这样的事件。</p></li><li><p>安德烈曾邀请参观者踩踏他建在地板上的雕塑，希望帮助参观者理解这种物理材料，这种理念可以追溯到俄罗斯构成主义塔特林，而安德烈正是此人的粉丝，在《角落的反浮雕》中，塔特林鼓励参观者去琢磨该物品的制作材料以及对空间的影响，这是一种非常接近五十年后美国极简艺术家所采用的方法。对于塔特林的推崇，没人能比得上<strong>丹·弗莱文</strong>（1933-1996），他将 39 座雕塑献给了这位构成主义的创始人。</p><p>当塔特林使用 20 世纪初期的现代建筑材料（铝、玻璃、钢铁）来制作作品时，弗莱文则选择商用荧光灯管作为雕塑的材质。塔特林对材料的选择是出于对俄罗斯革命的支援，而弗莱文则是参考了艺术史并结合了当代评论。光线，当然一直是艺术实践的固有部分，在基本层面上，一名艺术家只有在光线下才能观察和创作。卡拉瓦乔和伦勃朗用戏剧般的明暗技法来突出光影反差，创作出非凡的绘画，从特纳到印象派的艺术家们倾其一生试图捕捉光纤那稍纵即逝的效果。曼·雷将他的实物投影和中途曝光的摄影创新形容为“用光作画”。</p><p>相比之下，弗莱文喜欢荧光灯不带个人色彩和大规模生产的特质，认为它是一种连接艺术和生活“日常关怀”的材料。这些荧光灯管是他“玩弄空间”、改变房间形象和观众反应的一种手段，并且从 1963 年以来一直是他制作艺术品的主要工具，他在长达 25 年的时间里所创作的献给塔特林的诸多作品是最为著名的系列，第一件创作于 1964 年，最后一件是 1990 年，它们都有同样的标题——《献给V·塔特林之纪念碑》。</p><p>《献给V·塔特林之纪念碑 1》是系列作品中的第一件，含有七个靠墙固定的荧光灯管，以最高的一个作为雕塑的中心，其余六个以每边三个的方式对称分布，从高到低，类似正态分布。尽管这些材料不怎么样，但当通上电时，它便产生了预期的效果，不可否认，荧光灯对其空间产生了巨大的影响。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fosprw8cooj30qm1jkx6p.jpg" alt=""></p></li><li><p><strong>索尔·勒维特</strong>（1928-2007）于 60 年代初在纽约现代艺术博物馆的书店工作时，正是丹·弗莱文帮助他发现了削减的极简主义理论。他向勒维特展示了他的灯光作品，并为这位书店助理指出了一条追求自己艺术抱负的道路。</p><p>他与生俱来的温情和友善，令他的雕塑臻于纯粹，1996 年，他推出了作品《序列工程 1》（《ABCD》），这是一幅由几个白色矩形方块构成的雕塑，有的是实心，有的是空心框架，所有这一切都安放在地板上的巨大方形灰色垫子上，垫子上画着白色的网格线，立方体放置在网格内，整个构图让人想起从空中俯瞰纽约城。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fosptclukzj31jk0owhdu.jpg" alt=""></p><p>勒维特这次创作的理念是想搞清楚，为什么有些东西在某种情况下可以看起来即有条理又整洁，而在另外一种情况下则是一团糟。他的个人宣言是“再造艺术，从头开始”，《序列工程 1》（《ABCD》）是极简艺术作品的原型，你可以认为它是太空时代的艺术：精准、条理和无情的冷静客观，极简艺术家与那些正设计火箭的科学家们，在同一时间探索同样的原则问题：物质、系统、体积、顺序、感觉和条理。</p><p>极简艺术表面的平静，泄露了要为世界带来秩序与控制的艺术家们所感到的内在紧迫，他们并没有把这种冲动传递给下一代艺术家，他们在 60 年代嬉皮士运动中成长起来，而后在 70 年代石油危机的影响下点燃创作的欲望。</p><p>极简主义标志现代主义的终结，现在，艺术将步入一个后现代主义的新时期。</p></li></ul><h2 id="后现代主义：假身份-1970-1989"><a href="#后现代主义：假身份-1970-1989" class="headerlink" title="后现代主义：假身份 1970-1989"></a>后现代主义：假身份 1970-1989</h2><ul><li><p>后现代主义的一大好处是，几乎你想让它是什么，它就是什么，但同时，后现代主义最恼人之处也在于此，这一随心所欲的悖论是此次运动的关键，普遍认为现代主义与极简主义一起终结于 1960 年代中期，如同后印象派一样，后现代主义是对其先驱的发展和批判性回应。法国哲学家让·利奥塔将后现代主义描述为“对宏达叙事的怀疑”。在后现代主义看来，现代主义对于解决人类问题的单一而包罗万象的方法的不断探索是愚蠢的，他们认为任何的新的大思想都会像 20 世纪的其他“宏大叙事”一样注定失败，如共产主义和资本主义。</p><p>对他们来说，如果有答案，也需要从先前运动和理念里挑选出最佳集合，根据这些片段创作出一套新的视觉速记，同时这也是一种难以消化的混合物。<strong>菲利普·约翰逊</strong>所设计的美国电话电报大楼是一个典型的后现代主义的拼接物，对艺术史的诙谐引用混杂着对现代文化的热情相拥。抽样、嘻哈、文化、混合、对公众形象的敏锐意识均成为后现代的特色：自觉的洞察与辛辣的讽刺成为通用的语言。既然任何东西都没有单一的答案，那就意味着任何东西都值得考虑，而且如果需要，就可以被合法地容纳起来，区别和定义变得模糊，无法分清事实与虚构，对后现代性来说，表面形象至关重要，但它经常被证明是虚假的或矛盾的。</p></li><li><p><strong>辛迪·舍曼</strong>（1954 年出生）凭借《无题电影剧照》（1977-1980）系列，成为后现代戏仿与扮演艺术的早期代表，她想要讽刺的是好莱坞的男性沙文主义，在三年时间内，她生产出 69 幅宣传剧照式的黑白肖像摄影。 这位艺术家搜罗了她的化妆箱，创作出了一批虚构的女性角色，这些角色均是二流电影里被构想出来的，有美荡妇、妓女、性感女人、家庭主妇、冰美人。在舍曼的这个例子里，她的创作大体属于行为艺术和观念艺术领域，舍曼从照片中去掉一切关于个人特性的痕迹，她是所有图像中的明星，但又不存在，这就是后现代主义者喜爱的那种存在主义的矛盾，这可以追溯到超现实主义的心灵游戏和 1960 年代喜剧小说的象征主义哲学，比如库尔特·冯内古特的《第五屠宰场》和约瑟夫·海勒《第二十二条军规》。舍曼的变色龙艺术是对媒体和名流虚构、操纵公众形象手法的一种反思，这一形象不是基于某一个体的真实性格，而是基于市场的需求。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fospupsysnj31jk18c4qs.jpg" alt=""></p></li><li><p>因此当我们得知辛迪·舍曼 1977 年在现代艺术博物馆的展览的唯一赞助人是后现代的终极偶像和形象再造之母麦当娜时，也就丝毫不惊讶了。像舍曼一样，麦当娜在一系列经过淘气设计的黑白照片中担任明星，模仿了软色情世界里所刻画的那种老套的女性形象。以照片为媒介来玩弄假身份和隐喻这两个概念的人，还有加拿大艺术家<strong>杰夫·沃尔</strong>，创作了《损毁的房间》（1978），这是他的首幅反光摄影透明正片，当舍曼和麦当娜将好莱坞当做创作的主题时，沃尔却搜捕了 17、18、19 世纪伟大的欧洲画家的作品，就《损毁的房间》而言，是欧仁·德拉克洛瓦。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fospvlvr3vj30ku0e1qlq.jpg" alt=""></p><p>沃尔以极其细腻的手法重新创作了后现代版本的德拉克洛瓦的油画《萨丹纳帕路斯之死》（1827）。色彩、构图和光线几乎完美匹配，两幅作品都以一张双人床为中心，其周围一片混乱。德拉克洛瓦的绘画描绘的是东方古代国王萨丹纳帕路斯在遭受一场军事失败后，下令屠杀他的奴隶和女人，画面中充满了众多因极度痛苦而扭动的人体和马匹，而国王则躺在床上冷漠地看待这一切。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fospw1kbd7j30nn0iskjl.jpg" alt=""></p><p>而沃尔的作品却描绘了一幅没有任何人物的图景，相反，他展示了一间属于一个妓女的卧室，廉价，现代，无特色，刚遭洗劫和破坏，其精妙的设计与德拉克洛瓦作品的构图方法遥相呼应，两幅作品均描绘了一个曾经乐观和英勇的社会所处的幻灭和衰败状态。</p><p>了解这些典故能让我们更好地享受沃尔的照片，后现代主义奖励知识的方式，就像是纵横填字游戏，在破解谜题的过程中获取理解，它需要一个解构的过程，你拆解艺术家从各种资源借鉴来的元素，从而洞察作品的含义。</p><p>后现代艺术并不仅仅过一下眼瘾就算了，它总有更多的东西，以沃尔更著名的作品之一《模拟》（1982）为例，作品展示了两男一女走在阳光普照的街上。图像的中心将三名主要人物分隔开来，那对白人伴侣在距离中心几英寸的一侧，那位亚洲人则在离中心几乎相等距离的另一侧，这一设计是有意的，沃尔是在批评西方存在的种族隔离。除此之外，这是一张蓄意伪造的照片，沃尔采用了电影拍摄的规则并将它们用于摄影，而后利用背光灯广告牌的技术来展示作品，这件后现代艺术品的一切，都是由那些从别处获取和仿制的片段构建的。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fospx6utc9j30ku0i9kh2.jpg" alt=""></p><p>图中亚洲人的腿的形状和位置，与那位白人的腿形成镜像，而白人的腿又是其女友腿的镜像，而她的则是亚洲人的翻版。沃尔是在模仿画家古斯塔夫·卡耶伯特（1848-1894），一名与印象派有关的画家，瞥一眼他的《巴黎街道：雨天》（1877）你将会心一笑，两幅图像的右边都是一栋商业建筑，左边是一条道路，一直延伸，直至消失，两者都有三个主要人物没，身体相互呼应，两者都用一根街灯柱将主要人物和画面的其他部分隔开。沃尔照片中荒凉的街道背景是对现代主义之梦的讽刺性评论。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fospxm3gjsj30zk0qykjm.jpg" alt=""></p></li><li><p>现代主义棱角分明，后现代主义没有棱角，现代主义拒绝传统，后现代主义什么也不抗拒，现代主义注重线条和系统性，后现代主义则分散得七零八落，现代主义者相信未来，后现代主义者对很多事物抱以不相信的态度，现代主义者认真，具有冒险精神，后现代主义者是戏谑实验的大师，巧妙地表达不敬之意，超然世外般对现实冷嘲热讽。《辛普森一家》里面曾说：“后现代主义为了怪诞而怪诞。”这开启了他们与四分之一个世纪前波普艺术家所选择的同一个方向的征程：广告和商业界。</p><p><strong>芭芭拉·克鲁格</strong>（1954 年生）是康泰纳仕集团的平面设计师，该集团是全世界最高端的时尚杂志出版商，她裁剪杂志广告中引起她注意的图片，而后，用黑白两色对其重新制作，并在上面置放文字标语，如《我买故我在》（1987）和《你的身体是战场》（1989），像沃霍尔一样，她利用广告来阐释她的观点，与沃霍尔不同的是，她公开对这一行业进行批评。</p><center><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fospzwer14j30d50czguo.jpg" alt=""></center><p>克鲁格使用人称代词——我、我们、你——来吸引我们，并以强行推销中所使用的臆断之词把我们牵涉其中，作为一名后现代主义者，克鲁格在自己的作品中加入了许多其他的指涉，红色的字体来自罗琴科的构成主义海报，取自广告上的二手形象则是波普艺术的主要特征，采用的字体叫做未来型字体，是于 1927 年被创造出来的一种几何形图案，它遵循了包豪斯建筑学派严格的现代主义原则，未来主义并未被忘掉，克鲁格经常用未来型字体为语句添加马里内蒂的紧迫感和活力。</p><p>其次，她的作品中存在一种具有讽刺意味的文字游戏，使我们想到马赛尔·杜尚，达达主义者，没有什么比操纵语言来嘲弄权威和艺术界更让他们欢喜的了。1982 年，克鲁格在《无题》（《你投资杰作之神圣性》）中通过模仿广告招贴的商业做法，来质疑艺术界的商业行为。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fosq0n1ignj30zu1jknpf.jpg" alt=""></p><p>她的作品并不署名，排版也不带个人色彩，从而提出了作者身份、真实性、复制和身份等问题，这一切均是后现代主义的中心议题。她促使我们对大众媒体的消息和方法要三思而后信，还提醒我们要注意文字在艺术中的力量。</p><center><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fosq02qd1jj30dw0e0dt8.jpg" alt=""></center></li><li><p>后现代主义通过质疑、模仿和挪用来创作他们模棱两可的艺术，那些愿意花一些时间和精力去琢磨其微妙之处的人，将会得到启发，他们喜欢开玩笑，这会使他们的作品看起来琐碎、愚蠢和充满讥讽，最好的后现代艺术家来自聪明的局外人的观察，在他眼中，既怀有钦佩，有抱有厌恶，实际上，所有优秀的艺术都是如此。</p></li></ul><h2 id="今日艺术：名利场-1988-2008-至今"><a href="#今日艺术：名利场-1988-2008-至今" class="headerlink" title="今日艺术：名利场 1988-2008 至今"></a>今日艺术：名利场 1988-2008 至今</h2><ul><li><p>现在还没有公认的术语来描述 20 世纪末至 21 世纪初这二十年间产生的艺术，后现代主义是最后一个被正式认可的艺术运动，而它在 1980 年代末逐渐失去势头。过去的二十五年非同凡响，从未有如此多的现代艺术品诞生和收购，公众和媒体从未抱有如此大的兴趣，也从未有现在这么多的场所去欣赏艺术品，毕尔巴鄂的古根海姆博物馆、伦敦的泰特现代美术馆和罗马国立当代美术馆均在过去的十五年中拔地而起，我们正经历一场全球性的现代艺术大繁荣。</p></li><li><p>有一种明确的态度可以概括过去四分之一个世纪内所产生的大部分艺术，为了方便论证，我将设立一个时间框架，它并非一个明确的开始和结束点，自 1988 年至 2008 年，各有一个事件标志着它的开始和结束，而且都由同一个人发起，即英国艺术家<strong>达米恩·赫斯特</strong>（1965 年出生）。第一个事件是 1988 年 7 月在伦敦东南港区举办的一次名为“冻结”的夏季展览，展出的是 16 位在伦敦金史密斯学院与赫斯特一起学习的英国年轻艺术家的作品。这次展览被视为一个历史性的时刻，不过在当时，这只不过是一个来自英国北部籍籍无名的学生以令人钦佩的勇气和专业水准来推动和呈现的。自那时起，伦敦成为推动艺术向前发展的一支领导力量，正如 19 世纪末 20 世纪初的巴黎。</p><p>二十年后，还是这位学生，这一次只有他一人，展览在伦敦苏富比拍卖行的主销售厅进行，时间为 2008 年秋季，世界将为之折服。</p><p>赫斯特将他强大的英国经纪人（杰·乔普林）和美国经纪人（拉里·高古轩）从流程中剔除，将两百多件新作从工作室直接运到苏富比拍卖行直接拍卖，这是一个大胆冒险的行动，他给拍卖会起了一个展览式的名字：美丽永驻我心。最后拍卖大获成功，但这次拍卖和金融危机同时发生，无意中标志了资本主义的一个时代的终结，也标志了现代艺术里的一个终结，总结一下现代艺术的最新阶段：企业家主义。</p><p>通过 1988 年的“冻结”展，这些年轻艺术家首次公开宣言，他们开始掌控自己的命运。他们怀有一种企业家的精神，预示着他们创作的艺术。没有人比赫斯特更能以个人的方式来体现这种精神了，赫斯特努力成为一名好画家，但最终放弃了，他开始追求用雕塑的形式进行创作，他创作出了《一千年》（1990）和《生者对于死亡无动于衷》（1991）赫斯特和其他英国艺术家一样共享一种企业家似的世界观，他们意识到若想以自己的方式取得成功，需要创建基于作品又基于个人形象的品牌。伴随着安迪·沃霍尔的“好生意就是最好的艺术”在耳旁响起，他们找到了<strong>查尔斯·萨奇</strong>，他与他的兄弟一起，创建了萨奇&amp;萨奇广告公司，它成为世界上最成功的广告公司之一。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fosqc8pvcoj30lf0d7k20.jpg" alt=""></p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fosqcflt9tj30lf0eu7cd.jpg" alt=""></p><p>1985 年，查尔斯·萨奇在伦敦北郊开设了一个同名画廊，目的是展出和推销他搜集的当代艺术品，五年后，他们在艺术史中的声誉得到了巩固，，皇家艺术学院举办了一个查尔斯·萨奇的藏品展，并且有一个合适的名字：轰动。</p></li><li><p>其他八名来自赫斯特“冻结”展的艺术家参加了“轰动”的展出，其中一位是<strong>莎拉·卢卡斯</strong>，卢卡斯的雕塑可以是关于社会如何看待和描述女人和性的深刻评论，假小子风潮正横扫整个英国，她并非单枪匹马，她一个朋友的作品也在“轰动”展览上展出：终极假小子，<strong>翠西·艾敏</strong>（1963 年出生），和达米恩·赫斯特及许多英国青年艺术家一样，来自工薪阶层并深受其影响，她在刚刚能自食其力的时候便离开家乡，奔向伦敦去追寻命运。她的作品收藏在世界最著名的现代艺术博物馆（纽约现代艺术博物馆、法国现代艺术博物馆、英国泰特美术馆）而且，她是代表英国参加威尼斯双年展的仅有的两位女性。《我的床》（1998）这是一张翠西·艾敏的床，没有整理，乱糟糟，床单还带有污迹，地板上，空的酒瓶，烟头，肮脏的内衣。翠西·艾敏乱七八糟的床使她出了名，她变得声名狼藉，成了媒体既爱又狠的人，而她却把媒体操纵得驾轻就熟。</p></li></ul> <center><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fosqdj6vqdj30ac07f78l.jpg" alt=""></center><ul><li><p>此时在伦敦晃荡着的还有一个野心勃勃的人，<strong>杰·乔普林</strong>想成为一名拥有一间画廊的艺术经纪人，他引用美国艺术家布莱恩·奥多尔蒂（1934 年生）1976 年的一篇有影响的散文，叫做《白立方内》，作者在文中论述，比起展出的艺术作品，现代艺术画廊中枯燥无味的白墙更能塑造和操纵品味。他把自己的画廊称为“白立方”，既是对这一空间的描述，也是对当代艺术世界的嘲笑。</p><p>乔普林希望展览和出售自己同代人创作的艺术品，因此，于 1993 年白立方画廊开张六个月后，他推出了翠西·艾敏创作的自传性精品展，两颗明星诞生了，一颗是追求名声的艺术家，另一颗是机制灵敏的艺术经纪人，乔普林善于发现和培养人才，自从 1990 年代初全面启动后，白立方画廊已经成为新兴的英国艺术市场上最大、最具影响力的角色之一。</p></li><li><p>与此同时，<strong>拉里·高古轩</strong>——当代艺术品交易界的大佬——已建立一个空前强大的世界性帝国。销售高端艺术与销售高端房地产相差无几，两种生意都需要有位于高档场所的办事处或画廊，并安排展示，把作品印在精美的小册子相互传看，办公室和画廊的工作人员往往穿着考究，善于辞令。房地产和艺术都将独特性作为卖点，当决定一栋房子价格的是“地段、地段、地段”时，一件艺术品的价值则完全取决于“出处、出处、出处”。也就是说，谁创作的它，谁在出售的它，以及非常关键的它在哪个主要的当代艺术博物馆展出过。</p><p>母庸置疑的是，这位美国经纪人将艺术交易游戏提升到了另一个游戏水平，从 1970年代业务启动开始，到 70 年代结束时，他已在洛杉矶建立了一个画廊，80 年代，他迁往曼哈顿，并与<strong>里欧·卡斯特里</strong>结为朋友，后者在当时可是当代艺术交易市场的大佬，由于得到这位睿智老人的信任、帮助，高古轩很快建立起作为曼哈顿第一艺术经纪人的地位，今天他的画廊已散布世界各地。</p><p>他不仅是赫斯特的美国经纪人，还是其他两位商业型艺术家的代表人：<strong>杰夫·昆斯</strong>和<strong>村上隆</strong>（1962 年出生）。</p></li><li><p>村上是媚俗之王，他在各个方面都是一个艺术企业家，像一个成功的商业学院毕业生一样，抓住商机，建造他的全球帝国，而且，如同大多数当代艺术家一样，他以灵活的公关机器包装自己，建立起形象与品牌。</p><p>村上是日本流行视觉文化的采样器，正像霍沃尔和利希腾斯坦是 1960 年代美国流行文化的采样器一样，村上的参照物是动画和漫画，他将人物角色变成雕塑、绘画和商品销售。</p><p>日本的意象在现代艺术发展中起到了巨大的作用。印象派、后印象派、野兽派和立体派艺术家均从构图优美的 19 世纪日本浮世绘版画中寻找灵感和方向，随后爆发了两次世界大战，艺术世界西移至美国，使日本在当代舞台上处于消费者而不是参与者的地位，村上作品的目的是矫正这种平衡：将国产的日本的视觉文化推广到全世界，他利用全球化的工具——旅行、传媒、自由贸易——对本土性、原生性和文化特性表明自己的看法。</p></li><li><p>昆斯接过沃霍尔的接力棒，沃霍尔被名人文化的兴起吸引住，可涉及到他的艺术时，他却想方设法去掉自己的痕迹，昆斯不这样，他把自己加工成了一个名人，《天堂制造》系列中，他横卧着，全身赤裸，在他面前是一个被降服的脆弱的金发女郎，呈现出一种色情的屈服形象，这幅画暗示着亚当和夏娃的故事。</p><p>杰夫·昆斯大胆进取的路径推动了事业的进步，1985 年，他受到一个颇具冒险精神的纽约艺术空间“纪念国际画廊”的注意，他们决定为这位年轻艺术家举办一次展览，其中有一位来自中国的年轻艺术家，对这位美国人的企业家观念十分赞同，当艾未未（1957 年出生）在 1981 年离开北京前往纽约时，他的兜里只有 30 美元，并且一句英语也不会说。</p></li><li><p>艾未未是一个不平凡的人物，他是自我世界的中心，无畏而坚定，他在中国西北戈壁滩长大的那些日子里，没有书籍和学校让他消遣，反倒留给她足够的空间去思考。一次突发奇想，如果拍摄一系列他把一件陶器摔落在水泥地面上的照片，那会很有趣，他这样做了，并取名为《摔破一个汉代陶罐》（1995）。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fosqaxa00jj30ql0a44dh.jpg" alt=""></p></li><li><p>总的来说，这个时代里的先锋艺术家即使在最激进、最具挑战性的时候，也倾向于带着调皮的笑容而不是一脸怒容来呈现他们的作品，总趋势是为了取悦，而不是为了战斗，过去二十五年社会所发生的巨大变化几乎被忽视了，对于一个赢家通吃的资本主义时代，一个名声和财富高于一切的时代，几乎没有人评论：全球化和数字媒介对此的影响很少被提及，至于环境问题，政治和媒体的腐败，恐怖主义，宗教极端主义，乡村生活的瓦解，随着富人越富、穷人更穷的社会两极分化，以及银行家贪得无厌和冷酷无情。</p><p>也许艺术家的目光和心思已在别处，也许他们会感到需要妥协，成为一名艺术企业家的后果之一是，你会像任何从商的人一样，容易接受权宜的哲学，接受偶尔也要和魔鬼做交易的现实。</p><p>除非，你完全在市场之外进行操作，没有任何可失去的东西，而这就是街头艺术的状况，自从被斥为非法下层阶级的无聊行为，街头艺术和涂鸦便被认可为现代艺术的一部分。2008 年，在泰特现代美术馆北面巨大的立墙上，覆盖有六幅大型街头艺术作品，其中一幅由<strong>JR</strong>创作，他戏称自己为“摄影者”，并以此来描述他带有政治倾向的黑白照片，把他们贴到建筑物上，像壁画一样。</p><p>JR 对政治和社会公开进行评论，这种直接性，是街头艺术的一个共同要素，但贫困不是，人们普遍认为，所有街头艺术都来自一个被抛弃的下层阶级的愤怒呐喊，这种看法是偏离事实的，有史以来可能最著名的街头艺术是由一名非常成功的中产阶级平面设计师创作的，他就是<strong>谢泼德·费尔雷</strong>（1970 年出生），在 2008 年总统大选的准备阶段，他创作了支持当时的民主党候选人巴拉克·奥巴马的海报，以波普艺术的风格将其简化和程式化，与安迪·沃霍尔的丝网印刷很相似，费尔雷这一街头艺术作品已经成为奥巴马竞选的图标，并成为地球上最著名的肖像之一。</p><p>街头艺术之根源可追溯到史前的原始洞穴壁画，从毕加索到波洛克，众多的现代艺术家从中获取了灵感，但是直到 60 年代初 70 年代初，一些城市如纽约和巴黎变成一群非法的“视觉艺术家游击队”的“画布”时，街头艺术的概念才被推广开来，从那时开始，随着数字社会媒体的出现，街头艺术运动力量和声望也逐渐增加，二者均依靠病毒般的网络去获得重视和关注。</p></li><li><p>我猜想，如果马赛尔·杜尚今日仍在人世，他大概会成为一名街头艺术家，这位法国人的特立独行，在当下艺术的身上打上了深深的烙印。当代艺术家讲述到自己受到的影响时，他是我听说过的被提及最多的一个人。毕加索的画家个性主导了 19 世纪的上半叶，不过毫无疑问的是，其下半叶愈发是在杜尚式的心灵游戏的背景中落下了帷幕。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文整理自《现代艺术150年：一个未完成的故事》 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;泉-1917&quot;&gt;&lt;a href=&quot;#泉-1917&quot; class=&quot;headerlink&quot; title=&quot;泉 1917&quot;&gt;&lt;/a&gt;泉 1917&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>密码学</title>
    <link href="http://yoursite.com/2017/12/26/primaryCryptography/"/>
    <id>http://yoursite.com/2017/12/26/primaryCryptography/</id>
    <published>2017-12-25T16:00:00.000Z</published>
    <updated>2018-09-19T14:23:06.274Z</updated>
    
    <content type="html"><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script><blockquote><p>本文整理自《图解密码技术：第3版》</p></blockquote><h2 id="一、概览"><a href="#一、概览" class="headerlink" title="一、概览"></a>一、概览</h2><ul><li><p>六大密码技术：</p><p>（1）对称密码（symmetric cryptography）：加密和解密时使用<strong>同一密钥</strong>的方式。</p><p>（2） 公匙密码（asymmetric cryptography）：加密和解密时使用<strong>不同密钥</strong>的方式，也称为非对称密码，现代计算机和互联网体系很大程度上依赖于公钥密码。</p><p>（3） 单向散列函数（one-way hash function）：为防止软件遭到篡改，软件发布者会在发布软件的      同时发布散列值，散列值就是用单向散列函数计算所得。可保证数据<strong>完整性</strong>，可以检测数据是否被<strong>篡改</strong>过。</p><p>（4）消息认证码（message authentication code）：不但能确认消息是否被<strong>篡改</strong>过，而且能够确认消息是否来自所期待的通信对象，也就是<strong>认证</strong>机制。</p><p>（5） 数字签名（digital signature）：不仅能确保<strong>完整性</strong>、提供<strong>认证</strong>而且能够<strong>防止否认</strong>的密码技术。</p><p>（6） 伪随机数生成器（Pseudo Random Number Generator，PRNG）：一种能够模拟产生随机数的算法，承担着<strong>密钥生成</strong>的职责。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fmsuk5s0euj30sg0lcn0g.jpg" alt="1"></p></li><li><p>隐写术：密码是让消息变得无法解读，而隐写术是能够隐藏消息本身，数字水印技术就采用了隐写术的方法。</p></li><li><p>密码与信息安全常识：</p><p>（1）不要使用保密的密码算法。</p><p>（2）使用低强度的密码比不进行任何加密更危险。</p><p>（3）任何密码总有一天会被破解。</p><p>（4）密码只是信息安全的一部分。</p></li></ul><h2 id="二、简单密码"><a href="#二、简单密码" class="headerlink" title="二、简单密码"></a>二、简单密码</h2><ul><li><p>凯撒密码（Caesar cipher）：通过将明文所使用的字母表按照一定的字数平移来进行加密，可被<strong>暴力破解</strong>（brute-force attack）。</p></li><li><p>简单替换密码（simple substitution cipher）：将明文中所使用的字母表替换成另外一套字母表的密码，很难通过暴力破解，但可以使用<strong>频率分析</strong>来破解。</p></li><li><p>Enigma（谜）：一种由键盘、齿轮、电池和灯泡组成的机器，可完成加密和解密两种操作，使用了<strong>密钥加密密钥</strong>（Key Encrypting Key，KEK），即用通信密码加密消息，用每日密码来加密通信密码，最终被 Alan Turing 破解。</p></li></ul><h2 id="三、对称密码"><a href="#三、对称密码" class="headerlink" title="三、对称密码"></a>三、对称密码</h2><ul><li><p>编码（encoding）：将现实世界中的东西映射为<strong>比特序列</strong>的操作。</p></li><li><p>异或（Exclusive OR，XOR）：如果 a、b 两个值不相同，则异或结果为 1 ，如果 a、b 两个值相同，异或结果为 0 。</p></li><li><p>一次性密码本（one-time pad）：又称<strong>维纳密码</strong>（Vernam cipher），原理是将明文与一串随机的比特序列进行 XOR 运算，在理论上是无法破译的（香农于 1949 年通过数学方法加以证明）就算通过暴力破解，也<strong>无法得知结果是否是正确的明文</strong>。</p></li><li><p>流密码（stream cipher）：一次性密码本孕育出了流密码，流密码使用的并不是真正的随机比特序列，而是伪随机数生成器产生的比特序列，只要使用高性能的伪随机数生成器就能构建出强度较高的密码系统。</p></li><li><p>DES（Data Encryption Standard）：是 1977 年美国联邦信息处理标准（FIPS）中所采用的一种对称密码。DES 以 64 比特的明文（比特序列）为一个单位来进行加密，这个 64 比特的单位称为<strong>分组</strong>，以分组为单位进行处理的密码算法称为<strong>分组密码</strong>（block cipher），DES 每次只能加密 64 比特的数据，如果加密的明文较长，就需要对 DES 加密进行迭代，而迭代的具体方式称为<strong>模式</strong>。</p><p>DES 的基本结构是由 Horst Feistel 设计的，因此也被称为 <strong>Feistel 网络</strong>（结构/密码），在 Feistel 网络中，加密的各个步骤称为<strong>轮</strong>，整个加密过程就是进行若干次轮的循环，DES 是一种 16 轮循环的 Feistel 网络。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fmsuk5g3jlj30sg0lcac8.jpg" alt="2"></p><p>在 Feistel 网络中，每一轮都需要使用一个不同的子密钥，它只是一个局部密钥，因此才被称为子密钥（subkey）。</p><p>轮函数的作用是根据“右侧”和子密钥生成对“左侧”进行加密的比特序列，是整个密码系统的核心。</p><p>Feistel 网络的特点：</p><p>（1）轮数可以任意增加。</p><p>（2）加密时无论使用任何函数作为轮函数都可以正确解密。</p><p>（3）加密和解密可以用完全相同的结构来实现。</p></li><li><p>三重DES（triple-DES）：是为了增加 DES 的强度，将 DES 重复三次所得到的一种密码算法，也称为 TDEA（Triple Data Encryption Algorithm），通常缩写为 3DES 。</p><p> <img src="https://ws4.sinaimg.cn/large/006tNc79gy1fmsuk56u5ej30sg0lc41h.jpg" alt="3"></p><p> 从图中我们可以发现，三重 DES 并不是进行三次 DES 加密（加密—加密—加密），而是加密-<strong>解密</strong>-加密的过程，在加密算法中加入解密操作目的是为了让三重 DES 能够兼容普通的 DES ，这个方法由 IBM 设计，当三重 DES 中的所有密钥都相同时，三重 DES 也就等于普通的 DES 了，也就是说三重 DES 具有向下兼容性。</p><p> 三重 DES 目前还被银行等机构使用，但其处理速度不高，除了特别重视向下兼容性的情况外，很少被用于新的用途。</p></li><li><p>AES（Advanced Encrying Standard）：是取代前任 DES 而成为新标准的一种对称算法，Rijindael于 2000 年被选为新一代的标准密码算法—— AES 。DES 使用 Feistel 网络作为基本结构，而Rijindael 使用了 <strong>SPN 结构</strong>。</p><p>  加密过程：逐字节替换（SubBytes）——平移行（ShiftRows）——混合列（MixColumns）——与轮密匙进行XOR（AddRoundKey）</p></li></ul><h2 id="四、分组密码的模式"><a href="#四、分组密码的模式" class="headerlink" title="四、分组密码的模式"></a>四、分组密码的模式</h2><ul><li><p>分组密码（block cipher）：每次只能处理特定长度数据的一类密码算法。</p></li><li><p>流密码（stream cipher）：是对数据进行连续处理的一类密码算法，一般以 1 比特、8 比特或 32 比特为单位进行加密和解密的。分组密码处理完一个分组就结束了，因此不需要通过内部状态来记录加密的进度，相对地，流密码是对一串数据流进行连续处理，因此需要<strong>保持内部状态</strong>。</p></li><li><p>模式：分组密码算法只能加密固定长度的分组，但是我们需要加密的明文长度可能会超过分组密码的分组长度，这时就需要对分组密码算法进行迭代，以便将一段很长的明文全部加密，而<strong>迭代的方法</strong>就称为分组密码的模式。</p></li><li><p>电子密码本模式（Electronic CodeBook，ECB）：<strong>在 ECB 模式中，将明文分组加密之后的结果直接成为密文分组</strong>，相同的明文分组会转换为相同的密文分组，我们可以将其理解为一个巨大的“明文分组——密文分组”的对应表，因此被称为<strong>电子密码本模式</strong>。</p><p>   <img src="https://ws2.sinaimg.cn/large/006tNc79gy1fmsuk4wk7gj30sg0lcaep.jpg" alt="4"></p><p>  攻击方式：<strong>无需破译密文就能操纵明文</strong>。</p></li><li><p>密文分组链接模式（Cipher Block Chaining，CBC）：在 CBC 模式中，首先<strong>将明文分组与前一个密文分组进行 XOR 运算，然后再进行加密</strong>。</p><p>  <img src="https://ws2.sinaimg.cn/large/006tNc79gy1fmsuk4hxotj30sg0lcjxi.jpg" alt="5"></p><p>  初始化向量（Initialization Vector，IV）：每次加密时都会产生一个不同的比特序列来作为初始化向量。</p><p>  特点：</p><p>  （1）在 CBC 模式加密过程中，我们无法单独对一个中间的明文分组进行加密，需要<strong>凑齐</strong>之前的明文分组。</p><p>  （2）在 CBC 模式解密过程中，若有一个密文分组<strong>损坏</strong>了，只要密文分组的长度没有发生改变，则解密时最多只有两个分组受到数据损坏的影响。</p><p>  （3）在 CBC 模式解密过程中，若密文文组有一些比特<strong>缺失</strong>了，此时即便缺失了 1 比特，也会导致密文分组的长度发生改变，此后的分组发生错位，缺失比特的位置之后的密文分组也就全部无法解密了。</p><p>  应用实例：确保互联网通信安全的通信协议之一的 SSL/TLS 就是使用 CBC 模式进行加密的。</p><p>  攻击方式：</p><p>  （1）填充式攻击（Padding Oracle Attack）：是一种利用分组密码中的填充部分来进行攻击的方法。在分组密码中，当明文长度不为分组长度的整数倍时，需要在最后一个分组中填充一些数据凑满一个分组长度，攻击者会反复发送一段密文，每次发送都对填充的数据进行少许的改变，由于接收者在无法正确解密时会返回一个错误消息，攻击者通过这一错误消息可以获得一部分与明文有关的消息。</p><p>  （2）对初始化向量进行攻击：初始化向量必须使用不可预测的随机数。然而在 SSL/TLS 的 TLS 1.0 版本协议中 IV 并没有使用不可预测的随机数，而是使用了上一次 CBC 模式加密时的最后一个分组。</p><p>  （3）假设主动攻击者目的是通过修改密文来操纵解密后的明文，攻击者如果能够对初始化向量中的任意比特进行反转，则解密后得到的明文分组中相应的比特也会被反转，因为第一个明文分组会和初始化向量进行 XOR 运算。</p><p>但是如果想要对密文分组也进行同样的攻击就非常困难了，假设主动攻击者将密文分组 1 中的某个比特进行了反转，则明文分组 2 中的相应比特也会被反转，然后这 1 比特的变化却会对解密后的明文分组 1 中的多个比特造成影响，也就是说，只让明文分组 1 中主动攻击者所期待的特定比特发生变化是很困难的。</p></li><li><p>密文反馈模式（Cipher FeedBack，CFB）：在 CFB 模式中，前一个密文分组会被送回密码算法的输入端。在 ECB 模式和 CBC 模式中，明文分组都是通过密码算法进行加密的，而在 CFB 模式中，明文分组并没有通过密码算法加密。</p><p>  <img src="https://ws4.sinaimg.cn/large/006tNc79gy1fmsuk44gxkj30sg0lcgr3.jpg" alt="6"></p><p>CFB 模式与流密码：</p><p>CFB 模式与之前的一次性密码本十分相似，一次性密码本是通过将“明文”与“随机比特序列”进行 XOR 运算来生成“密文”的。CFB 模式则是通过将“明文分组”与“密码算法的输出”进行 XOR 运算来生成“密文分组”的。CFB 模式中由密码算法所生成的比特序列称为<strong>密钥流</strong>，密码算法相当于生成密钥流的伪随机数生成器。</p><p> 在 CFB 模式中，明文数据可以被逐比特加密，因此可以将 CFB 模式看作是一种使用分组密码来实现流密码的方式</p><p> 攻击方式：<strong>重放攻击</strong></p></li><li><p>输出反馈模式（Output-Feedback，OFB）：在 OFB 模式中，密码算法的输出会反馈到密码算法的输入中，因此被称为输出反馈模式。OFB 模式并不是通过密码算法对明文直接进行加密的，而是通过将“明文分组”和“密码算法的输出”进行异或来产生“密文分组”的，这一点上 OFB 模式和 CFB 模式很像。</p><p>  <img src="https://ws3.sinaimg.cn/large/006tNc79gy1fmsuk3ueq5j30sg0lc7a5.jpg" alt="7"></p><p>  OFB 模式与 CFB 模式的区别：在于两者密码算法的输入，前者密码算法的输入是密码算法的前一个输出，后者密码算法的输入是前一个密文分组，两者名称也因此不同。</p></li><li><p>计数器模式（CounTeR，CTR）：<strong>是一种通过将逐次累加的计数器进行加密来生成密匙流的流密码</strong>。</p><p>  <img src="https://ws3.sinaimg.cn/large/006tNc79gy1fmsuk3igkfj30sg0lctes.jpg" alt="8"><br>  CTR 模式中，每个分组对应一个逐次累加的计数器，并通过对计数器进行加密来生成密匙流，最终的密文分组是通过将计数器加密得到的比特序列，与明文分组 XOR 所得到的。</p><p>  由于计数器的值每次都不同，因此每个分组中将计数器进行加密所得到的密钥流也是不同的，也就是说，这种方法就是用分组密码来模拟生成随机的比特序列。</p><p>  特点：</p><p>  （1）加密和解密使用了完全相同的结构，因此在程序上容易实现，这一特点与同为流密码的 OFB 模式是一样的。</p><p>  （2）CTR 模式可以以任意顺序对分组进行加密和解密，因此在加密和解密时需要用到的“计数器”的值可以由 nonce 和分组序号直接计算出来，这一性质是 OFB 不具备的。</p><p>  （3）能够以任意顺序处理分组，意味能够实现并行计算，在支持并行计算的系统中，CTR的速度是最快的。</p><p>  错误与机密性方面：</p><p>  CTR 模式具备和 OFB 模式差不多的性质，假设 CTR 密文分组中有 1 个比特被反转了，则解密之后明文分组中仅有与之对应的比特会被反转，这一错误不会放大。换言之，主动攻击者可以利用通过反转密文分组中的某些比特，来引起解密之后的明文中相应比特发生反转，这一弱点和 OFB 模式是相同的。</p><p>  不过 CTR 模式具备一个比 OFB 模式要好的性质，在 OFB 模式中，如果对密钥流的一个分组进行加密后其结果碰巧和加密前是一样的，那么这一分组之后的密钥流就会变成同一值得不断反复，在 CTR 模式中就不存在这种问题。</p></li></ul><h2 id="五、公钥密码"><a href="#五、公钥密码" class="headerlink" title="五、公钥密码"></a>五、公钥密码</h2><ul><li><p>解决<strong>密钥配送问题</strong>的四个方法</p><p> （1）通过<strong>事先共享密钥</strong>来解决</p><p> （2）通过<strong>密钥分配中心</strong>来解决</p><p> （3）通过 <strong>Diffie-Hellman 密钥交换</strong>来解决</p><p> （4）通过<strong>公钥密码</strong>解决</p></li><li><p>公钥密码（public-key cryptography）：也被称为非对称密码（asymmetric cryptography）在公钥密码中，密钥分为加密密钥（<strong>公钥</strong>，可以公开）和解密密钥（<strong>私钥</strong>，不能公开）两种，发送者用加密密钥对消息进行加密，接受者用解密密钥对密文进行解密。公钥和私钥是一一对应的，一对公钥和私钥统称为密钥对。</p><p>公钥密码无法解决的问题：</p><p>（1）我们需要判断所得到的公钥是否正确合法，也就是<strong>公钥认证</strong>问题。</p><p>（2）处理<strong>速度</strong>只有对称密码的几百分之一。</p></li><li><p>时钟运算：</p><p>（1）加法：时针的指针向右旋转相当于做加法，不过不是单纯的加法，而是“除法求余数（mod）”</p><p>（2）减法：实际上是加法的逆运算，可将减法转换为加法。</p><p>（3）乘法：相当于加法的多次重复。</p><p>（4） 除法：实际上是乘法的逆运算，例如：7 × ■ mod 12 = 1，在乘法中我们的思路是“在 mod 12    的世界里，7 乘以几等于 1 ”。换句话就是“在 mod 12 的世界里，1 ÷ 7 等于几”。</p><p>我们再来看下面这个算式：</p><p>● × ■ mod 12 = 1</p><p>当我们把 mod 12 遮住的时候，我们发现 ● 与 ■ <strong>互为倒数</strong>，当然我们需要加上“在以 12 为模的世界中”这个条件。在 0 到 11 的数字中，有哪些数存在与之相应的倒数呢，实际上，时钟运算中“某个数是否存在倒数”这个问题，与公钥算法 RSA 中“一个公钥是否存在相对应的私钥”这个问题是直接相关的。</p><p>某个数是否存在倒数，可以通过这个数和 12 的最大公约数是否为 1 这个条件来判断，和 12 的最大公约数为 1 的数（5、7、11），在数学上称为“和 12 互质的数”，可以理解为“相对于 12 的质数”。</p><p>（5）乘方：相当于乘法的多次重复。</p><p>（6）对数：时钟运算中的对数称为<strong>离散对数</strong>，例如：7 <sup>■</sup> mod 13 = 8 ，尝试下来我们知道 ■ 为 9 ，当数字很大的时候，求离散对数就非常困难，能够快速求出离散对数的算法现在还没被发现，Diffie-Hellman 密钥交换协议以及 ElGamel 公钥算法中就运用了离散对数。</p></li><li><p>RSA：是目前使用最为广泛的公钥密码算法，名字是由它的三位开发者的姓氏首字母组成的，可被用于公钥密码和数字签名。</p><p>  <img src="https://ws2.sinaimg.cn/large/006tNc79gy1fmsuk37xabj30sg0lcq4y.jpg" alt="9"></p><p>  加密过程：</p><blockquote><p>密文 = 明文<sup><em>E</em></sup> mod <em>N</em></p></blockquote><p>  其中 <em>E</em>（Encryption） 和 <em>N</em>（Number） 是 RSA 加密的密钥，<strong>因此<em>E</em> 和 <em>N</em> 的组合就是公钥</strong>。 </p><p>  解密过程：</p><blockquote><p>明文 = 密文<sup><em>D</em></sup> mod <em>N</em></p></blockquote><p>  这里所使用的 <em>N</em> 与加密时使用的是一致的，<strong>因此<em>D</em>（Decryptio） 和 <em>N</em> 的组合就是私钥</strong>。</p><p>  由于 <em>E</em> 和 <em>N</em> 是公钥，<em>D</em> 和 <em>N</em> 是私钥，因此求 <em>E</em>、<em>N</em>、<em>D</em> 这三个数就是<strong>生成密钥对</strong>，生成步骤如下：</p><blockquote><p>（1）求 <em>N</em> ：</p></blockquote><blockquote><p>首先准备两个很大的质数 <em>p</em> 和 <em>q</em> 。 过小容易被破解，要求出这样大的质数，需要通过伪随机数生成器生成一个 512 比特大小的数，判断是不是质数，如果不是，则重新生成。</p></blockquote><blockquote><p>准备好之后，将这两个数相乘，其结果就是 <em>N</em> ，可用以下公示表达。</p></blockquote><blockquote><p><em>N</em> = <em>p</em> × <em>q</em></p></blockquote><blockquote><p>（2）求 <em>L</em> （只在生成密钥对的过程中出现）：</p></blockquote><blockquote><p><em>L</em> 是 <em>p</em> -1和 <em>q</em> -1的最小公倍数（least common multple，lcm），如果用 lcm(<em>X</em>,<em>Y</em> ) 来表示“ <em>X</em> 与 <em>Y</em> 的最小公倍数”，则 <em>L</em> 可以写成以下形式。</p></blockquote><blockquote><p><em>L</em> = lcm(<em>p</em> -1, <em>q</em> -1)     </p></blockquote><blockquote><p>（3）求 <em>E</em> ：</p></blockquote><blockquote><p><em>E</em> 是一个比 1 大、比 <em>L</em> 小的数，此外 <em>E</em> 和 <em>L</em> 的最大公约数（greatest common divisor，gcd）必须为1。如果用 gcd(<em>X</em>,<em>Y</em> ) 来表示 <em>X</em> 和 <em>Y</em> 的最大公约数，则 <em>E</em> 和 <em>L</em> 存在以下关系。</p></blockquote><blockquote><p>1 &lt; <em>E</em> &lt; <em>L</em></p></blockquote><blockquote><p>gcd(<em>E</em>, <em>L</em>) = 1</p></blockquote><blockquote><p>使用伪随机数生成器，在 1 &lt; <em>E</em> &lt; <em>L</em>范围内生成 <em>E</em> 的候选数，然后再判断是否满足 gcd(<em>E</em>, <em>L</em>) = 1 这个条件。</p></blockquote><blockquote><p>（4）求 <em>D</em> :</p></blockquote><blockquote><p>数 <em>D</em> 是由数 <em>E</em> 计算得到的。<em>D</em> 、 <em>E</em> 、 <em>L</em> 之间必须具备下列关系。</p></blockquote><blockquote><p>1 &lt; <em>D</em> &lt; <em>L</em></p></blockquote><blockquote><p><em>E</em> × <em>D</em> mod <em>L</em> = 1</p></blockquote><blockquote><p>只要满足以上条件，则通过 <em>E</em> 和 <em>N</em> 进行加密的密文，就可以通过 <em>D</em> 和 <em>N</em> 进行解密。</p></blockquote><p>  对 RSA 的攻击：</p><p>  （1）通过密文求得明文：RSA 的加密过程如下，由于密码破译者知道密文、<em>E</em> 、<em>N</em> ，如果没有 mod <em>N</em> 的话就会变成看作是一个求对数的问题，但是加上 mod <em>N</em> 的话，就会变成一个求离散对数的问题，目前还没发现求离散对数的高效算法。</p><blockquote><p>密文 = 明文<sup><em>E</em></sup> mod <em>N</em></p></blockquote><blockquote><p>密文 = 明文<sup><em>E</em></sup> <del>mod <em>N</em></del></p></blockquote><p>  （2）通过暴力破解：只要能知道 <em>D</em> 就能对密文进行破解，因此我们可以逐一尝试有可能作为 <em>D</em> 的数字来破译 RSA ，也就是暴力破解法。但暴力破解的难度会随着 <em>D</em> 长度的增加而变大，当 <em>D</em> 足够长的时候就不可能在现实的时间内通过暴力破解找出 <em>D</em> 。</p><p>   现在，RSA 中使用的 <em>p</em> 和 <em>q</em> 的长度都是 1024 比特以上，<em>N</em> 的长度为 2048 比特以上，由于 <em>E</em> 和 <em>D</em> 的长度可以和 <em>N</em> 差不多，因此要找出 <em>D</em> 就需要进行 2048 比特以上的暴力破解，这样的长度下暴力破解是很困难的。</p><p>   （3）通过 <em>E</em> 和 <em>N</em> 求出 <em>D</em>：密码破译者不知道 <em>D</em> ，但是却知道公钥中的 <em>E</em> 和 <em>N</em> ，回忆一下生成密钥对的方法：</p><blockquote><p><em>E</em> × <em>D</em> mod <em>L</em> = 1</p></blockquote><p>   出现的数字是<em>L</em> ， 而 <em>L</em> 是 = lcm(<em>p</em> -1, <em>q</em> -1)，可以看出由 <em>E</em> 计算 <em>D</em> 需要使用 <em>p</em> 和 <em>q</em> ，因此<strong>质数 <em>p</em> 和 <em>q</em> 不能被密码破译者知道</strong>，把 <em>p</em> 和 <em>q</em> 交给密码破译者与把私钥交给密码破译者是等价的。</p><p>   <em>p</em> 和 <em>q</em> 不能被密码破译者知道，但是 <em>N</em> = <em>p</em> × <em>q</em> ，并且 <em>N</em> 是公开的，因此由 <em>N</em> 求 <em>p</em> 和 <em>q</em> 只能通过将 <em>N</em> 进行<strong>质因数分解</strong>来完成，<strong>一旦发现了对大整数进行质因数分解的高效算法，RSA 就能够被破解</strong>，然而现在还未发现此类高效算法。</p><p>   即使不进行质因数分解，密码破译者还是有可能知道 <em>p</em> 和 <em>q</em> 。由于 <em>p</em> 和 <em>q</em> 是通过伪随机数生成器产生的，一旦伪随机数生成器的算法很差，密码破译者就很有可能推测出来。</p><p>   （4）中间人攻击（man-in-the-middle-attack）：这种方法虽然不能破译 RSA ，但却是一种针对机密性的有效攻击，所谓中间人攻击，就是主动攻击者混入发送者和接受者的中间，对发送者伪装成接受者，对接受者伪装成发送者的攻击方式。要防御中间人攻击我们需要一种手段确认所收到的公钥是否是真正的发送者发来的，也就是公钥的证书。</p><p>   （5）选择密文攻击（Chosen Ciphertext Attack）：我们假设攻击者可以使用这样一种服务，即“发送任意数据，服务器都会将其当做密文来解密并返回解密的结果”，这种服务被称为<strong>解密提示</strong>（Decryption Oracle）。攻击者可以生成不同的数据，并让解密提示来尝试解密，从而获得生成密文时使用的密钥以及和明文有关的信息，反过来说，如果一种密码算法能够抵御选择密文攻击，则我们就可以认为这种算法的强度很高。</p><p>   只要我们在解密时能够判断“密文是否是由知道明文的人通过合法的方式产生的”就可以了，也就是认证。RSA-OAEP（Optimal Asymmetric Encryption Padding，最优非对称加密填充）正是基于上述思路设计的一种 RSA 改良算法。</p><p>   RSA-OAEP在加密时会在明文前面填充一些认证信息，包括明文的散列值以及一定数量的 0 ，然后再对填充后的明文进行 RSA 加密。在 RSA-OAEP 解密过程中，如果在 RSA 解密后的数据的开头没有找到正确的认证信息，则可以判定“这段密文不是由知道明文的人生成的”，并返回错误提示，因此能够抵御选择密文攻击。在实际运用中，还会通过随机数使得每次生成的密文呈现不同的排列方式，从而提高安全性。</p></li><li><p>其他公钥密码算法：</p><p>（1）ElGamal 方式：RSA 利用了质因数分解的困难度，而 ElGamal 则利用了 mod <em>N</em> 下求离散对数的困难度。</p><p>（2）Rabin 方式：利用了 mod <em>N</em> 下求平方根的困难度。</p><p>（3）椭圆曲线密码（Elliptic Curve Cryptography，ECC）：利用了在椭圆曲线上乘法运算的逆运算非常难这一特点。</p></li></ul><h2 id="六、混合密码"><a href="#六、混合密码" class="headerlink" title="六、混合密码"></a>六、混合密码</h2><ul><li><p>公钥密码的两大缺陷：</p><p>（1）处理速度远低于对称密码（解决方法：混合密码）</p><p>（2）难以抵御中间人攻击（解决方法：认证）</p></li><li><p>混合密码系统（hybrid cryptosystem）：用快速的对称密码来加密消息，用公钥密码加密对称密码的密钥。混合密码系统解决了公钥密码速度慢的问题、并通过公钥密码解决了对称密码的密钥配送问题。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fmsuk2xlotj30sg0lcwie.jpg" alt="10"></p></li><li><p>应用实例：著名的密码软件 PGP 、以及网络上的密码通信所使用的 SSL/TLS 都运用了混合密码技术。</p></li></ul><h2 id="七、单向散列函数"><a href="#七、单向散列函数" class="headerlink" title="七、单向散列函数"></a>七、单向散列函数</h2><ul><li><p>单向散列函数（one-way hash function）：有一个输入和输出，输入被称为<strong>消息</strong>，输出被称为<strong>散列值</strong>（hash value），单向散列函数可以根据消息的内容计算出散列值，用来检查消息的<strong>完整性</strong>。</p></li><li><p>单向散列函数的性质：</p><p>（1）根据任意长度的消息计算出固定长度的散列值。</p><p>（2）快速计算散列值。</p><p>（3）消息不同，散列值不同。 </p><p>（4）单向性，无法通过散列值反算出消息的性质。</p></li><li><p>碰撞（collision）：两个不同的消息产生同一个散列值的情况称为“碰撞”。</p></li><li><p>抗碰撞性（collision resistance）：难以发现发现碰撞的性质。</p></li><li><p>弱抗碰撞性：找到和该条消息具有相同散列值的另外一条消息是非常困难的性质。</p></li><li><p>强抗碰撞性：找到散列值相同的两条不同的消息是非常困难的性质。密码技术中所使用的单向散列函数，不仅要具备弱抗碰撞性，还必须具备强抗碰撞性。</p></li><li><p>术语：<strong>单向散列函数</strong>也称<strong>消息摘要函数</strong>（message digest function）、<strong>哈希函数</strong>、<strong>杂凑函数</strong>。<strong>消息</strong>也被称为<strong>原像</strong>（pre-image），<strong>散列值</strong>也被称为<strong>消息摘要</strong>、<strong>指纹</strong>（fingerprint），<strong>完整性</strong>也被称为<strong>一致性</strong>。</p></li><li><p>应用实例：</p><p>（1）检测软件是否被篡改</p><p>（2）用于基于口令的加密（Password Based Encryption，PBE）PBE的原理是将口令和盐（salt，通过伪随机生成器产生的随机值）混合后计算其散列值，然后将这个散列值作为加密的密钥，通过这样的方法能够有效防御针对口令的字典攻击。</p><p>（3）构造消息认证码</p><p>（4）构造数字签名</p><p>（5）构造伪随机数生成器</p><p>（6）构造一次性口令（one-time password），一次性口令被用于服务器对客户端的合法性认证，使用单向散列函数可以保证口令只在通信链路上传送一次，即使被窃听了口令，也无法使用。</p></li></ul><ul><li><p>传统单向散列函数：</p><p> （1）MD4、MD5：两者分别是 Rivest 于 1990、1991 年设计的单向散列函数，能够产生 128 比特的散列值，MD是消息摘要（Message Digest）的缩写，现均已被攻破。</p><p> （2）SHA-1：SHA-1是由NIST（National Institute of Standards and Technology，美国国家标准技术研究所）设计的一种能够产生 160 比特的散列值的单向散列函数，已被攻破。</p><p> （3）SHA-256、SHA-384、SHA-512：由NIST设计的单向散列函数，统称为 SHA-2 ，抗碰撞性尚未攻破。</p><p> （4）RIPEMD-160：是于 1996 年设计的一种能够产生 160 比特散列值的单向散列函数，RIPEMD-160 是欧盟 RIPE 项目所设计的 RIPEMD 单向散列函数的修订版，这一系列的函数还包括RIPEMD-128、RIPEMD-25 、RIPEMD-320 等，RIPEMD 的强抗碰撞性已被攻破，但RIPEMD-160尚未攻破，比特币中使用的就是 RIPEMD-160 。</p></li><li><p>SHA-3（Secure Hash Algorithm-3）：在 2005 年 SHA-1 被攻破的背景下，NIST 开始着手制定下一代单向散列函数 SHA-3，最终于 2012 年正式确定将 Keccak 算法作为 SHA-3 标准。</p><p>Keccak 可以生成任意长度的散列值，但为了配合 SHA-2 的散列长度，SHA-3 标准中共规定了 SHA3-224、SHA3-256、SHA3-384、SHA3-512 这 4 种版本。输入数据方面 SHA-3 无长度限制。</p><p>（1）海绵结构：Keccak 采用了与 SHA-1 、SHA-2 完全不同的<strong>海绵结构</strong>（sponge construction），在海绵结构中，输入的数据在进行填充之后，要经过<strong>吸收阶段</strong>（absorbing phase）和<strong>挤出阶段</strong>（squeezing phase），最终生成输出的散列值。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fmsuk2l3d6j30sg0lc42l.jpg" alt="11"></p><p>函数 <em>f</em> 的作用是将输入的数据进行复杂的搅拌操作并输出结果（输入和输出的长度均为 <em>b</em> = <em>r</em> + <em>c</em> 个比特），其操作对象是长度为 <em>b</em> = <em>r</em> + <em>c</em> 个比特的内部状态，内部状态的初始值为 0 ，也就是说，通过反复将输入分组的内容搅拌进来，整个消息就会被一点一点地吸收到海绵的内部结构中，每次吸收的输入分组长度为 <em>r</em> 个比特，因此 <em>r</em> 被称为<strong>比特率</strong>（bit rate）</p><p>函数 <em>f</em> 的输入长度并不是 <em>r</em> 个比特，而是 <em>r</em> + <em>c</em> 个比特，这意味着内部状态中有 <em>c</em> 个比特是不受输入分组内容的直接影响的（但会受到函数 <em>f</em> 的简介影响），这里的 <em>c</em> 被称为<strong>容量</strong>（capacity）。</p><p>在挤出阶段中，内部状态 <em>r</em> + <em>c</em> 个比特的容量（ <em>c</em> 个比特）部分是不会直接进入输出分组的，这部分数据只会通过函数 <em>f</em> 间接影响输出的内容，因此容量 <em>c</em> 的意义在于防止将输入消息中的一些特征泄漏出去。</p><p>（2）双工结构：作为海绵结构的变形，Keccak 中还提出了一种双工结构。在海绵结构中，只要将输入的消息全部吸收完毕后之后才能输出，但在双工结构中，输入和输出是以相同的速率进行的。</p><p>（3）对 Keccak 的攻击：Keccak 之前的单向散列函数都是通过循环执行压缩函数的方式来生成散列值的，称为 <strong>MD 结构</strong>（Merkle-Damagard construction）。MD4、MD5、RIPEMD、RIPEMD-160、SHA-1、SHA-2 等几乎所有的传统的单向散列函数算法都是基于 MD 结构的。而 Keccak 则采用了和 MD 结构完全不同的海绵结构，因此目前为止还未出现能对 Keccak 算法形成威胁的攻击方法。</p></li><li><p>对单向散列函数的攻击：</p><p>（1）暴力破解：利用文件的<strong>冗余性</strong>生成具有相同散列值的另一个文件，所谓冗余性就是指不改变文档意思的前提下能够对文件的内容进行修改的程度。现在我们需要寻找的是一条具备特定散列值的消息。这相当于<strong>试图破解单向散列函数的“弱抗碰撞性”的攻击</strong>。找出具有指定散列值的消息的攻击分为两种，即“原像攻击“和”第二原像攻击”。<strong>原像攻击</strong>（Pre-Image Attack）是指给定一个散列值，找出具有该散列值的任意消息。<strong>第二原像攻击</strong>（Secend Pre-Image Attack）是指定一条消息 1 ，找出另外一条消息 2 ，消息 2 的散列值和消息 1 相同。</p><p>（2）生日攻击：要找到散列值相同的两条消息，散列值可以是任意的，这样的攻击被称为<strong>生日攻击</strong>或<strong>冲突攻击</strong>（collision attack）”，这是一种<strong>试图破解单向散列函数的“强碰撞性”的攻击</strong>。</p></li><li><p>单向散列函数无法解决的问题：<strong>能够辨认出篡改，并无法辨认出伪装</strong>，因此我们需要认证。</p></li></ul><h2 id="八、消息认证码"><a href="#八、消息认证码" class="headerlink" title="八、消息认证码"></a>八、消息认证码</h2><ul><li><p>消息认证码（Message Authentication Code，MAC）：是一种确认完整性并认证的技术。</p><p>消息认证码的输入包括任意长度的消息和一个发送者与接收者之间的共享的密钥，它可以输出固定长度的数据，这个数据被称为 <strong>MAC 值</strong>。</p><p>根据任意长度的消息输出固定长度的数据，这一点和单向散列函数很像，因此可以理解<strong>消息认证码是一种与密钥相关的单向散列函数</strong>。</p></li><li><p>应用实例：</p><p>（1）SWIFT（Society for Worldwide Interbank Financial Telecommunication，环球银行金融电信协会），1973年成立的国际组织，目的是为国际银行间的交易保驾护航，银行与银行之间就是通过SWIFT 来传递消息，SWIFT 中使用了消息认证码。</p><p>（2）IPsec：是对互联网基本协议——IP 协议（Internet Protocol）增加安全的一种方式，在 IPsec中，对通信内容的认证和完整性校验都是采用消息认证码来完成的。</p><p>（3）SSL / TLS：对通信内容的认证和完整性校验也使用了消息认证码。</p></li><li><p>实现方法：</p><p>（1）使用<strong>单向散列函数</strong>实现：使用 SHA-2 之类的单向散列函数就可以实现消息认证码，其中一种实现方法称为 HMAC 。</p><p>（2）使用<strong>分组密码</strong>实现：使用 AES 之类的分组密码也可以实现消息认证码，将分组密码的密钥作为消息认证码的共享密钥来使用，并用 CBC 模式将消息全部加密，此外初始化向量（IV）是固定的。因为 CBC 模式的最后一个密文分组会受到整个信息以及密钥的双重影响，因此我们可以将它作为消息认证码，将除最后一个分组以外的密文部分全部丢弃。例如：AES-CMAC 就是一种基于 AES 实现的消息认证码。</p></li><li><p>HMAC：是一种使用单向散列函数来构造消息认证码的方法（RFC2104），其中 HMAC 的 H 就是 Hash 的意思。</p><p>  <img src="https://ws3.sinaimg.cn/large/006tNc79gy1fmsuk2b6qfj30sg0lcdi4.jpg" alt="12"></p><p>HMAC 中所使用的单向散列函数并不仅限于一种，任何高强度的单向散列函数都可以被用于 HMAC，使用 SHA1、SHA-224、SHA-256、SHA-384、SHA-512 所构造的 HMAC ，分别被称为HMAC-SHA1、HMAC-SHA-224、HMAC-SHA-256、HMAC-SHA-384、HMAC-SHA-512 。</p><p>实现原理：</p><p>（1）密钥填充：如果密钥比单向散列函数的分组长度要短，就需要在末尾填充 0 ，直到长度达到单向散列函数的分组长度为止。如果密钥比分组长度要长，则要单向散列函数求出密钥的散列值，然后将这个散列值用作 HMAC 的密钥。</p><p>（2）将填充后的密钥与被称为 <strong>ipad</strong> 的比特序列进行 XOR 运算：ipad 是将 00110110 这一比特序列不断循环往复直到达到分组长度所形成的比特序列，其中 ipad 的 i 代表 inner（内部）的意思。</p><p>XOR 运算所得到的值，就是一个和单向散列函数的分组长度相同，且和<strong>密钥相关的比特序列</strong>，称为 ipadkey 。</p><p>（3）与消息组合：也就是将比特序列（ipadkey）依附在消息的开头。</p><p>（4）输入单向散列函数，计算散列值。</p><p>（5）将填充后的密钥与被称为 <strong>opad</strong> 的比特序列进行 XOR 运算：opad 是将 01011100 这一比特序列不断循环往复直到达到分组长度所形成的比特序列，其中 opad 的 o 代表 outer（内部）的意思。</p><p>XOR 运算所得到的值，就是一个和单向散列函数的分组长度相同，且和密钥相关的比特序列，称为 opadkey 。</p><p>（6）将散列值拼在 opadkey 后面。</p><p>（7）输入单向散列函数，计算散列值，这就是最终的 MAC 值，一个和输入的消息和密钥都相关的长度固定的比特序列。</p></li><li><p>认证加密：2000以后，关于认证加密（Authenticated Encryption，AE，Authenticated Encryption with Associated Data，AD）的研究逐渐展开，认证加密是一种将对称密码和消息认证码相结合，同时满足机密性、完整性和认证三大功能的机制。</p><p>有一种认证加密方式叫作 Encrypt-then-MAC ，这种方式是先用对称密码将明文加密，然后计算密文的MAC值，另外还有 Encypt-and-MAC（将明文用对称密码加密，并对明文计算 MAC 值）和 MAC-then-Encrypt（先计算明文的 MAC 值，然后将明文和 MAC 值同时用对称密码加密）。</p><p>GCM（Galois/Counter Mode）是一种认证加密方式，GCM 中使用 AES 等 128 比特分组密码的 CTR 模式，并使用了一个反复进行加法和乘法运算的散列函数来计算 MAC 值，由于 CTR 模式本质是对递增的计数器值进行加密，因此可通过对若凡分组进行并行处理来提高速度，并且 CTR 模式加密与 MAC 值得计算使用的是相同的密钥，因此密钥管理也十分方便。</p></li><li><p>对消息认证码的攻击：</p><p>（1）重放攻击：通过事先保存的正确的 MAC 值不断重放来发动攻击。（可以使用序号、时间戳、nonce 来防御重放攻击）</p><p>（2）密钥推测攻击：和单向散列函数一样，对消息认证码也可以进行<strong>暴力破解</strong>和<strong>生日攻击</strong>，对于消息认证码来说，应该保证<strong>不能根据 MAC 值推测出通信双方所使用的密钥</strong>。此外生成消息认证码所使用的密钥，必须使用高强度的伪随机数生成器。</p></li><li><p>消息认证码无法解决的问题：</p><p>（1）无法对第三方证明</p><p>（2）无法防止否认</p></li></ul><h2 id="九、数字签名"><a href="#九、数字签名" class="headerlink" title="九、数字签名"></a>九、数字签名</h2><ul><li><p>数字签名（digital signature）：在数字签名中出现了两种行为，<strong>生成签名</strong>的行为和<strong>验证签名</strong>的行为。其中使用签名密钥来生成签名，使用验证密钥来验证签名。  数字签名对这两种密钥做了区分，使用验证密钥无法生成签名，此外，<strong>签名密钥只能由签名的人持有，而验证密钥则是任何需要验证签名的人都可以持有</strong>。 </p><p>实际上，数字签名就是通过将公钥密钥反过来实现的。</p></li></ul><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">私钥</th><th style="text-align:center">公钥</th></tr></thead><tbody><tr><td style="text-align:center">公钥密码</td><td style="text-align:center">接受者解密时使用</td><td style="text-align:center">发送者加密时使用</td></tr><tr><td style="text-align:center">数字签名</td><td style="text-align:center">签名者生成签名时使用</td><td style="text-align:center">验证者验证签名时使用</td></tr><tr><td style="text-align:center">谁持有密钥？</td><td style="text-align:center">个人持有</td><td style="text-align:center">只要需要任何人可以持有</td></tr></tbody></table><ul><li><p>实现方法：</p><p>（1）直接对消息签名的方法（实际上并不会使用）</p><p>（2）对消息的散列值签名的方法（实际上会使用）</p><p>   <img src="https://ws4.sinaimg.cn/large/006tNc79gy1fmsuk1zccnj30sg0lcq5j.jpg" alt="13"></p></li><li><p>对数字签名的疑问：</p><p>（1）密文为什么能作为签名使用？</p><p>数字签名是利用了“没有私钥的人事实上无法生成使用该私钥所生成的密文”这一性质来实现的，这里所生成的密文并非被用于确保机密性，而是被用于代表一种只有持有该密钥的人才能生成的信息。这样的信息被称为认证符号（authenticator），消息认证码也是认证符号的一种，数字签名也是一样。</p><p>（2）数字签名能保证机密性吗？</p><p>数字签名的作用本来就不是确保机密性。</p><p>（3）数字签名被复制之后，还可以用作签名吗？</p><p>签名可以被复制，并不意味着签名会失去意义，因为签名所表达的意义是特定的签名者对特定的消息进行了签名，即便签名被复制，也并不会改变签名者和消息的内容。并且，签名是不是原件不重要，重要的是特定的签名者与特定的消息绑定在了一起这一事实。</p><p>（4）消息会不会被任意修改？</p><p>数字签名要实现的并不是防止修改，而是识别修改。</p><p>（5）能不能同时修改消息和签名，使得验证签名成功？</p><p>只要消息被修改 1 比特，重新计算散列值就会发生很大的变化，要拼凑出合法的签名，必须在不知道私钥的前提下对新产生的散列值进行加密，事实上这是无法做到的，因为不知道私钥就无法生成用该私钥才能生成的密文。</p><p>（6）签名能不能被重复使用？</p><p>将签名部分提取出来并附加到别的消息后面，验证签名会失败。在数字签名中，签名与消息具有对应关系，因此事实上无法做到将签名提取出来重复使用。</p><p>（7）删除签名也无法作废合同吗？</p><p>带有数字签名的借据即便删除掉也无法作废，因为不知道其他地方是否留有副本，要作废带有数字签名的借据，可以重新创建一份相当于收据的文书，并让对方在这份文书上加上数字签名。</p><p>也可以在消息中声明该消息的有效期并加上数字签名。</p><p>（8）数字签名如何防止否认？</p><p>在数字签名中，能够生成签名的私钥是只有发送者才持有的，因此只有发送者才能够生成签名，无法进行否认，但严格来说，也存在私钥被窃取的情况。</p><p>（9）数字签名能否取代真实的签名与盖章？</p><p>美国于 2001 年颁布了 E-SIGN 法案，日本也于 2001 年颁布了电子签名及其认证业务的相关法律，我国于 2005 年颁布了《中华人民共和国电子签名法》，这些法律为将电子手段实现的签名与手写的签名和盖章同等处理提供了法律基础。数字签名在未来将发挥重要的作用，但是单纯地认为数字签名比普通的盖章或手写签名更可信是很危险的，一种新技术只有被广泛地认知，并对各种问题制定相应的解决方法之后，才能被社会真正地接受。</p></li><li><p>应用实例：</p><p>（1）安全信息公告: 信息发布的目的是尽量让更多的人知道，因此我们没有必要对信息进行加密，但是必须排除有人恶意伪装成该组织来发布假消息的风险，因此我们不加密消息，而只是对消息加上数字签名，这种对明文消息所施加的签名，一般称为明文签名（clearsign）</p><p>（2）软件下载：智能手机上广泛使用的 Android 系统是无法安装没有数字签名的应用软件的，在签署数字签名时，为了识别应用开发者的身份等信息，需要使用证书，这个证书只被用于识别应用开发者的身份等信息，并不是经过认证机构（Certificate Authority）签名的。不过数字签名只是能够检测软件是否被篡改过，无法保证软件本身不做出恶意行为。</p><p>（3）公钥证书：在验证数字签名时我们需要合法的公钥，那么怎么才知道我们的公钥是否合法呢，我们可以将公钥当做消息，对他加上数字签名，像这样对公钥施加数字签名所得到的就是公钥证书。</p><p>（4）SSL/TLS：在认证服务器身份是否合法时会使用服务器证书，它就是加上了数字签名的服务器公钥，相对地，服务器为了客户端进行认证也会使用客户端证书。</p></li></ul><ul><li><p>使用 RSA 实现数字签名：</p><p>用 RSA 生成签名</p><blockquote><p>签名 = 消息<sup><em>D</em></sup> mod <em>N</em></p></blockquote><p>其中 <em>D</em> 和 <em>N</em> 就是签名者的私钥，生成之后，将消息和签名发送给接受者。</p><p>用 RSA 验证签名</p><blockquote><p>由签名求得的消息 = 签名<sup><em>E</em></sup> mod <em>N</em></p></blockquote><p>其中 <em>E</em> 和 <em>N</em> 就是签名者的公钥，将“由签名求得的消息”与发送者直接发送而来的“消息”进行比对，两者一致则签名验证成功。</p></li><li><p>对数字签名的攻击：</p><p>（1）中间人攻击：对发送者伪装成接受者，对接受者伪装成发送者。</p><p>（2）对单向散列函数的攻击：数字签名中所使用的单向散列函数必须具有抗碰撞性，否则攻击者就可以生成另外一条不同的消息，使其与签名所绑定的消息具有相同的散列值。</p><p>（3）利用数字签名攻击公钥密码：</p><p>在 RSA 中，生成签名的公式是：</p><blockquote><p>签名 = 消息<sup><em>D</em></sup> mod <em>N</em></p></blockquote><p>这个公式和公钥密码中解密的操作是一样的，也就是说可以将“请对消息签名”这一请求理解成“请解密消息”。利用这一点攻击者可以发动一种巧妙的攻击，即利用数字签名来破译密文。</p><p>对于这样的攻击所采取的措施：首先不要直接对消息进行签名，对散列值进行签名比较安全。其次，公钥密码和数字签名最好分别使用不同的密钥对。最重要的是<strong>绝对不要对意思不清楚的消息进行签名</strong>。</p><p>（4）潜在伪造：如果攻击者能够生成合法的数字签名（即攻击者生成的签名能够正常通过校验），我们也应该将其当成是对这种签名算法的一种潜在威胁，这种情况被称为对数字签名的潜在伪造。</p><p>在用 RSA 来解密消息的数字签名算法中，潜在伪造是可能的，因为我们只要把随机比特序列 <em>S</em> 用 RSA 的公钥加密生成密文 <em>M</em> ，那么 <em>S</em> 就是 <em>M</em> 的合法数字签名，由于攻击者是可以获取公钥的，因此对数字签名进行潜在伪造也就可以实现。</p><p>为了应对潜在伪造，人们在改良 RSA 的基础上开发了一种签名算法，叫做 RSA-PSS（Probabilistic Signature Scheme）, RSA-PSS并不是对消息本身进行签名，而是对其散列值进行签名，另外为了提高安全性，在计算散列值的时候还要对消息加盐（salt）。</p><p>（5）其他攻击：针对公钥密码的攻击方法大部分都能够被用于攻击数字签名，例如暴力破解找出私钥，或者尝试对 RSA 的 N 进行质因数分解等。</p></li><li><p>其他数字签名：</p><p>（1）ElGamal 方式：利用了 mod <em>N</em> 中求离散对数的困难度，可被用于公钥密钥和数字签名。</p><p>（2）DSA（Digital Signature Algorithm）：是一种数字签名算法，是由 NIST（National Institute of Standards and Technology，美国国家标准技术研究所） 于 1991 年制定的数字签名规范（DSS）。</p><p>（3）ECDSA（Elliptic Curve Digital Signature Algorithm）：是一种利用椭圆曲线密码来实现的数字签名算法。</p><p>（4）Rabin 方式：利用了在 mod <em>N</em> 中求平方根的困难度，可被用于公钥密码和数字签名。 </p></li><li><p>数字签名无法解决的问题：使用数字签名我们同时实现了确认消息的完整性、进行认证以及防止否认，然而要正确使用数字签名，有一大前提就是用于验证签名的公钥必须属于真正的发送者，为了确认自己得到的公钥是否合法，我们需要证书，所谓证书，就是将公钥当作一条消息，由一个可信的第三方对其签名后得到的公钥。当然，这样只是把问题转移了而已，为了对证书上施加的数字签名进行验证，我们必定需要另一个公钥，如何才能构建一个可信的数字签名链条？又由谁来颁发可信的证书？因此我们需要让公钥以及数字签名成为一种社会性的基础设施，即公钥基础设施（Public Key Infrastructure，PKI）。</p></li></ul><h2 id="十、证书"><a href="#十、证书" class="headerlink" title="十、证书"></a>十、证书</h2><ul><li><p>公钥证书（Public-Key Certificate，PKC）：里面记录了姓名、组织、邮箱地址等个人信息，以及属于此人的公钥，并由<strong>认证机构</strong>（Certificate Authority、Certifying Authority，CA）施加数字签名，只要看到公钥证书，我们就可以知道认证机构认定该公钥确属于此人，公钥证书简称为<strong>证书</strong>（certificate）。有名的认证机构包括 <strong>VerSign</strong> 等。</p><p>  <img src="https://ws1.sinaimg.cn/large/006tNc79gy1fmsuk1pf4kj30sg0lctd6.jpg" alt="14"></p></li><li><p>证书标准规范：证书是由认证机构颁发的，使用者需要对证书进行验证，因此如果证书的格式千奇百怪那就不方便了，于是，人们制定了证书的标准规范，其中使用最为广泛的是由 ITU（International Telecommunication Union，国际电信联盟）和 ISO（International Organization for Standardization，国际标准化组织）制定的 X.509 规范，很多应用程序都支持 X.509 并将其作为证书生成和交换的标准规范。</p></li><li><p>公钥基础设施（Public-Key Infrastructure，PKI）：是为了更有效地运用公钥而制定的一系列规范和规格的总称，PKI 只是一个总称，而非指某一个单独的规范和规格。例如。RSA 公司所制定的 <strong>PKCS</strong>（Public-Key Cryptography Standards，公钥密码标准）系列规范也是 PKI 的一种，而互联网规格 <strong>RFC</strong>（Request for Comments）中也有很多与 PKI 相关的文档。此外 X.509 这样的规范也是 PKI 的一种。在开发 PKI 程序时所使用的由各个公司编写的 <strong>API</strong>（Application Programmming Interfere，应用程序编程接口）和规格设计书也可以算是 PKI 的相关规格。</p><p>PKI 的组成要素：</p><p>（1）用户：使用 PKI 的实体（人或计算机）。</p><p>（2）认证机构（Certificate Authority，CA）：是对证书进行管理的人。认证机构的工作中，公钥注册和本人身份认证这一部分可以由<strong>注册机构</strong>（Registration Authority，RA）来分担，这样一来，认证机构就可以将精力集中到颁发证书上，从而减轻了认证机构的负担，但这样也很可能增加攻击目标。</p><p>（3）仓库（repository）：是一个保存证书的数据库，PKI 用户在需要的时候可以从中获取证书，仓库也叫<strong>证书目录</strong>。</p><p>认证机构的工作：</p><p>（1）生成密钥对：有两种方式，一种是由 PKI 用户自行生成，一种是由认证机构来生成（认证机构会将私钥发送给用户）。</p><p>（2）注册证书：在用户自行生成密钥对的情况下，用户会请求认证机构来生成证书。认证机构根据其认证业务准则（Certificate Practice Statement，CPS）对用户的身份进行认证，并生成证书。在生成证书时，需要使用认证机构的私钥来进行数字签名，生成的证书格式是由 X.509 定义的。</p><p>（3）作废证书与 CRL ：当用户的私钥丢失、被盗、员工从公司离职失去使用私钥的使用权限，或者是名称变更导致和证书中记载的内容不一致等情况时，认证机构需要对证书进行<strong>作废</strong>（revoke）。</p><p>要作废证书，认证机构需要制作一张<strong>证书作废清单</strong>（Certificate Revocation List，CRL）。</p><p>CRL 是认证机构宣布作废的证书一览表，具体来说，是一张已作废的证书序列号的清单，并由认证机构加上数字签名，证书序列号是认证机构在颁发证书时所赋予的编号，在证书中会有记载。</p><p>PKI 用户需要从认证机构获取最新的 CRL ，并<strong>查询自己要用于验证签名（或者是用于加密）的公钥证书是否已经作废</strong>，这一步非常重要。</p><p>证书的层级结构：</p><p>对于用来验证数字签名的认证机构的公钥，可以由其他的认证机构施加数字签名，从而对认证机构的公钥进行验证，即生成一张<strong>认证机构的公钥证书</strong>。</p><p>一个认证机构来验证另一个认证机构的公钥，这样的关系可以迭代好几层，我们将最顶层的称之为<strong>根 CA</strong>（Root CA），对于根 CA 来说，则由它自己来颁发证书，这种对自己的公钥进行数字签名的行为称为<strong>自签名</strong>（self-signature）。</p><p>关于公钥基础设施的误解：认证机构只需要对公钥进行数字签名就可以了，因此任何人都可以成为认证机构。国家、地方政府、医院、图书馆等公共组织和团体可以成立认证机构来实现 PKI ，公司也可以在内部实现 PKI ，甚至你和你的朋友也可以。</p></li><li><p>对证书的攻击：</p><p>（1）在公钥注册之前进行攻击：主动攻击者可以在认证机构进行数字签名之前，将公钥替换为自己的（防止这种攻击，可以在将公钥发送给认证机构进行注册时，使用认证机构的公钥对即将发送的公钥进行加密。此外，认证机构在确认发送公钥者的身份的时候，也可以将公钥的指纹一并发送给发送者请他进行确认）</p><p>（2）注册相似人名进行攻击：证书是认证机构对公钥及持有者的信息加上数字签名的产物，对于一些相似的身份信息，计算机可以进行区别，但人类往往很容易认错，而这就可以被用来攻击（防止这种攻击，认证机构必须确认证书中所包含的信息是否真的属于其持有者的个人信息，当个人身份确认失败时则不向其颁发证书）。</p><p>（3）窃取认证机构的私钥进行攻击：认证机构是否妥善保管自己的私钥，是与该认证机构所颁发的证书的可信度密切相关的。由于认证机构记录了自己签发的证书的序列号，因此能够判断某个证书是不是该认证机构自己签发的。一旦认证机构的私钥被窃取，认证机构就需要将私钥泄露一事<strong>通过 CRL 通知用户</strong>。</p><p>（4）攻击者伪装成认证机构进行攻击：<strong>如果认证机构不可信，即便证书合法，其中的公钥也不能使用</strong>。</p><p>（5）钻 CRL 的空子进行攻击：</p><p>① 利用 CRL 的时间差来发动攻击：</p><p>主动攻击者 Mallory 黑掉了 Bob 的电脑，窃取了私钥，伪装成 Bob 给 Alice 发送了一封要求汇款的邮件，并用窃取的私钥进行了数字签名。第二天，Bob 发现电脑被黑，私钥被盗，急忙通知认证机构 Trent 自己的公钥已经失效。Trent 接到消息，将 Bob 密钥失效一事制成 CRL 并发布。然而，在发布 CRL 之前，Alice 收到了邮件，需要验证数字签名，Alice 用 Bob 的公钥进行了验证，结果成功了，而且公钥还带有认证机构 Trent 颁发的证书，于是 Alice 信任了邮件中的内容。</p><p>要防范上述这种攻击是非常困难的，因此对于这种攻击的对策是：</p><pre><code>当公钥失效时尽快通知认证机构 尽快发布 CRL 尽快更新 CRL 在使用公钥前，再次确认公钥是否已经失效。</code></pre><p>② 利用 CRL 的时间差来发动攻击：</p><p>Bob 是一个坏人，设想了一个从 Alice 手上骗钱的计划，用假名字开了一个账户，写了一封要求汇款的邮件给 Alice，并用私钥进行了数字签名。紧接着又向认证机构 Trent 发送了一封邮件告知自己的公钥已经失效。在从 Trent 处收到新的 CRL 证书之前，Alice 已经验证了签名并执行了汇款。Bob 赶快从用假名字开设的账户把钱取出来。Alice 收到 Trent 的 CRL 之后，大为震惊，于是尝试联系 Bob，Bob 当即进行否认，借自己的私钥被盗取，数字签名已失效完成否认。</p><p>要防止这种攻击是很困难的，尽管我们可以将签名的时间（timestamp）和发送公钥作废清单请求的时间进行比对，但是私钥泄露之后很久才发现也是很正常的，因此这种比对没什么意义。</p><p>在这个故事中，通过公钥、证书等技术无法是被出 Bob 的犯罪行为，必须依靠刑事侦查才行。为了快速确认证书是否已经失效，人们设计出了一种名为 OCSP 的协议。</p><p>虽然数字签名能够防止否认，但通过钻 CRL 的空子，就有可能<strong>实现否认</strong>。</p></li><li><p>对证书的疑问：</p><p>（1）为什么需要证书？</p><p>从认证机构获取公钥，就可以降低遭到中间人攻击的风险，因为带有证书的公钥是经过认证机构进行数字签名的，事实上无法篡改，但<strong>如果双方能够当面交换公钥则不需要认证机构</strong>。</p><p>（2）通过自己的方法进行认证是不是更安全？</p><p>自己开发保密的方法是犯了典型的<strong>隐蔽式安全</strong>（Security by obscurity）错误。</p><p>（3）为什么要信任认证机构？</p><p>即便认证机构是具有层级结构的，但实际上支撑“信任”关系的也不只是单纯的层级而已。不管证书的链条是否具有层级结构，我们之所以信任某个认证机构，是因为那是我们基于多个可信的情报源所做出的判断。</p></li></ul><h2 id="十一、密钥"><a href="#十一、密钥" class="headerlink" title="十一、密钥"></a>十一、密钥</h2><ul><li><p>密钥：在使用对称密码、公钥密码、消息认证码、数字签名等密码技术时，都需要一个称为<strong>密钥</strong>（key）的巨大数字，然而，数字本身的大小并不重要，重要的是<strong>密钥空间的大小</strong>，也就是可能出现的密钥的总数量，密钥空间越大，进行暴力破解就越困难。密钥空间的大小是由<strong>密钥长度</strong>决定的。</p><p><strong>密钥与明文是等价的</strong>。</p><p>信息的机密性不应该依靠密码算法本身，而更应该依赖于妥善保管的密钥。</p></li><li><p>密钥的分类：</p><p>（1）对称密码的密钥和公钥密码的密钥：在<strong>对称密码</strong>中，加密和解密使用同一个密钥，由于发送者和接受者之间需要共享密钥，因此对称密码又称为<strong>共享密钥密码</strong>。在<strong>公钥密码</strong>中，加密和解密使用的是不同的密钥，用于加密的密钥称为<strong>公钥</strong>，顾名思义可以公开。用于解密的密钥称为<strong>私钥</strong>，只有需要进行解密的接受者才持有，公钥和私钥称为<strong>密钥对</strong>。</p><p>（2）消息认证码的密钥和数字签名的密钥：在<strong>消息认证码</strong>中，发送者和接受者使用共享的密钥来进行认证，消息认证码只有持有合法密钥的人才能计算出来，可以用来识别通信内容是否被篡改或伪装。在<strong>数字签名</strong>中，签名的生成和验证使用不同的密钥。只有持有私钥的本人才能生成签名，但由于验证签名使用的是公钥，因此任何人都可以验证签名。</p><p>（3）用于确保机密性的密钥和用于认证的密钥：对称密码和公钥密码的密钥都是<strong>用于确保机密性的密钥</strong>，相对地，消息认证码和数字签名所使用的密钥，则是<strong>用于认证的密钥</strong>。</p><p>（4）会话密钥和主密钥：当我们访问以 http:// 开头的网页时，Web 服务器和浏览器之间会进行基于 SSL / TLS 的加密通信。在这样的通信中所使用的密钥仅限于本次通信的一次性密钥，下次通信不会再使用，像这样每次通信只能使用一次的密钥称为<strong>会话密钥</strong>（session key）。相对于会话密钥，一直被重复使用的密钥称为<strong>主密钥</strong>（master key）。</p><p>（5）用于加密内容的密钥和用于加密密钥的密钥：加密的对象是用户直接使用的信息，这样的情况下所使用的密钥称为 <strong>CEK</strong>（Contents Encrpyting Key，内容加密密钥），相对地，用于加密密钥的密钥则称为 <strong>KEK</strong>（Key Encrpyting Key，密钥加密密钥）。</p><p>在很多情况下，会话密钥都是作为 CEK 使用的，而主密钥则是被作为 KEK 使用的。</p></li><li><p>密钥的管理：</p><p>（1）生成密钥：</p><p>① 用随机数生成密钥：生成密钥的最好方法就是<strong>使用随机数</strong>，尽管生成伪随机数的算法有很多种，但<strong>密码学用途的伪随机数生成器必须是专门针对密码学用途而设计的</strong>。</p><p>② 用口令生成密钥：使用人类可以记住的<strong>口令</strong>（password / passphrase）来生成密钥。严格来说，我们很少直接用口令来作为密钥使用，一般都是将口令输入单向散列函数，用得到的散列值作为密钥使用。为了防止字典攻击，需要在口令上面附加一串称为<strong>盐</strong>（salt）的随机数，然后再将其输入单向散列函数，这种方法称为<strong>基于口令的密码</strong>（Password Based Encrpytion，PBE）。</p><p>（2）配送密钥：</p><p>① 通过<strong>事先共享密钥</strong>来解决</p><p>② 通过<strong>密钥分配中心</strong>来解决</p><p>③ 通过 <strong>Diffie-Hellman</strong> 密钥交换来解决</p><p>④ 通过<strong>公钥密码</strong>解决</p><p>（3）更新密钥：提高通信机密的技术被称为<strong>密钥更新</strong>（key updating），在使用共享密钥通信的过程中，定期改变密钥，比如用当前密钥的散列值作为下一个密钥，因为单向散列函数具有单向性，因此反算出单向散列函数的输入（即上一个密钥）是很困难的，窃听者无法解密更新密钥这个时间点之前的通信内容，这种防止破译过去的通信内容的机制，称为<strong>后向安全</strong>（backward security）。</p><p>（4）保存密钥：<strong>人类无法记住具有实用长度的密钥</strong>，我们记不住密钥，但如果将密钥保存下来有可能被窃取，因此我们需要将密钥<strong>保存在保险柜等安全的地方</strong>，通过保险柜的机制确保密钥的机密性。但是却无法保证便携性，随身携带又可能会丢失被盗，因此我们可以使用<strong>将密钥加密后保存</strong>的方法，用于加密密钥的密钥称为 KEK 。那么 KEK 又如何保存呢，好像进入了死循环，对密钥进行加密的方法并没有完全解决机密性的问题，但在现实中确是一个非常有效的方法，可以<strong>减少需要保管的密钥数量</strong>。用一个密钥来代替多个密钥进行保管的方法，和认证机构的层级化非常相似，我们不需要信任多个认证机构，而只需要信任一个根 CA 就可以了，同样地，我们也不需要确保多个 CEK 的机密性，而只需要确保一个 KEK 的机密性就可以了。</p><p>（5）作废密钥：密钥的作废和生成是同等重要的，这是因为密钥和明文是等价的。要完全删除密钥，不但要用到密码软件，还需要在设计计算机系统时对信息安全进行充分考虑。</p></li><li><p>Diffie-Hellamn 密钥交换（Diffie-Hellamn key exchange）：是 1976 年由 Whitfield Diffie 和 Martin Hellman 共同发明的一种算法，使用这种算法，通信双方只需要交换一些可以公开的消息就能够生成出共享的秘密数字，而这一秘密数字就可以被用作对称密码的密钥，IPsec 中就使用了经过改良的Diffie-Hellamn 密钥交换。</p><p>虽然这种方法的名字叫做“密钥交换”，但实际上双方并没有真正交换密钥，而是通过计算生成了一个相同的共享密钥，因此这种方法也叫 <strong>Diffie-Hellman 密钥协商</strong>（Diffie-Hellman key agreement）。</p><blockquote><p>密钥交换的步骤：</p></blockquote><blockquote><p>假设 Alice 和 Bob 需要共享一个对称密码的密钥，然而双方之间的通信已被窃听者 Eve 窃听了。</p></blockquote><blockquote><p>（1）Alice 向 Bob 发送两个质数 <em>P</em> 和 <em>G</em> ：</p></blockquote><blockquote><p><em>P</em> 必须是一个非常大的质数，而 <em>G</em> 则是一个和 <em>P</em> 相关的数，称为<strong>生成元</strong>（generator），<em>G</em> 可以是一个较小的数字。</p><blockquote><p>生成元：<em>P</em> 的生成元的乘方结果与 1~ <em>P</em> －1 中的数字是一一对应的，正是因为具有这样一一对应的关系，Alice 才能从 1~ <em>P</em> －2 的范围中随机选择一个数字（之所以不能选择 <em>P</em> －1 是因为<em>G</em><sup><em>P</em> - 1</sup> mod <em>P</em> 的值一定是等于 1 的）。</p></blockquote></blockquote><blockquote><p><em>P</em> 和 <em>G</em> 不需要保密，被窃听者 Eve 获取也没关系，此外 <em>P</em> 和 <em>G</em> 可以由 Alice 和 Bob 中任意一方生成。</p></blockquote><blockquote><p>（2）Alice 生成一个随机数 <em>A</em> ：</p></blockquote><blockquote><p><em>A</em> 是一个 1 ~ <em>P</em> — 2 之间的整数，这个数是一个只有 Alice 知道的秘密数字，没有必要告诉 Bob，也不能让 Eve 知道。</p></blockquote><blockquote><p>（3）Bob 生成一个随机数 <em>B</em> ：</p></blockquote><blockquote><p><em>B</em> 是一个 1 ~ <em>P</em> — 2 之间的整数，这个数是一个只有 Bob 知道的秘密数字，没有必要告诉 Alice ，也不能让 Eve 知道。</p></blockquote><blockquote><p>（4）Alice 将 <em>G</em><sup><em>A</em></sup> mod <em>P</em> 这个数发送给 Bob ：</p></blockquote><blockquote><p>这个数让 Eve 知道也没关系。</p></blockquote><blockquote><p>（5）Bob 将 <em>G</em><sup><em>B</em></sup> mod <em>P</em> 这个数发送给 Alice ：</p></blockquote><blockquote><p>这个数让 Eve 知道也没关系。</p></blockquote><blockquote><p>（6）Alice 用 Bob 发过来的数计算 <em>A</em> 次方并求 mod <em>P</em> ：</p></blockquote><blockquote><p>这个数就是共享密钥。</p></blockquote><blockquote><p>Alice 计算的密钥 = (<em>G</em><sup><em>B</em></sup> mod <em>P</em> )<sup><em>A</em></sup> mod <em>P</em></p></blockquote><blockquote><p>Alice 计算的密钥 = <em>G</em><sup><em>B</em> × <em>A</em></sup> mod <em>P</em></p></blockquote><blockquote><p>Alice 计算的密钥 = <em>G</em><sup><em>A</em> × <em>B</em></sup> mod <em>P</em></p></blockquote><blockquote><p>（7）Bob 用 Alice 发过来的数计算 <em>B</em> 次方并求 mod <em>P</em> ：</p></blockquote><blockquote><p>Bob计算的密钥 = (<em>G</em><sup><em>A</em></sup> mod <em>P</em> )<sup><em>B</em></sup> mod <em>P</em></p></blockquote><blockquote><p>Bob 计算的密钥 = <em>G</em><sup><em>A</em> × <em>B</em></sup> mod <em>P</em></p></blockquote><blockquote><p>得出：Alice 计算的密钥 = Bob 计算的密钥</p></blockquote><blockquote><p>在步骤（1）~（7）中，双方交换的数字（能被 Eve 知道的数字）一共有 4 个：<em>P</em> 、<em>G</em> 、<em>G</em><sup><em>A</em></sup> mod <em>P</em> 、<em>G</em><sup><em>B</em></sup> mod <em>P</em> ，根据这四个数计算共享密钥（<em>G</em><sup><em>A</em> × <em>B</em></sup> mod <em>P</em>）是非常困难的。</p></blockquote><blockquote><p>如果 Eve 知道 <em>A</em> 和 <em>B</em> 中的任意一个数，那么要计算 <em>G</em><sup><em>A</em> × <em>B</em></sup> 就很简单了，仅靠上面 4 个数是很难求出 <em>A</em> 和 <em>B</em> 的。</p></blockquote><blockquote><p>举个例子，我们能够根据 <em>G</em><sup><em>A</em></sup> mod <em>P</em> 计算出 <em>A</em> 吗？<em>G</em><sup><em>A</em></sup> mod <em>P</em> 中的 mod <em>P</em> 是这里的关键所在，如果仅仅是 <em>G</em><sup><em>A</em></sup> 的话，要计算出 <em>A</em> 并不难，然而<strong>根据 <em>G</em><sup><em>A</em></sup> mod <em>P</em> 计算出 <em>A</em> 的有效算法到现在还没有出现</strong>，这个问题被称为<strong>有限域（finite field）的离散对数问题</strong>。</p></blockquote></li><li><p>椭圆曲线 Diffie-Hellman 密钥交换：Diffie-Hellman密钥交换是利用“离散对数问题”的复杂度来实现密钥的安全交换的，如果将“离散对数问题”改为“椭圆曲线上的离散对数问题”，这样的算法就称为<strong>椭圆曲线 Diffie-Hellman 密钥交换</strong>。</p></li><li><p>基于口令的密码（Password Based Encryption，PBE）：是一种根据口令生成密钥并用该密钥进行加密的方法，其中加密和解密使用同一个密钥。</p><p>PBE 有很多种实现方法，例如可以通过 Java 的 javax.crypto 包进行实现，此外，通过密码软件 PGP 保存密钥时，也会使用 PBE 。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fmsuk1d0kdj30sg0lctdu.jpg" alt="15"></p><p>PBE 加密与解密包括下列 3 个步骤：</p><p>（1）生成 KEK —————— 重建 KEK</p><p>（2）生成会话密钥并加密——解密会话密钥</p><p>（3）加密消息———————解密消息</p><p>盐的作用：盐是由伪随机数生成器生成的随机数，在生成密钥（KEK）时会和口令一起被输入单向散列函数。<strong>盐是用来防御字典攻击的</strong>，<strong>字典攻击</strong>是一种事先进行计算并准备好候选密钥列表的方法。</p><p>我们假设在生成 KEK 的时候没有加盐，就意味着主动攻击者可以根据字典数据事先生成大量的候选 KEK 。如果在生成 KEK 的时候加盐，则盐的长度越大，候选 KEK 的数量也随之增大，事先生成候选 KEK 就会变得非常困难。</p><p>口令的作用：具有充足长度的密钥是无法用人脑记忆的，同样，人脑也无法记住充足长度的口令，在PEB中，我们通过口令生成密钥（KEK），再用这密钥来加密会话密钥（CEK）。由于通过口令生成的密钥（KEK）强度不如伪随机数生成器生成的会话密钥（CEK），因此需要将盐和加密后的 CEK <strong>通过物理方式进行保护</strong>，比如保存到存储卡中随身携带。</p><p>通过拉伸来改良 PBE：在生成 KEK 时，通过多次使用单向散列函数就可以提高安全性，例如，如果我们将盐和口令先输入单向散列函数，然后将得到的散列值再次输入单向散列函数……像这样将单向散列函数进行多次迭代的方法称为<strong>拉伸</strong>（stretching）。</p><p>如何生成安全的口令：</p><p>（1）使用只有自己才能知道的信息，不要使用自己重要的事物的名字，不要使用关于自己的信息，不要使用被人见过的信息。</p><p>（2）将多个不同的口令分开使用。</p><p>（3）有效利用笔记。</p><p>（4）理解口令的局限性。</p><p>（5）使用口令生成和管理工具。</p></li></ul><h2 id="十二、随机数"><a href="#十二、随机数" class="headerlink" title="十二、随机数"></a>十二、随机数</h2><ul><li><p>使用随机数的密码技术：</p><p>（1）生成密钥：用于对称密码和消息认证码。</p><p>（2）生成密钥对：用于公钥密码和数字签名。</p><p>（3）生成初始化向量 IV ：用于分组密码的 CBC 、CFB 、OFB 模式。</p><p>（4）生成 nonce：用于防御重放攻击以及分组密码的 CTR 模式。</p><p>（5）生成盐：用于 PBE 等。</p><p>上面的这些用途都很重要，但其中尤为重要的是“生成密钥”和“生成密钥对”这两个，密码算法再高，只要攻击者知道了密钥，就会变得形同虚设。因此我们需要用随机数来生成密钥，使之无法看穿。<strong>为了不让攻击者看穿而使用随机数</strong>这一观点，即不可预测性，正是本章的主题。</p></li><li><p>随机数的性质：</p><p>可将随机数的性质分为以下三类：</p><p>（1）随机性：所谓随机性，简单来说就是看上去杂乱无章的性质，但是<strong>杂乱无章不代表不会被看穿</strong>，因此我们将只具备随机性的伪随机数称为“弱伪随机数”。</p><p>（2）不可预测性：指<strong>攻击者在知道过去生成的伪随机数列的前提下，依然无法预测出下一个生成的伪随机数</strong>的性质，因此我们将具有不可预测性的伪随机数称为<strong>强伪随机数</strong>。事实上，<strong>不可预测性是通过使用其他密码技术来实现的</strong>，例如使用单向散列函数的单向性和密码的机密性来保证伪随机数生成器的不可预测性。</p><p>（3）不可重现性：指无法重现和某一随机数列完全相同的数列的性质，如果除了将随机数列保存下来以外，没有其他方法可以重现该数列，我们就说该随机数列具备不可重现性。仅靠软件是无法生成具备不可重现性的随机数列的，软件只能生成伪随机数列，因为运行软件的计算机本身仅具备有限的内部状态，在内部状态相同的情况下，软件必然只能生成相同的数，因此软件所生成的数列在某一时刻一定会重复出现。首次出现重复之前的数列长度称为<strong>周期</strong>，凡是具有周期的数列，都不具备不可重现性。</p><p> 要生成具备不可重现性的随机数列，需要从不可重现的物理现象中获取信息，例如周围的温度和声音的变化，鼠标移动的位置、键盘输入的事件间隔，根据从这些硬件中所获取的信息而生成的数列，一般可以认为是具备不可重现性的随机数列。我们将具备不可重现性的随机数称为<strong>真随机数</strong>。</p><blockquote><p>英特尔的新型 CPU 中内置了<strong>数字随机数生成器</strong>（Digital Random Number Generator，DRNG），并提供了 RDSEED 和 RDRAND 两条指令。这种 CPU 生成随机数的原料（随机信号源）来自于电路中产生的热噪声。从随机信号源获得的不可重现的比特序列，经过 AES-CBC-MAC 算法之后，形成一串 256 比特的数据，这串数据被称为<strong>调查随机样本</strong>（conditioned entropy sample）。AES-CBC-MAC 是一种基于 AES 分组密码的 CBC 模式的消息验证码算法，在这里它的作用是将一串很长的比特序列压缩到 256 比特。</p></blockquote><blockquote><p>RDSEED 指令直接利用调整随机样本来生成不确定的随机序列，这样的随机序列是具备不可重现性的。这个指令的所输出的结果，一般被用作其他伪随机数生成器的种子。</p></blockquote><blockquote><p>RDRAND 指令则是将调整随机样本输入到 CTR 模式的 AES 分组密码中，快速生成确定的随机数列，这样的数列是具备不可预测性的。</p></blockquote></li></ul><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">随机性</th><th style="text-align:center">不可预测性</th><th style="text-align:center">不可重现性</th></tr></thead><tbody><tr><td style="text-align:center">弱伪随机数</td><td style="text-align:center">具有</td><td style="text-align:center">不具有</td><td style="text-align:center">不具有</td></tr><tr><td style="text-align:center">强伪随机数</td><td style="text-align:center">具有</td><td style="text-align:center">具有</td><td style="text-align:center">不具有</td></tr><tr><td style="text-align:center">真随机数</td><td style="text-align:center">具有</td><td style="text-align:center">具有</td><td style="text-align:center">不具有</td></tr></tbody></table><ul><li><p>伪随机数生成器：通过硬件生成的随机数列，是根据传感器收集的热量、声音的变化等事实上无法预测和重现的自然信息来生成的，像这样的硬件设备就称为<strong>随机数生成器</strong>（Random Number Generator，RNG），而可以生成随机数的软件就称为<strong>伪随机数生成器</strong>（Pseudo Random Number Generator，PRNG）。</p><p>伪随机数生成器的结构：</p><p>（1）内部状态：是指伪随机数生成器所管理的内存中的数值，为了响应下一个伪随机数请求，伪随机数生成器会改变自己的内部状态，因此将根据内部状态计算伪随机数生成器的方法和改变内部状态的方法结合起来，就是伪随机数生成的算法。由于内部状态决定了下一个生成的伪随机数，因此内部状态不能被攻击者知道。</p><p>（2）种子：是用来对伪随机数生成器的内部状态进行初始化的。种子是一串随机的比特序列，根据种子可以生成出专属于自己的伪随机数列，伪随机数生成器是公开的，但种子是需要自己保密的。</p><p>具体的伪随机数生成器：</p><p>（1）杂乱的方法：该方法无法用于密码技术，因为周期太短，不具有不可预测性，并且程序员都不能理解算法的详细内容，无法判断是否具有不可预测性。</p><p>（2）线性同余法（line congruential method）：是一种使用很广泛的伪随机数生成器算法，然而，它并不能用于密码技术。   </p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fmsv52a6cdj30sg0lcju7.jpg" alt="16"></p><p><strong>线性同余法就是将当前的伪随机数乘以 <em>A</em> 在加上 <em>C</em> ，然后将除以 <em>M</em> 得到的余数作为下一个伪随机数</strong>。（<em>A</em>、<em>C</em>、<em>M</em> 都是常量，且 <em>A</em> 和 <em>C</em> 需要小于 <em>M</em>）</p><p><strong>线性同余法不具备不可预测性，因此不可以将线性同余法用于密码技术</strong>。很多伪随机数生成器的库函数（library function）都是采用线性同余法编写的，例如 C 语言的库函数 rand ，以及 Java 的java.util.Random类，都采用了线性同余法，因此这些函数都无法用于密码技术。</p><p>（3）单向散列函数法：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fmsv51wqusj30sg0lctbq.jpg" alt="17"></p><p>① 用伪随机数的种子初始化内部状态（计数器）。</p><p>② 用单向散列函数计算计算器的散列值。</p><p>③ 将散列值作为随机数输出——计算器的值加 1 。</p><p>④ 据需要的伪随机数数量重复步骤。</p><p>在此方法中，<strong>单向散列函数的单向性是支撑伪随机数生成器不可预测性的基础</strong>。</p><p>（4）密码法：</p><p>① 初始化内部状态（计数器）。</p><p>② 用密钥加密计数器的值。</p><p>③ 将密文作为伪随机数输出——计数器的值加 1 。 </p><p>④ 根据需要的伪随机数数量重复步骤。</p><p>在此方法中，<strong>密码的机密性是支撑伪随机数生成器不可预测性的基础</strong>。</p><p>（5）ANSI X9.17 ：关于用密码实现伪随机数生成器的具体方法，被用于密码软件 PGP 中。</p><p>（6）其他算法：除了上面介绍的算法，还有很多其他的生成随机数的算法，在安全相关的软件开发中，开发者在选择随机数生成算法时必须确认“这个随机数算法是否能够用于密码学和安全相关用途”。一个随机数算法再优秀，如果它不具备不可预测性，那么就不能用于密码学和安全相关用途。</p><p>有一个有名的伪随机数生成算法叫做<strong>梅森旋转算法</strong>（Mersenne twister），但它并不能用于安全相关的用途，和线性同余法一样，只要观察足够长的随机数列，就能够对之后生成的随机数列进行预测。</p><p>Java 中有一个用于生成随机数列的类，名叫 java.util.Random ,然而这个类也不能用于安全相关用途，要用于安全用途，可以使用另一个名叫 java.security.SecureRandom 的类。</p><p>和 Java 一样，Ruby 中也分别有 Random 类和 SecureRandom 模块，在安全相关用途中应该使用 SecureRandom，而不是 Random 。</p></li><li><p>对伪随机数的攻击：</p><p>（1）对种子进行攻击：伪随机数的种子和密码的密钥同等重要，一旦被攻击者知道种子，那他就能知道这个伪随机数生成器所生成的全部伪随机数列。要避免种子被攻击者知道，我们需要使用具备不可重现性的真随机数作为种子。</p><p>（2）对随机数池进行攻击：我们一般不会到了需要的时候才生成真随机数，而是事先在一个名为<strong>随机数池</strong>（Random pool）的文件中积累随机比特序列。随机数池的内容不可以被攻击者知道，否则伪随机数的种子就可能被预测出来。</p><blockquote><p>Linux 系统中的 /dev/random 文件就是一个根据硬件设备驱动收集的背景噪声储存真随机数的随机数池。</p></blockquote></li></ul><h2 id="十三、PGP"><a href="#十三、PGP" class="headerlink" title="十三、PGP"></a>十三、PGP</h2><ul><li><p>PGP（Pretty Good Privacy）：是于 1990 年左右由 Philip Zimmermann 个人编写的密码软件，现在依然被广泛使用。</p></li><li><p>OpenPGP：是对密文和数字签名格式进行定义的标准规格（RFC1991、RFC2440、RFC4880、RFC5581、RFC6637）。</p><p>1996 年的 RFC1991 中对 PGP 的消息格式进行了定义。2007 年的 RFC4880 中新增了对 RSA 和DSA 的支持。2012年的 RFC6637 中新增了对椭圆曲线（EEC）的支持，并且还支持基于 Curve P-256、P-384、P-521 三种椭圆曲线的椭圆曲线 DSA（Elliptic Curve Digital Signature Algorithm，ECDSA）和椭圆曲线 Diffie-Hellman 密钥交换（Elliptic Curve Diffie-Hellman，ECDH）。</p><p>RFC6637 中新增了用于比较密码学强度的平衡性的对照表，由此表可知，例如当我们选用 256 比特的椭圆曲线密码算法时，相应地应该选用 256 比特的散列算法以及密钥长度为 128 比特的对称算法。</p></li></ul><table><thead><tr><th style="text-align:center">椭圆曲线名</th><th style="text-align:center">ECC</th><th style="text-align:center">RSA</th><th style="text-align:center">散列</th><th style="text-align:center">对称密码</th></tr></thead><tbody><tr><td style="text-align:center">P-256</td><td style="text-align:center">256</td><td style="text-align:center">3072</td><td style="text-align:center">256</td><td style="text-align:center">128</td></tr><tr><td style="text-align:center">P-384</td><td style="text-align:center">384</td><td style="text-align:center">7680</td><td style="text-align:center">384</td><td style="text-align:center">192</td></tr><tr><td style="text-align:center">P-521</td><td style="text-align:center">521</td><td style="text-align:center">15360</td><td style="text-align:center">512</td><td style="text-align:center">256</td></tr></tbody></table><ul><li><p>GNU Privacy Guard（GunPG、GPG）：是一款基于 OpenPGP 标准开发的密码学软件，支持加密、数字签名、密钥管理、S/MIME、ssh 等多功能，基于 GNU GPL 协议发布，因此任何人可以使用它。GunPG 本身是一款命令行工具，也经常被集成到其他软件中去。</p></li><li><p>PGP 的功能：</p><p>（1）对称密码：可以使用的对称密码算法包括 AES、IDEA、CAST、三重 DES、Blowfish、Twofish、Camellia等。</p><p>（2）公钥密码：可以使用的公钥密钥算法包括 RSA 和 ElGamal 等。</p><p>（3）数字签名：可以使用的数字签名算法包括 RSA、 DSA、ECDMA（椭圆曲线 DSA）、EdDSA（爱德华兹曲线 DSA）等。</p><p>（4）单向散列函数：可以使用的单向散列函数包括 SHA-1、SHA-224、SHA-256、SHA-384、SHA-512 和 RIPEMD-160 等。</p><p>（5）证书：可以使用 OpenGPG 中规定格式的证书，以及与 X.509 规范兼容的证书，此外，还可以颁发公钥的作废证明（revocation certificate），并可以使用 CRL 和 OSCP 对证书进行检验。</p><p>（6）压缩：压缩采用 ZIP、ZLIB、BZIPZ 等格式。</p><p>（7）文本数据：可以将二进制数据和文本数据（ASCII radix-64 格式）进行互换。（radix-64 格式是在邮件等场合中经常使用的 base-64 编码的基础上，增加了检测数据错误的校验和的版本）</p><p>（8）大文件的拆分和拼合</p><p>（9）钥匙串管理：可以管理所生成的密钥对以及外部获取的公钥，用于管理密钥的文件称为钥匙串（key ring）</p></li><li><p>加密与解密：基本结构和混合密码系统是一样的，差异在于这里还包括了消息的压缩与解压缩以及二进制＜－＞文本转换（ASCII radix-64 格式）这两个步骤。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fmsv52k13dj30sg0lctbg.jpg" alt="18"></p></li><li><p>生成和验证数字签名：</p></li><li><p>生成数字签名并加密以及解密并验证数字签名： </p></li><li><p>信任网（web of trust）：在这种方法中，PGP 用户会互相对对方的公钥进行数字签名，不依赖认证机构，而是建立每个人之间的信任关系。PGP 用户可以自行设置对谁进行何种程度的信任，PGP 就是根据信任数据库中的设置来判断所得到的公钥是否属于本人。PGP 当初的设计目的是在连国家都不可信的情况下依然能够使用，因此并不关心有没有可信的认证机构。</p></li></ul><table><thead><tr><th style="text-align:center">信任级别</th></tr></thead><tbody><tr><td style="text-align:center">绝对信任（Ultimately trusted）</td></tr><tr><td style="text-align:center">完全信任（Fully trusted）</td></tr><tr><td style="text-align:center">有限信任（Marginally trusted）</td></tr><tr><td style="text-align:center">不信任（Never trust this key）</td></tr><tr><td style="text-align:center">未知密钥（Not enough information）</td></tr><tr><td style="text-align:center">未设置（No owner trust assigned）</td></tr></tbody></table><h2 id="十四、SSL-TLS"><a href="#十四、SSL-TLS" class="headerlink" title="十四、SSL / TLS"></a>十四、SSL / TLS</h2><ul><li><p>SSL/TLS ：是世界上使用最广泛的密码通信方法。</p><p>客户端与服务器：当我们需要用浏览器浏览一个网页的时候，Web 浏览器就是我方计算机上运行的一个程序，而 Web 服务器则是对方计算机上运行的一个程序，它们都遵循 <strong>HTTP</strong>（HyperText Transfer Protocol，超文本传输协议）来进行通信，其中，Web浏览器被称为 <strong>HTTP 客户端</strong>，Web 服务器被称为 <strong>HTTP 服务器</strong>，HTTP 可以认为是在 HTTP 客户端与 HTTP 服务器之间进行请求和响应的规范。</p><p>用 SSL/TLS 承载 HTTP：当Web浏览器发送信用卡号时，我们可以用 SSL（Secure Socket Layer）或者 TLS（Transport Layer Security）作为对通信进行加密的协议，然后<strong>在此之上承载 HTTP</strong> 。通过将两种协议叠加，我们就可以对 HTTP 的通信进行加密，因此当通过 SSL/TLS 进行通信时，URL不是以 http://开头，而是以https://开头。</p><p>SSL/TLS 也可以保护其他的协议：不仅可以承载 HTTP ，发送邮件时使用的 SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）和接受邮件时使用的 POP3（Post Office Protocol，邮局协议）都可以用 SSL/TLS 进行承载。</p><p>密码套件（cipher suite）：SSL/TLS 提供了一种密码通信的框架，这意味着 SSL/TLS 中使用的对称密码、公钥密码、数字签名、单向散列函数等技术，都可以像零件一样进行替换，也就是说，如果发现所使用的某个密码技术存在的弱点，只要将这一部分进行替换就好了。</p><p>尽管如此，并不是说所有的组件都可以自由选择，选择过于自由，难以保证整体的兼容性，为此，SSL/TLS 就像事先搭配好的盒饭一样，规定了一些密码技术的“推荐套餐”，被称为密码套件。</p><p>SSL 与 TLS 的区别：SSL（Secure Socket Layer，安全套接层）是 1994 年由网景（Netscape）公司设计的一种协议，随后成为行业标准。SSL 已于 1995 年发布了 3.0 版本，但在 2014 年，SSL 3.0 协议被发现存在可能导致 POODLE 攻击的安全漏洞，因此 SSL 3.0 已经不安全了。</p><p>TLS（Transport Layer Security，传输层安全）是 IETF 在 SSL 3.0 的基础上设计的协议，TLS 相当于 SSL 的后续版本。</p></li><li><p>使用 SSL/TLS 进行通信：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fmsv51lq3jj30sg0lcq5m.jpg" alt="19"></p><p>（1）TLS 记录协议：位于 TLS 握手协议的下层，是负责使用对称密码对消息进行加密通信的部分，该协议中使用了对称密码和消息认证码，但是具体的算法和共享密钥则是通过后面的握手协议在服务器和客户端之间协商决定的。</p><p>首先消息被分割成多个较短的片段（fragment），然后分别对每个片段进行压缩。压缩算法需要与通讯对象进行协商。</p><p>接下来，经过压缩的片段会被加上消息认证码，这是为了保证完整性，并进行数据的认证，通过附加消息认证码的 MAC 值，可以识别出篡改。与此同时，为了防止重放攻击，在计算消息认证码时，还加上了片段的编号。单向散列函数的算法，以及消息认证码所使用的共享密钥都需要与通信对象协商决定。</p><p>再接下来，经过压缩的片段再加上消息认证码会一起通过对称密码进行加密。加密使用 CBC 模式，CBC 模式 的初始化向量（IV）通过主密码生成，而对称密码的算法以及共享密钥需要与通信对象协商决定。</p><p>最后，上述经过加密的数据加上数据类型、版本号、压缩后的长度组成的报头（header）就是最终的报文数据。其中，数据类型为 TLS 记录协议所承载的 4 个子协议 的其中之一。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fmsv517yjij30sg0lcwi1.jpg" alt="20"></p><p>（2）TLS 握手协议：</p><p>（2.1）握手协议：握手协议负责生成共享密钥以及交换证书，其中生成密钥是为了进行密码通信，交换证书是为了通信双方相互进行认证。由于握手协议中的信息交换是在没有加密的情况下进行的，也就是说协议所收发的数据很有可能被窃听，因此在这一过程中必须使用公钥密码或者 Diffie-Hellman 密钥交换。</p><blockquote><p>握手协议详解：</p></blockquote><blockquote><ol><li>ClientHello（客户端﹣＞服务器）</li></ol></blockquote><blockquote><p> 客户端向服务器发送 ClientHello 消息</p></blockquote><blockquote><p> 客户端：“你好。我能理解的密码套件有 RSA/3DES，或者 DSS/AES，请问我们使用哪一种密码套件进行通信呢？”</p></blockquote><blockquote><p> 客户端会向服务器发送下列消息： </p></blockquote><blockquote><pre><code>可用版本号当前时间客户端随机数会话 ID可用的密码套件清单可用的压缩方式清单</code></pre><p> 之所以发送“可用版本号”“可用的密码套件清单”“可用的压缩方式清单”，是因为不同的客户端所支持的方式不同，具体使用哪一种来通信，需要和服务器来协商。</p></blockquote><blockquote><p> “当前时间”在基本的 TLS 中是不使用的，但上层协议有可能会使用，“客户端随机数”是一个由客户端生成的不可预测的随机数，我们在后面的步骤中需要用到它。</p></blockquote><blockquote><p> “会话 ID”是当客户端和服务器希望重新使用之前建立的会话时所使用的信息。</p></blockquote><blockquote><ol start="2"><li>SeverHello（客户端＜﹣服务器）</li></ol></blockquote><blockquote><p> 对于客户端发送的 ClientHello 消息，服务器会返回一个 SeverHello 消息。</p></blockquote><blockquote><p> 服务器：“你好，我们就用 RSA/3DES 来进行通信吧。”</p></blockquote><blockquote><p> 服务器会将下列消息随 SeverHello 消息一起发出去。</p></blockquote><blockquote><pre><code>使用的版本号当前时间服务器随机数会话 ID使用的密码套件使用的压缩方式</code></pre></blockquote><blockquote><p> 服务器会根据客户端在 ClientHello 消息中发送过来的消息确定通信中使用的“版本号”“密码套件”和“压缩方式”。</p></blockquote><blockquote><p> “服务器随机数”是一个服务器生成的不可预测的随机数，这个随机数必须与客户端生成的随机数无关，会在后面的步骤中用到它。</p></blockquote><blockquote><ol start="3"><li>Certificate（客户端＜﹣服务器）</li></ol></blockquote><blockquote><p> 服务器会发送 Certificate 消息。</p></blockquote><blockquote><p> 服务器：“好，这是我的证书。”</p></blockquote><blockquote><p> 通过 Certificate 消息，服务器会向客户端发送下列消息。</p></blockquote><blockquote><pre><code>证书清单</code></pre></blockquote><blockquote><p> 证书清单是一组 X.509v3 证书序列，首先发送的是服务器（发送方）的证书，然后会按顺序发送服务器证书签名的认证机构的证书。</p></blockquote><blockquote><p> 客户端会对服务器发送过来的证书进行验证，当以匿名方式通信时，不发送 Certificate 消息。</p></blockquote><blockquote><ol start="4"><li>ServerKeyExchange（客户端＜﹣服务器） </li></ol></blockquote><blockquote><p> 服务器发送 SeverKeyExchange 消息。</p></blockquote><blockquote><p> 服务器：“我们用这些消息来进行密钥交换吧”</p></blockquote><blockquote><p> 当 Certificate 消息不足以满足需求的时，服务器会通过 ServerKeyExchange 消息向客户端发送一些必要消息。具体所发送的消息内容会根据所使用的密码套件而有所不同。</p></blockquote><blockquote><p> 当不需要这些消息时，将不会发送 ServerKeyExchange 消息。  </p></blockquote><blockquote><ol start="5"><li>CertificateRequest (客户端＜﹣服务器）</li></ol></blockquote><blockquote><p> 服务器发送 Certificate 消息。</p></blockquote><blockquote><p> 服务器：“对了，请给我看一下你的证书吧。”</p></blockquote><blockquote><p> CertificateRequest 消息用于服务器向客户端请求证书，这是为了进行客户端认证，通过这一消息，服务器会向客户端发送下列消息</p></blockquote><blockquote><pre><code>服务器能够理解的证书类型清单服务器能够理解的认证机构名称清单</code></pre></blockquote><blockquote><p> 当不使用客户端认证时，不会发送 CertificateRequest 消息。</p></blockquote><blockquote><ol start="6"><li>ServerHelloDone（客户端＜﹣服务器）</li></ol></blockquote><blockquote><p> 服务器发送 SeverHelloDone 消息。</p></blockquote><blockquote><p> 服务器：“问候到此结束。”</p></blockquote><blockquote><p> 这一消息表示从 ServerHello 消息开始的一系列消息的结束。</p></blockquote><blockquote><ol start="7"><li>Certificate（客户端﹣＞服务器） </li></ol></blockquote><blockquote><p> 客户端发送 Certificate 消息。</p></blockquote><blockquote><p> 客户端：“这是我的证书。”</p></blockquote><blockquote><p> 当步骤 5 中服务器发送了 CertificateRequest 消息时，客户端会将自己的证书同 Certificate 消息一同发给服务器。</p></blockquote><blockquote><p> 服务器读取客户端的证书并进行验证。 </p></blockquote><blockquote><p> 当服务器没有发送 CertificateRequest 消息时，客户端不会发送 Certificate 消息。</p></blockquote><blockquote><ol start="8"><li>ClientExchange（客户端﹣＞服务器） </li></ol></blockquote><blockquote><p> 客户端发送 ClientExchange 消息。</p></blockquote><blockquote><p> 客户端：“这是经过加密的预备主密码。”</p></blockquote><blockquote><p> 当密码套件中包含 RSA 时，会随着 ClientExchange 消息一起发送经过加密的预备主密码。</p></blockquote><blockquote><p> 当密码套件中包含 Diffie-Hellman 密钥交换时，会随着 ClientExchange 消息一起发送 Diffie-Hellman 的公开值。</p></blockquote><blockquote><p> 预备主密码（pre-master secret）是由客户端生成的随机数，之后会被用作生成主密码的种子，这个值会使用服务器的公钥进行加密后发送给服务器。</p></blockquote><blockquote><p> 根据预备主密码，服务器和客户端会计算出相同的主密码，然后再根据主密码生成下列比特序列（密钥素材）。</p></blockquote><blockquote><pre><code>对称密码的密钥消息认证码的密钥对称密码的 CBC 模式中使用的初始化向量（IV）</code></pre></blockquote><blockquote><ol start="9"><li>CertificateVerify（客户端﹣＞服务器） </li></ol></blockquote><blockquote><p> 客户端发送 CertificateVerify 消息。</p></blockquote><blockquote><p> 客户端：“我确实是客户端证书的持有者本人。”</p></blockquote><blockquote><p> 客户端只有在服务器发送 CertificateRequest 消息时才会发送 CertificateVerify 消息。这个消息的目的是向服务器证明自己的确持有客户端证书的私钥。</p></blockquote><blockquote><p> 为了实现这一目的，客户端会计算“主密码”和“握手协议中传送的消息”的散列值，并加上自己的数字签名后发送服务器。</p></blockquote><blockquote><ol start="10"><li>ChangeCipherSpec（客户端﹣＞服务器）</li></ol></blockquote><blockquote><p> 客户端发送 ChangeCipherSpec 消息。</p></blockquote><blockquote><p> 客户端：“好，现在我要切换密码了。”</p></blockquote><blockquote><p> 实际上，ChangeCipherSpec 消息并不是握手协议的消息，而是密码变更协议的消息。</p></blockquote><blockquote><p> 在 ChangeCipherSpec 消息之前，客户端和服务器之间已经交换了所有关于密码套件的信息，因此在收到这一消息时，客户端和服务器会同时切换密码。</p></blockquote><blockquote><p> 在这一消息之后，TLS 记录协议就开始使用双方协商决定的密码通信方式了。</p></blockquote><blockquote><ol start="11"><li>Finished（客户端﹣＞服务器）</li></ol></blockquote><blockquote><p> 客户端发送 Finished 消息。 </p></blockquote><blockquote><p> 客户端：“握手协议到此结束。”</p></blockquote><blockquote><p> 由于已经完成了密码切换，因此 Finished 消息时】是使用切换后的密码套件来发送的。实际负责加密操作的是 TLS 记录协议。</p></blockquote><blockquote><p> Finished 消息的内容是固定的，因此服务器可以将收到的密文解密，来确认所收到的 Finished 消息是否正确，通过这一消息，就可以确认握手协议是否正常结束，密码套件的切换是否正确。</p></blockquote><blockquote><ol start="12"><li>ChangeCipherSpec（客户端＜﹣服务器）</li></ol></blockquote><blockquote><p> 这次轮到服务器发送 ChangeCipherSpec 消息了。</p></blockquote><blockquote><p> 服务器：“好，现在我要切换密码了。”</p></blockquote><blockquote><ol start="13"><li>Finished（客户端＜﹣服务器） </li></ol></blockquote><blockquote><p> 和客户端一样，服务器也会发送 Finished 消息。</p></blockquote><blockquote><p> 服务器：“握手协议到此结束。”</p></blockquote><blockquote><p> 这一消息会使用切换后的密码套件来发送，实际负责加密操作的是 TLS 记录协议。</p></blockquote><blockquote><ol start="14"><li>切换至应用数据协议</li></ol></blockquote><blockquote><p> 在此之后，客户端和服务器会使用应用数据协议和 TLS 记录协议进行密码通信。</p></blockquote><blockquote><p> 从结果上来看，握手协议完成了下列操作：</p></blockquote><blockquote><pre><code>客户端获得了服务器的合法公钥，完成了服务器认证服务器获得了客户端的合法公钥，完成了客户端的认证（当需要客户端认证时）客户端和服务器生成了密码通信中使用的共享密钥客户端和服务器生成了消息认证码中使用共享密钥</code></pre></blockquote></li></ul><p> （2.2）密码规格变更协议：用于密码切换的同步。</p><p> （2.3）警告协议：用于当发送错误时通知通信对象，当握手协议的过程中产生异常，或者发生消息认证码错误、压缩数据无法解压缩等问题时，会使用该协议。</p><p> （2.4）应用数据协议：用于和通信对象之间传送应用数据，当 TLS 承载 HTTP 时，HTTP 的请求和响应就会通过 TLS 的应用数据协议和 TLS 记录协议来进行传送。</p><ul><li><p>主密码：主密码是 TLS 客户端和服务器之间协商出来的一个秘密的数值，TLS 密码通信的机密性和数据的认证全部依靠这个数值，主密码是一个 48 字节（384 比特）的数值。</p><p>主密码是客户端和服务器根据下列信息计算出来的：</p><pre><code>预备主密码客户端随机数服务器随机数</code></pre><p>当使用 RSA 公钥密码时，客户端会在发送 ClientKeyExchange 消息时，将经过加密的预备密码一起发送给服务器，当使用 Diffie-Hellman 密钥交换时，客户端会在发送 ClientKeyChange 消息时，将 Diffie-Hellman 的公开值一起发送给服务器。根据这个值，客户端和服务器会各自生成预备主密码。客户端随机数和服务器随机数的作用相当于防止攻击者事先计算出密钥的盐。</p><p>主密码用于生成下列 6 中消息：</p><pre><code>对称密码的密钥（客户端﹣＞服务器）对称密码的密钥（客户端＜﹣服务器）消息认证码的密钥（客户端﹣＞服务器）消息认证码的密钥（客户端＜﹣服务器）对称密码的 CBC 模式所使用的初始化向量（客户端﹣＞服务器）对称密码的 CBC 模式所使用的初始化向量 （客户端＜﹣服务器）</code></pre></li></ul><ul><li>TLS 握手协议中使用的密码技术</li></ul><table><thead><tr><th style="text-align:center">密码技术</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">公钥密码</td><td style="text-align:center">加密预备主密码</td></tr><tr><td style="text-align:center">单向散列函数</td><td style="text-align:center">构成伪随机数生成器</td></tr><tr><td style="text-align:center">数字签名</td><td style="text-align:center">验证服务器和客户端的证书</td></tr><tr><td style="text-align:center">伪随机数生成器</td><td style="text-align:center">生成预备主密码、根据主密码生成密钥（密码参数）、生成初始化向量</td></tr></tbody></table><ul><li>TLS 记录协议中使用的密码技术</li></ul><table><thead><tr><th style="text-align:center">密码技术</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">对称密码（CBC模式）</td><td style="text-align:center">确保片段的机密性</td></tr><tr><td style="text-align:center">消息认证码</td><td style="text-align:center">确保片段的完整性并进行认证</td></tr><tr><td style="text-align:center">认证加密（AEAD）</td><td style="text-align:center">确保片段的完整性和机密性并进行认证</td></tr></tbody></table><ul><li><p>对 SSL/TLS 的攻击：</p><p>（1）对各个密码技术的攻击：当然 SSL/TLS 作为框架的特性也被体现，更换密码套件即可。</p><p>（2）OpenSSL 的心脏出血漏洞：2014 年，Goolge 的 Neel Mehta 发现了广泛使用的密码学工具 OpenSSL 中存在一个 bug ,这个漏洞被称为<strong>心脏出血</strong>（HeartBleed） ，心脏出血并不是 SSL/TLS 协议本身的漏洞，而是 OpenSSL 这一实现上的漏洞。具体来说，由于 OpenSSL 在 TLS 心跳拓展功能中对于请求的数据大小没有进行检查，从而导致将内存中于该请求无关的信息返回给了请求者，攻击者通过访问包含该漏洞的 OpenSSL 的服务器，就可以在一定范围内窃取服务器上的信息。</p><p>这一漏洞公布时，全世界有相当多的服务器都收到了影响，据称当时有 17% 的 SSL/TLS 服务器都具有这一漏洞。</p><p>（3）SSL 3.0 的漏洞与 POODLE 攻击：Google 发现了针对 SSL 3.0 漏洞的攻击——POODLE攻击，SSL 3.0 中对 CBC 模式加密时的分组填充操作没有进行严格的规定，而且填充数据的完整性没有收到消息认证码的保护，POODLE攻击正是利用了这一漏洞。POODLE 攻击的本质就是填充提示攻击。</p><p>在某些条件下，攻击者可以将通信协议的版本从 TLS 强制降级到 SSL 3.0，也就是说，导致存在遭受 POODLE 攻击的风险。</p><p>要有效抵御 POODLE 攻击，必须禁用 SSL 3.0。</p><p>（4）FREAK 攻击与密码产品出口管制：FREAK 是 Factoring RSA Export Keys（出口级 RSA 密钥质因数分解）的缩写，从首字母看，并未出现“A”，缩写成 FREAK 是为了和“freak”形成双关，其攻击方式是强制 SSL/TLS 服务器使用一种名为 RSA Export Suites 的强度较低的密码套件。要实现 FREAK 攻击，除了需要 SSL/TLS 服务器具有该漏洞，同时还需要用户的 Web 浏览器（HTTP 客户端）接受使用 RSA Export Suites 来进行通信。</p><p>美国曾经将密码算法和软件作为武器来看待，因此历史上一度禁止将“高强度密码软件”出口到国外（<strong>密码产品出口管制</strong>），直到 20世纪 90年代后半期这一政策才有所缓和，RSA Export Suites 就是一种配合当时的环境而故意弱化的密码套件。</p><p>（5）对伪随机数生成器的攻击：1995年，加州大学的研究生发现了网景浏览器的一个 bug，这个 bug 存在于伪随机数生成器中。由于 SSL 中使用的伪随机数生成器的种子都在时间和进程编号等可预测的范围内，因此所得到的密钥范围实际上非常小。</p><p>（6）利用证书的时间差进行攻击：在 SSL/TLS 中，客户端会使用服务器证书对服务器进行认证，在这个过程中，客户端需要使用合法认证机构的公钥对证书所附带的数字签名进行验证。要验证证书需要使用最新版的 CRL（证书作废清单），如果 Web 浏览器没有获取最新版的 CRL，即便使用 SSL/TLS 也无法保证通信的安全。</p></li><li><p>SSL/TLS 注意事项：</p><p>（1）不要误解证书的含义：<strong>即便对方拥有合法的证书，也不代表你就可以放心地发送信用卡号</strong>，仅通过 SSL/TLS 是无法确认对方是否在从事信用卡诈骗的。</p><p>另外，认证机构所进行的本人身份确认也分为不同的等级，需要仔细确认一下认证机构的业务规则。</p><p>（2）密码通信之前的数据是不受保护的</p><p>（3）密码通信之后的数据是不受保护的 </p></li></ul><h2 id="十五、密码技术与现实社会"><a href="#十五、密码技术与现实社会" class="headerlink" title="十五、密码技术与现实社会"></a>十五、密码技术与现实社会</h2><ul><li><p>密码学家的工具箱</p><p>（1）对称密码：是一种用相同的密钥进行加密和解密的技术，用于确保消息的机密性。在对称密码的算法中，目前主要使用的是 AES 。尽管对称密码能够确保消息的机密性，但需要解决将解密密钥配送给接受者的密钥配送问题。</p><p>（2）公钥密码：是一种用不同的密钥进行加密和解密的技术，和对称密码一样用于确保消息的机密性。使用最广泛的是公钥算法是 RSA ，除此之外，还有 ElGamal 和 Rabin 等算法，以及与其相关 Diffie-Hellman 密钥交换（DH）和椭圆曲线 Diffie-Hellman 密钥交换（ECDH）等技术。和对称密码相比，公钥密钥的速度非常慢，因此一般都会与对称密码一起组成混合密码系统使用。公钥密码能够解决对称密码中的密钥交换问题，但存在通过中间人攻击被伪装的风险，因此需要对带有数字签名的公钥进行认证。</p><p>（3）单向散列函数：是一种将长消息转换为短散列值的技术，用于确保消息的完整性。在单向散列函数的算法方面，SHA-1 曾被广泛使用，但由于人们已经发现了一些针对该算法的理论上可行的攻击方式，因此该算法不应再被用于新的用途，今后我们应该主要使用的算法包括目前已经在广泛使用的 SHA-2（SHA-224、SHA-256、SHA-384、SHA-512），以及具有全新结构的 SHA-3（Keccak）算法。单向散列函数可以单独使用，也可以作为消息认证码、数字签名以及伪随机数生成器等技术的组成元素来使用。</p><p>（4）消息认证码：是一种能够识别通信对象发送的消息是否被篡改的认证技术，用于验证消息的完整性，以及对消息进行认证。消息认证码的算法中，最常用的是利用单向散列函数的 HMAC ，HMAC 的构成不依赖于某一种具体的单向散列函数算法。消息认证码能够对通信对象进行认证，但无法对第三方进行认证，此外也无法防止否认。消息认证码也可以用来实现认证加密。</p><p>（5）数字签名：是一种能够对第三方进行消息认证，并能够防止通信对象作出否认的技术。数字签名的算法包括 RSA 、ElGamal 、DSA 、椭圆曲线 DSA（ECDSA）、爱德华兹曲线 DSA（EDDSA）等。公钥基础设施（PKI）中使用的证书，就是公钥加上认证机构的数字签名所构成的。要验证公钥的数字签名，需要通过某种途径获取认证机构自身的合法公钥。</p><p>（6）伪随机数生成器：是一种能够生成具备不可预测性的比特序列的技术，由密码和单向散列函数等技术构成。用于生成密钥、初始化向量和 nonce 等。</p></li><li><p>密码与认证：认证也是密码技术中重要的组成部分，例如，公钥密码是一种很重要的技术，但如果无法确认自己所持有的公钥的合法性，即是否是经过验证的公钥，公钥密码就无法发挥作用。</p><p>此外，即便在使用高强度的密码算法来确保机密性的情况下，依然存在像填充提示攻击这样通过伪造密文来窃取明文相关信息的攻击方式。在这种情况下，我们需要对接受到的密文进行认证，判断是不是通过合法的加密过程生辰出来的，这样才能有效地确保信息的机密性。</p></li><li><p>密码技术的框架化</p><p>框架的特点就是能够对其中作为组成元素的技术进行替换。例如，消息认证码算法 HMAC 的设计就允许对单向散列函数的算法进行替换，此外，在 PGP 中，对称密码、公钥密码、单向散列函数等都是可以替换的。在 SSL/TLS 中，客户端和服务器可以通过握手协议进行通信，并当场决定所使用的密码套件。</p><p>当然，现实世界中的问题也没有这样单纯，2014 年发现的 POODLE 攻击，就是利用 SSL/TLS 在握手协议中确定密码套件的机制来对协议的版本来进行强制降级的，这可以说是一种针对 SSL/TLS<br>框架本身的攻击。</p></li><li><p>密码技术与压缩技术</p><p>在密码学家的工具箱中，所有的技术都可以看成是一种“压缩技术”。</p><p>无论是对称密码还是公钥密码，密码的作用是确保机密性。通过保护较短的密钥来保护较长的明文，这样的做法被称为<strong>机密性的压缩</strong>。</p><p>单向散列函数是用于确认完整性。通过检查较短的散列值来确认较长的明文的完整性，这样的做法可以称为<strong>完整性的压缩</strong>。</p><p>消息认证码和数字签名都是用于认证的技术，但我们并不是直接对较长的消息本身进行认证，而是通过将较长的消息与密钥结合起来，生成较短的比特序列（认证符号）,再通过认证符号进行认证。在消息认证码中，MAC 值就是认证符号，在数字签名中，签名就是认证符号。通过较短的认证符号来对较长的消息进行认证，这样的做法可以称为<strong>认证的压缩</strong>。</p><p>在伪随机数生成器中，要大量生成具备不可预测性的随机数列非常困难，于是我们通过将种子输入伪随机数生成器，生成具备不可预测性的伪随机数列，这可以被称为<strong>不可预测性的压缩</strong>。反过来说，伪随机数生成器是将种子的不可预测性进行了扩张。</p><p>从另一角度总结：</p><pre><code>密钥是机密性的精华散列值是完整性的精华认证符号是认证的精华种子是不可预测性的精华</code></pre></li><li><p>比特币</p><p>比特币于 2009 年被实际运用，随后在世界各国流行起来。2015 年，美国开设了世界上第一家比特币交易所 Coinbase。 </p><p>（1）P2P 网络：比特币体系中没有中央银行，比特币完全依赖于去哪世界所有比特币用户组成的 P2P 网络（Peer to Peer Network）。全世界所有比特币用户的计算机（node 或者 peer）共同保存、验证和使用支撑比特币体系的所有必要信息。</p><p>与其说比特币是一种货币，不如说<strong>比特币是一种基于 P2P 网络的支付结算系统</strong>。</p><p>（2）地址：比特币交易是在<strong>比特币地址</strong>之间完成的，大多数情况下人们会为每一次比特币交易创建不同的地址，当然，在捐赠等场景中，也会反复使用同一个地址。</p><p>比特币使用的地址是由公钥的散列值生成的。具体来说，将椭圆曲线 DSA 的公钥输入 SHA-256 和 RIPEMD-160 两个单项散列函数来求出散列值，为其附加一些信息后再通过 Base58Check 进行编码，转换成字符串。为防止混淆，Base58Check 编码中不使用数字（0）、大写（O）、大写（I）和小写（l）。</p><p>（3）钱包：比特币交易需要客户端，这种客户端叫做钱包。用户可以在自己的计算机和智能手机上安装钱包应用程序，也可以通过提供钱包服务的网站来使用比特币。</p><p>（4）区块链（block chain）：是<strong>保存比特币全部交易记录的公共账薄</strong>，记录了比特币体系中<strong>所有的地址</strong>迄今为止<strong>所有的交易</strong>。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fmsv5011z2j30sg0lc78j.jpg" alt="21"></p><p>（5）区块的添加：比特币的首付款是以交易为单位进行的，若干条交易会被合并为一个区块，并被添加到区块链中，当 P2P 网络确认区块的添加后，相应的交易也就成立了。</p><p>一个区块是由若干条交易以及一个区块头所组成的，区块头保存了“上一个区块的区块头的散列值”，如图所示，其中区块头 2 中保存的散列值 H2 就是根据它前面的区块 1 的区块头 1 计算出来的。此外，区块头中还保存着“本区块所有交易的整体散列值”，如图所示，区块头 2 中的散列值 T2 就是根据区块 2 中记录的所有交易数据计算出的散列值。也就是说，一旦对区块链中的数据进行任何改动，都需要重建所改动的区块之后的所有区块的数据，由此可见，区块头中的两个散列值有效增加了篡改区块链数据的难度。</p><p>区块头中还保存着一个名为 nonce 的任意数值，以及时间戳等信息。</p><p>（6）交易：所谓交易，就是对“从一个地址向另一个地址转移了多少比特币”这一事件的描述。举一个例子，假设 Alice 从 Bob 商店购买了商品，需要向 Bob 商店支付 1 BTC 的贷款。</p><pre><code>Bob 商店创建公钥密钥对（公钥 B 和私钥 b）Bob 商店根据公钥 B 生成地址 B，并发送给 AliceAlice 创建公钥密钥对（公钥 A 和私钥 a）Alice 创建交易：“从地址 A 向地址 B 发送 1 BTC”。此时，Alice 使用私钥 a 对交易签署了数字签名。Alice将这条交易发送至 P2P 网络，即向全世界广播这条交易。随后，Alice 创建的交易与其他一些交易一起被合并为一个区块，并添加到区块链中。添加的区块被 P2P 网络确认后，“从地址 A 向地址 B 发送 1 BTC”的交易就成立了。</code></pre><p>此时，外界并不知道“A 是 Alice 的地址，B 是 Bob 商店的地址”，但是 Alice 需要向 Bob 商店付款，Bob 商店也需要从 Alice 处收款，因此这条交易到底是谁把钱付给谁，至少 Alice 和 Bob 商店是要知道的。Alice 和 Bob 商店之间的身份确认，需要通过社交网络、电子邮件、网站等比特币系统之外的渠道进行。</p><p>当交易被合并到区块，并被添加到区块链后，地址 A 能够支付的金额就减少了 1 BTC，而地址 B 能够支付的金额则增加了 1 BTC。</p><p>在创建交易时运用了数字签名技术，比特币中使用的数字签名算法为椭圆曲线 DSA，其中使用的椭圆曲线方程为 x<sup>2</sup> = y<sup>3</sup> + 7</p><p>（7）挖矿：随着全世界的比特币不断增加，区块链也会随之不断增长，这就意味着 P2P 网络中的“某个人”在负责将新的区块添加到区块链。“将新的区块添加到区块链”这一行为，正好就相当于“创造新的比特币余额”。向区块链添加区块就好像从金矿中挖出比特币一样，因此称为<strong>挖矿</strong>，而从事挖矿的人则称为<strong>矿工</strong>。</p><p>由于区块链是一条单链，因此在某个特定的时间点只能向其中添加一个区块，按照比特币协议的规定，成功将区块添加到区块链的矿工，将获得挖矿奖励以及该区块所有交易的<strong>手续费</strong>（transaction fee）。</p><p>为了防止比特币被伪造，矿工必须证明自己确实完成了规定量的工作，这种证明被称为<strong>工作量证明</strong>（Proof of Work，PoW），工作量证明是通过散列值来实现的。</p><p>要向区块链添加新的区块，矿工需要生成合法的区块头，而且区块头中“前一区块的散列值”的格式是有规定的，它的前面的若干个比特必须为 0 。上图中的散列值 H2 可能是下面这样的值。</p><pre><code>00000000000000007780B6F7B32254538D2DA45DE67777</code></pre><p>区块头中之所以需要一个称为 nonce 的任意数值，就是为了凑出像上面这样前面若干比特都是 0 的散列值，也就是说，矿工需要不断更换 nonce 进行尝试，直到计算出符合要求的散列值为止。</p><p>这个过程实际上和暴力破解单向散列函数十分相似，这只是为了证明某个矿工确实投入了大量的计算资源来完成工作。比特币系统中大约每 10 分钟会添加一个新的区块，为了保持这样的恒定速率，计算的难度会不断地调整。</p><p>（8）确认：由于全世界有大量的矿工在不断尝试添加新的区块，因此如果在某一时间点上有多个矿工同时计算出了符合要求的散列值，区块链就可能产生分支。由于比特币是一个 P2P 网络，因此无法确定是哪一个区块先达到的节点，比如节点 1 可能先收到区块 A，节点 2 可能先收到 区块 B ，这样就会造成节点 1 和节点 2 的区块链产生差异。到底哪个区块才应该被添加到区块中呢？P2P 网络需要对此作出判断，这个动作称为确认。当产生分支时，P2P 网络的各个节点会选择计算量大的分支继续工作，从而抑制区块链继续产生分支。比特币系统假设善意的矿工所拥有的计算资源要大于恶意的矿工所拥有的计算资源，这也就是比特币系统得以正常运转的前提。</p><p>（9）匿名性：我们需要正确理解比特币的匿名性，诚然，在钱包中生成地址时，我们不需要将这个地址和自己的身份进行关联，也没有必要把自己的身份告诉交易对象，从这点来看，比特币交易的确是匿名的。</p><p>然而，之前的讲解有提到，某个地址所进行的交易会公开给全世界所有用户，而且交易记录也会近似永远留在区块链上，因此，通常用户不会同一个地址反复进行交易。</p><p>此外，商品交易中本来就需要一定程度上公开身份信息，不然你也没办法收到商品。而且，P2P 网络的性质决定了某条交易所对应的节点 IP 是需要被记录的，这也产生了一定的风险。</p><p>（10）信任的意义：</p><p>比特币系统具有以下三层含义的信任：</p><pre><code>信任使用比特币进行交易的对象信任比特币交易所信任比特币系统</code></pre><p>“信任使用比特币进行交易的对象”与信任使用现金进行交易的对象是差不多的。</p><p>“信任比特币交易所”与信任存款的银行是差不多的。</p><p>“信任比特币系统”相当于信任比特币所使用的密码技术以及用于实现这些密码技术的钱包等软件。</p></li></ul><table><thead><tr><th style="text-align:center">比特币</th><th style="text-align:center">单位(缩写)</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">bitcoin(BTC)</td></tr><tr><td style="text-align:center">0.01</td><td style="text-align:center">bitcent(cBTC)</td></tr><tr><td style="text-align:center">0.001</td><td style="text-align:center">millibitcoin(mBTC)</td></tr><tr><td style="text-align:center">0.0000001</td><td style="text-align:center">microbitcoin(uBTC)</td></tr><tr><td style="text-align:center">0.00000001</td><td style="text-align:center">satoshi</td></tr></tbody></table><ul><li><p>量子密码：是基于量子理论的通信技术，由 Bennett 和 Brassard 与 20 世纪 80 年代提出，严格来说，并没有直接构成一种密码体系，而是一种让通信本身不可窃听的技术，可以理解是一种利用光子的量子特性来实现通信的方法。</p><pre><code>利用了下列两个事实：（1）从原理上说，无法准确测出光子的偏振方向     根据这一事实，可以让窃听得到的内容变得不正确（2）测量行为本身会导致光子的状态发生改变     根据这一事实，接受者可以判断通信是否被窃听</code></pre><p>一次性密码本的最大问题在于难以发送和明文具有相同长度的大量密钥，然而如果使用量子密码来发送密钥，接受者就可以识别出密钥是否被窃听，量子密码让一次性密码本的实现更进了一步。</p><p>量子密码有很多方法正在研究之中，BB84 协议用 4 个量子状态代表 1 比特的信息，B92 协议用 2 个量子状态代表 1 比特的信息，E91 协议和 BB84 协议等价，但它采用相互纠缠（entangled）的一对光子来实现的，量子纠缠是一种量子现象，只要测定其中一个量子的状态，就可以确定相距很远的另一个光子的状态。</p><p>（1）量子计算机：由英国物理学家 David Deutsch 于 1985 年提出，根据量子理论，粒子可同时具有多种状态，如果使用具有多种状态的粒子进行计算，则可以同时完成多种状态的计算。如果一个粒子能够计算 0 或 1 两种状态，那么 128 个这样的粒子就可以同时计算 2<sup>128</sup> 种状态，换句话说，这就是一台超级并行计算机。目前量子计算机还未达到实用的程度，但相关研究正在如火如荼开展。</p><p>（2）量子密码与量子计算机：如果量子密码比量子计算机先进入实用领域，则可以使用量子密码来实现一次性密码本，从而产生完美的密码技术，由于一次性密码本是无法破译的，因此即便使用量子计算机也无法破译，即便它快速完成暴力破解，也无法判断到底哪一个才是正确的密钥。</p><p>如果量子计算机比量子密码先进入使用领域，则使用目前的密码技术所产生的密文将会全部被破译。</p><p>在量子计算机出现后依然能够抵抗破译的密码称为<strong>耐量子密码</strong>或者<strong>后量子密码</strong>（Post-Quantum Cryptography，PQCrypto ），其中有一种算法叫做<strong>多变量公钥密码</strong>（Multivariate Public Key Cryptosystem），它利用的是 NP 完全问题的复杂度。</p></li><li><p>人是密码技术中最大的弱点：</p><p>（1）采用生物信息的认证技术（<strong>生物识别认证</strong>，biometric authentication）也并不是完美的认证，要进行生物识别认证，就必须在某个时间点上将生物信息转换为比特序列，实际的认证是通过转换后的比特序列来完成的，一旦比特序列被窃取，就会和钥匙被偷产生相同的后果。</p><p>（2）防御必须天衣无缝，攻击只需突破一点。</p><p>（3）社会工程学（social enginneering）攻击，<strong>信息安全在于流程而非产品</strong>，不能因为购买了安全产品就认为可以高枕无忧了，还必须让系统相关的所有人员保持较高的安全意识。</p><p>（4）拒绝服务攻击（Denial of Service Attack），也称为 <strong>DoS 攻击</strong>，拒绝服务攻击是一种针对服务<strong>可用性</strong>（availablility）的攻击方式。拒绝服务攻击并非只是无法使用服务这么简单，当安全性较高的服务瘫痪时，用户往往会自发地转移到安全性较低的服务，通过拒绝服务攻击，可以让窃听等其他攻击更加容易。</p></li></ul><h2 id="附录、椭圆曲线密码"><a href="#附录、椭圆曲线密码" class="headerlink" title="附录、椭圆曲线密码"></a>附录、椭圆曲线密码</h2><ul><li><p>椭圆曲线密码（Elliptic Curve Cryptography，ECC）：是利用椭圆曲线来实现的密码技术的统称，实际上包括以下内容：</p><pre><code>基于椭圆曲线的公钥密码基于椭圆曲线的数字签名基于椭圆曲线的密钥交换</code></pre><p>椭圆曲线目前正被广泛使用，例如在 SSL/TLS 中，就使用了椭圆曲线 Diffie-Hellman 密钥交换（ECDH、ECDHE）和椭圆曲线 DSA（ECDSA），比特币中也是用了椭圆曲线 DSA 。</p><p><strong>椭圆曲线密码密钥短但强度高</strong>。</p><p>椭圆曲线（Elliptic Curve，EC）实际上并不是椭圆形，之所以叫椭圆曲线源自于求椭圆弧长的椭圆积分的反函数。</p><p>一般来说，椭圆曲线可用下列方程式表示，其中 <em>a</em> ，<em>b</em> ，<em>c</em> ，<em>d</em> 为系数。</p><blockquote><p><em>E</em> : <em>y</em> <sup>2</sup> = <em>a**x</em> <sup>3</sup> + <em>b**x</em> <sup>2</sup> + <em>c**x</em> + d</p></blockquote></li><li><p>椭圆曲线运算：</p><p>（1）椭圆曲线上的加法运算：过曲线上两点 <em>A</em>，<em>B</em> 画一条直线，找到直线与椭圆曲线的交点，我们将该交点关于 <em>x</em> 轴对称位置的点定义为 <em>A</em> + <em>B</em> 。</p><p>（2）椭圆曲线上的二倍运算：若出现两点重合的情况，因为无法画出两点的直线，因此我们画出点 <em>A</em> 的切线，然后找到该切线与椭圆曲线的交点，将该点关于 <em>x</em> 轴对称位置的点定义为 <em>A</em> + <em>A</em> 。</p><p>（3）椭圆曲线上的正负取反运算：将点 <em>A</em> 关于 <em>x</em> 轴对称位置的点定义为 -<em>A</em> 。</p><p>将 <em>A</em> 和 -<em>A</em> 相加会怎样，根据椭圆曲线的定义，我们应该找到过点 <em>A</em> 和点 -<em>A</em> 的直线与椭圆曲线的交点，但过点 <em>A</em> 和点 -<em>A</em> 的直线与椭圆曲线之间只有点 <em>A</em> 和点 -<em>A</em> 这两个交点，于是我们认为这条直线与椭圆曲线在“无限远点”的位置相交。这个无限远点在图像上画不出来，我们将其记作 <em>O</em> 。可以发现，无限远点 <em>O</em> 的作用和数字 0 相近，<em>A</em> + (-<em>A</em>) = <em>O</em> 是永远成立的。</p><p>基于上述运算规则，给定椭圆曲线上的某一点 <em>G</em> ，“已知数 <em>x</em> 求点 <em>xG</em> 的问题”并不困难，反过来，“已知点 <em>xG</em> 求数 <em>x</em> 的问题”则非常困难，这就是椭圆曲线密码中利用的离散对数问题。</p></li><li><p>椭圆曲线上的离散对数问题：</p><p>在椭圆曲线密码中，我们首先确定一条椭圆曲线，然后对椭圆曲线上的某一些点（以及无限远点）之间的“运算”进行定义，并用这些“运算”来进行密码技术相关的计算。</p><p>椭圆曲线利用了上述“运算”中“椭圆曲线上的离散对数问题”的复杂度，就像 RSA 利用了“质因数分解”的复杂度，以及 ElGamal 密码和 Diffie-Hellman 密钥交换利用了“有限域上的离散对数问题”的复杂度一样。</p><p>椭圆曲线上的离散对数问题（Elliptic Curve Discrete Logarithm Problem，ECDLP），其本质就是“已知点 <em>xG</em> 求数 <em>x</em> 的问题” 。</p><pre><code>椭圆曲线上的离散对数问题：已知：椭圆曲线 *E*椭圆曲线 *E* 上的一点 *G*（基点）椭圆曲线 *E* 上的一点 *xG* （*G* 的 *x* 倍）求：数 *x*</code></pre></li><li><p>有限域上的椭圆曲线运算：</p><p>其实椭圆曲线密码所使用的椭圆曲线运算，并不是在之前所讲的那种光滑曲线上进行的。</p><p>椭圆曲线上的图像要形成一条光滑的曲线，其坐标 <em>x</em>，<em>y</em> 必须都是实数，即“实数域 R 上的椭圆曲线”。</p><p>椭圆曲线密码所使用的椭圆曲线并非是在实数域 R 上，而是在有限域 F<sub>p</sub> 上。有限域 F<sub>p</sub> 是指对于某个给定的质数 <em>p</em> ，由 0，1，…, <em>p</em> -1 共 <em>p</em> 个元素所组成的整数集合中定义的加减乘除运算。有限域中的运算就是之间介绍的时钟运算，更直观一点就是用整数来计算坐标，并将结果除以 <em>p</em> 求余数。</p><blockquote><p>实数域 R 上的光滑椭圆曲线：</p></blockquote><blockquote><p><em>E</em> : <em>y</em> <sup>2</sup> = <em>x</em> <sup>3</sup> + <em>x</em> <sup>2</sup> + 1</p></blockquote><blockquote><p>有限域 F<sub>p</sub> 上的椭圆曲线：</p></blockquote><blockquote><p><em>E</em> : <em>y</em> <sup>2</sup> ≡ <em>x</em> <sup>3</sup> + <em>x</em> <sup>2</sup> + 1（mod 23）</p></blockquote></li><li><p>椭圆曲线 Diffie-Hellman 密钥交换：除了运用椭圆曲线这一点之外，它的流程与 Diffie-Hellman 密钥交换基本上是相同的。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fmsv50dxwij30sg0lcdjh.jpg" alt="22"></p><p>非椭圆曲线的 Diffie-Hellman 所利用的是：</p><blockquote><p>以 <em>p</em> 为模， 已知 <em>G</em> 和 <em>G</em><sup><em>x</em></sup> mod <em>p</em> 求 <em>x</em> 的复杂度（有限域上的离散对数问题）</p></blockquote><p>椭圆曲线 Diffie-Hellman 所利用的是：</p><blockquote><p>在椭圆曲线上， 已知点 <em>xG</em> 求数 <em>x</em> 的复杂度（椭圆曲线上的离散对数问题）</p></blockquote><p>交换步骤：</p><p>（1）Alice 向 Bob 发送点 <em>G</em> 。点 <em>G</em> 被 Eve 知道也没关系。</p><p>（2）Alice 生成随机数 <em>a</em> 。这个数没有必要告诉 Bob ，也不能让 Eve 知道。我们将数 <em>a</em> 称为 Alice 的私钥。</p><p>（3）Bob 生成随机数 <em>b</em> 。这个数没有必要告诉 Alice ，也不能让 Eve 知道。我们将数 <em>b</em> 称为 Bob 的私钥。</p><p>（4）Alice 向 Bob 发送点 <em>aG</em> 。点 <em>aG</em> 被 Eve 知道也没关系，它是 Alice 的公钥。</p><p>（5）Bob 向 Alice 发送点 <em>bG</em> 。点 <em>bG</em> 被 Eve 知道也没关系，它是 Bob 的公钥。</p><p>（6）<strong>Alice 对 Bob 发送的点 <em>bG</em> 计算其在椭圆曲线上 <em>a</em> 倍的点</strong>。Alice 在椭圆曲线上计算 <em>a(bG)</em> = <em>abG</em> ，它就是 Alice 与 Bob 的共享密钥。</p><p>（7）相对地，<strong>Bob 对 Alice 发送的点 <em>aG</em> 计算其在椭圆曲线上 <em>b</em> 倍的点</strong>。Alice 在椭圆曲线上计算 <em>b(aG)</em> = <em>abG</em> ，它就是 Alice 与 Bob 的共享密钥。</p><p>在椭圆曲线 Diffie-Hellman 密钥交换时，生成共享密钥需要使用随机数 <em>a</em>、<em>b</em>。如果每次通信都使用不同的随机数，则共享密钥也会随之改变。这样依赖，即便某个时间点的通信被破解，也无需担心在此之前的通信内容被破解。这样的特性称为<strong>前向安全性</strong>（Forward Secrecy，FS）或者完全前向安全性（Perfect Forward Secrecy，PFS）。 </p></li><li><p>椭圆曲线 ElGamal 密码：</p><p>通过椭圆曲线 Diffie-Hellman 密钥交换，Alice 和 Bob 能够生成共享密钥 <em>abG</em> 。利用共享密钥 <em>abG</em> 就可以很容易地实现椭圆曲线 EIGamal 密码。</p><p>假设 Alice 要向 Bob 发送一条消息，Alice 可以将自己要发送的消息用椭圆曲线上的一个点 <em>M</em> 来表示（实际上使用的是该点的 <em>x</em> 坐标）。</p><p>加密：</p><p>（1）Alice 用自己的私钥 <em>a</em> 以及 Bob 的公钥 <em>bG</em> ，对消息 <em>M</em> 计算点 <em>M</em> + <em>abG</em> 。此点 <em>M</em> + <em>abG</em> 就是密文。</p><p>（2）Alice 将密文 <em>M</em> + <em>abG</em> 发送给 Bob 。</p><p>解密：</p><p>（1）Bob 接受到密文 <em>M</em> + <em>abG</em> 。</p><p>（2）Bob 用 Alice 的公钥 <em>aG</em> 以及自己的私钥 <em>b</em> 计算出了共享密钥 <em>abG</em> 。</p><p>（3）Bob 将收到的密文 <em>M</em> + <em>abG</em> 减去共享密钥 <em>abG</em> 得到消息 <em>M</em> 。 </p></li><li><p>椭圆曲线 DSA（ECDSA）：使用椭圆曲线还可以实现数字签名。</p><p>假设 Alice 要对消息 <em>m</em> ，而 Bob 需要验证签名。以下写着“计算”的部分都代表以 <em>p</em> 为模的时钟运算。</p><blockquote><p>生成数字签名：</p></blockquote><p>（1）Alice 根据随机数 <em>r</em> 和基点 <em>G</em> 求出点 <em>rG</em> =（x，y）。</p><p>（2）Alice 根据随机数 <em>r</em> 、消息 <em>m</em> 的散列值 <em>h</em> 、私钥 <em>a</em> 计算  $ s=\frac{h+ax}{r} $ 。</p><p>（3）最后，Alice 将消息 <em>m</em> 、点 <em>rG</em> = （x，y）和 s 发送给 Bob，其中点 <em>rG</em> 和 <em>s</em> 就是数字签名</p><blockquote><p>验证数字签名：</p></blockquote><p>（1）Bob 接受到消息 <em>m</em> 、点 <em>rG</em> = （x，y）和 <em>s</em> 。</p><p>（2）Bob 根据消息 <em>m</em> 求出散列值 <em>h</em> 。</p><p>（3）最后，Bob 根据上述消息，用 Alice 的公钥进行一下计算。</p><p>$$\frac{h}{s}G+\frac{x}{s}(aG)$$ </p><p>并将结果与 <em>rG</em> 进行比较。</p><p>如果数字签名正确，则计算结果应如下所示。</p><p>$$\frac{h}{s}G+\frac{x}{s}(aG)=\frac{h+ax}{s}G$$<br>$$=\frac{r(h+ax)}{h+ax}G$$<br>$$=rG$$</p><p>由于攻击者没有 Alice 私钥，因此无法计算出合法的 <em>s</em> ，此外，即便是对于同一条消息，只要改变随机数 <em>r</em> ，所得带的数字签名也会随之改变。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default&quot;&gt;&lt;/script&gt;

&lt;blockquote&gt;
&lt;p&gt;本文整理自《图解密码技术
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>壹伍零壹</title>
    <link href="http://yoursite.com/2017/10/24/1501/"/>
    <id>http://yoursite.com/2017/10/24/1501/</id>
    <published>2017-10-23T16:00:00.000Z</published>
    <updated>2017-12-26T01:24:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;像是了一桩心事，像是自我娱乐了一番。</p><p>&emsp;&emsp;如果真能如我所愿，再好不过，是我过分自私了，你们要去哪，不该由我问。</p><p>&emsp;&emsp;我们共存于同一个物理空间，却是完全不同的人。</p><p>&emsp;&emsp;不打开盒子猫就不会死。</p><p>&emsp;&emsp;怎好意思感叹。</p><p>&emsp;&emsp;祝各位前程似锦。</p><h5 id="阿姆斯特丹-水坝广场"><a href="#阿姆斯特丹-水坝广场" class="headerlink" title="阿姆斯特丹 水坝广场"></a>阿姆斯特丹 水坝广场</h5><p><img src="https://i.loli.net/2017/10/24/59eedd594a642.png" alt="image"></p><h5 id="奥斯陆-雕塑公园"><a href="#奥斯陆-雕塑公园" class="headerlink" title="奥斯陆 雕塑公园"></a>奥斯陆 雕塑公园</h5><p><img src="https://i.loli.net/2017/10/24/59eedd7ce0256.png" alt="image"></p><h5 id="巴黎-凯旋门"><a href="#巴黎-凯旋门" class="headerlink" title="巴黎 凯旋门"></a>巴黎 凯旋门</h5><p><img src="https://i.loli.net/2017/10/24/59eedd9f8272a.png" alt="image"></p><h5 id="巴塞罗那-毕加索博物馆"><a href="#巴塞罗那-毕加索博物馆" class="headerlink" title="巴塞罗那  毕加索博物馆"></a>巴塞罗那  毕加索博物馆</h5><p><img src="https://i.loli.net/2017/10/24/59eeddbc2a58d.png" alt="image"></p><h5 id="巴塞罗那-诺坎普球场"><a href="#巴塞罗那-诺坎普球场" class="headerlink" title="巴塞罗那 诺坎普球场"></a>巴塞罗那 诺坎普球场</h5><p><img src="https://i.loli.net/2017/10/24/59eeddd91a311.png" alt="image"></p><h5 id="柏林-勃兰登堡门"><a href="#柏林-勃兰登堡门" class="headerlink" title="柏林 勃兰登堡门"></a>柏林 勃兰登堡门</h5><p><img src="https://i.loli.net/2017/10/24/59eede13d1668.png" alt="image"></p><h5 id="雷克雅未克-国家博物馆"><a href="#雷克雅未克-国家博物馆" class="headerlink" title="雷克雅未克 国家博物馆"></a>雷克雅未克 国家博物馆</h5><p><img src="https://i.loli.net/2017/10/24/59eede39904a0.png" alt="image"></p><h5 id="雷克雅未克-托宁湖"><a href="#雷克雅未克-托宁湖" class="headerlink" title="雷克雅未克 托宁湖"></a>雷克雅未克 托宁湖</h5><p><img src="https://i.loli.net/2017/10/24/59eeded6a1209.png" alt="image"></p><h5 id="伯明翰大学"><a href="#伯明翰大学" class="headerlink" title="伯明翰大学"></a>伯明翰大学</h5><p><img src="https://i.loli.net/2017/10/24/59eedef6aae39.png" alt="image"></p><h5 id="布拉格-查理大桥"><a href="#布拉格-查理大桥" class="headerlink" title="布拉格 查理大桥"></a>布拉格 查理大桥</h5><p><img src="https://i.loli.net/2017/10/24/59eedf0997263.png" alt="image"></p><h5 id="布拉格广场"><a href="#布拉格广场" class="headerlink" title="布拉格广场"></a>布拉格广场</h5><p><img src="https://i.loli.net/2017/10/24/59eedf3f87273.png" alt="image"></p><h5 id="大阪-心斋桥"><a href="#大阪-心斋桥" class="headerlink" title="大阪 心斋桥"></a>大阪 心斋桥</h5><p><img src="https://i.loli.net/2017/10/24/59eedf5bf0bc8.png" alt="image"></p><h5 id="底特律河"><a href="#底特律河" class="headerlink" title="底特律河"></a>底特律河</h5><p><img src="https://i.loli.net/2017/10/24/59eedf7016af1.png" alt="image"></p><h5 id="东京-歌舞伎町"><a href="#东京-歌舞伎町" class="headerlink" title="东京 歌舞伎町"></a>东京 歌舞伎町</h5><p><img src="https://i.loli.net/2017/10/24/59eedf866d04e.png" alt="image"></p><h5 id="东京-天空树"><a href="#东京-天空树" class="headerlink" title="东京 天空树"></a>东京 天空树</h5><p><img src="https://i.loli.net/2017/10/24/59eedf96ee5a6.png" alt="image"></p><h5 id="东京-银座"><a href="#东京-银座" class="headerlink" title="东京 银座"></a>东京 银座</h5><p><img src="https://ooo.0o0.ooo/2017/10/24/59eedffbee61d.png" alt="image"></p><h5 id="多伦多大学"><a href="#多伦多大学" class="headerlink" title="多伦多大学"></a>多伦多大学</h5><p><img src="https://i.loli.net/2017/10/24/59eee0452acb1.png" alt="image"></p><h5 id="多伦多-皇后西街"><a href="#多伦多-皇后西街" class="headerlink" title="多伦多 皇后西街"></a>多伦多 皇后西街</h5><p><img src="https://i.loli.net/2017/10/24/59eee05087f88.png" alt="image"></p><h5 id="法兰克福-美因河畔"><a href="#法兰克福-美因河畔" class="headerlink" title="法兰克福 美因河畔"></a>法兰克福 美因河畔</h5><p><img src="https://i.loli.net/2017/10/24/59eee076769c4.png" alt="image"></p><h5 id="佛罗伦萨-美术学院"><a href="#佛罗伦萨-美术学院" class="headerlink" title="佛罗伦萨 美术学院"></a>佛罗伦萨 美术学院</h5><p><img src="https://i.loli.net/2017/10/24/59eee08739227.png" alt="image"></p><h5 id="哥本哈根-菲特烈堡"><a href="#哥本哈根-菲特烈堡" class="headerlink" title="哥本哈根 菲特烈堡"></a>哥本哈根 菲特烈堡</h5><p><img src="https://i.loli.net/2017/10/24/59eee09116418.png" alt="image"></p><h5 id="北京-故宫博物院"><a href="#北京-故宫博物院" class="headerlink" title="北京 故宫博物院"></a>北京 故宫博物院</h5><p><img src="https://i.loli.net/2017/10/24/59eee08909143.png" alt="image"></p><h5 id="海德堡城堡"><a href="#海德堡城堡" class="headerlink" title="海德堡城堡"></a>海德堡城堡</h5><p><img src="https://i.loli.net/2017/10/24/59eee09797260.png" alt="image"></p><h5 id="华盛顿-杜邦圆环"><a href="#华盛顿-杜邦圆环" class="headerlink" title="华盛顿 杜邦圆环"></a>华盛顿 杜邦圆环</h5><p><img src="https://ooo.0o0.ooo/2017/10/24/59eee098a537a.png" alt="image"></p><h5 id="惠灵顿-国会大厦"><a href="#惠灵顿-国会大厦" class="headerlink" title="惠灵顿 国会大厦"></a>惠灵顿 国会大厦</h5><p><img src="https://i.loli.net/2017/10/24/59eee117af6a7.png" alt="image"></p><h5 id="加的夫-神秘博士博物馆"><a href="#加的夫-神秘博士博物馆" class="headerlink" title="加的夫 神秘博士博物馆"></a>加的夫 神秘博士博物馆</h5><p><img src="https://ooo.0o0.ooo/2017/10/24/59eee115c89f4.png" alt="image"></p><h5 id="京都-二条城"><a href="#京都-二条城" class="headerlink" title="京都 二条城"></a>京都 二条城</h5><p><img src="https://i.loli.net/2017/10/24/59eee117ab46d.png" alt="image"></p><h5 id="旧金山大桥"><a href="#旧金山大桥" class="headerlink" title="旧金山大桥"></a>旧金山大桥</h5><p><img src="https://i.loli.net/2017/10/24/59eee11669db7.png" alt="image"></p><h5 id="旧金山-市政厅"><a href="#旧金山-市政厅" class="headerlink" title="旧金山 市政厅"></a>旧金山 市政厅</h5><p><img src="https://i.loli.net/2017/10/24/59eee1192ddf7.png" alt="image"></p><h5 id="卡萨布兰卡-哈桑二世清真寺"><a href="#卡萨布兰卡-哈桑二世清真寺" class="headerlink" title="卡萨布兰卡 哈桑二世清真寺"></a>卡萨布兰卡 哈桑二世清真寺</h5><p><img src="https://i.loli.net/2017/10/24/59eee19354593.png" alt="image"></p><h5 id="开罗-解放广场"><a href="#开罗-解放广场" class="headerlink" title="开罗 解放广场"></a>开罗 解放广场</h5><p><img src="https://ooo.0o0.ooo/2017/10/24/59eee1bc24c98.png" alt="image"></p><h5 id="利物浦-市中心"><a href="#利物浦-市中心" class="headerlink" title="利物浦 市中心"></a>利物浦 市中心</h5><p><img src="https://i.loli.net/2017/10/24/59eee1c1a7054.png" alt="image"></p><h5 id="伦敦-大笨钟"><a href="#伦敦-大笨钟" class="headerlink" title="伦敦 大笨钟"></a>伦敦 大笨钟</h5><p><img src="https://i.loli.net/2017/10/24/59eee1c1abcd8.png" alt="image"></p><h5 id="伦敦-塔桥"><a href="#伦敦-塔桥" class="headerlink" title="伦敦 塔桥"></a>伦敦 塔桥</h5><p><img src="https://i.loli.net/2017/10/24/59eee1c315ea8.png" alt="image"></p><h5 id="罗马-斗兽场"><a href="#罗马-斗兽场" class="headerlink" title="罗马 斗兽场"></a>罗马 斗兽场</h5><p><img src="https://i.loli.net/2017/10/24/59eee1c3ceed1.png" alt="image"></p><h5 id="曼谷-大皇宫"><a href="#曼谷-大皇宫" class="headerlink" title="曼谷 大皇宫"></a>曼谷 大皇宫</h5><p><img src="https://i.loli.net/2017/10/24/59eee1bd3de64.png" alt="image"></p><h5 id="名古屋-电视塔"><a href="#名古屋-电视塔" class="headerlink" title="名古屋 电视塔"></a>名古屋 电视塔</h5><p><img src="https://i.loli.net/2017/10/24/59eee1bc1e983.png" alt="image"></p><h5 id="墨尔本-唐人街"><a href="#墨尔本-唐人街" class="headerlink" title="墨尔本 唐人街"></a>墨尔本 唐人街</h5><p><img src="https://i.loli.net/2017/10/24/59eee1c3ceed4.png" alt="image"></p><h5 id="南京-中山陵"><a href="#南京-中山陵" class="headerlink" title="南京 中山陵"></a>南京 中山陵</h5><p><img src="https://i.loli.net/2017/10/24/59eee27dc6597.png" alt="image"></p><h5 id="纽约-帝国大厦"><a href="#纽约-帝国大厦" class="headerlink" title="纽约 帝国大厦"></a>纽约 帝国大厦</h5><p><img src="https://i.loli.net/2017/10/24/59eee28233fe5.png" alt="image"></p><h5 id="纽约-中央公园"><a href="#纽约-中央公园" class="headerlink" title="纽约 中央公园"></a>纽约 中央公园</h5><p><img src="https://ooo.0o0.ooo/2017/10/24/59eee2908bf1e.png" alt="image"></p><h5 id="日内瓦湖"><a href="#日内瓦湖" class="headerlink" title="日内瓦湖"></a>日内瓦湖</h5><p><img src="https://i.loli.net/2017/10/24/59eee29051595.png" alt="image"></p><h5 id="格林瓦德"><a href="#格林瓦德" class="headerlink" title="格林瓦德"></a>格林瓦德</h5><p><img src="https://i.loli.net/2017/10/24/59eee28d742b5.png" alt="image"></p><h5 id="厦门大学"><a href="#厦门大学" class="headerlink" title="厦门大学"></a>厦门大学</h5><p><img src="https://i.loli.net/2017/10/24/59eee289a0871.png" alt="image"></p><h5 id="斯德哥尔摩-瑞典皇宫"><a href="#斯德哥尔摩-瑞典皇宫" class="headerlink" title="斯德哥尔摩  瑞典皇宫"></a>斯德哥尔摩  瑞典皇宫</h5><p><img src="https://i.loli.net/2017/10/24/59eee29112d6c.png" alt="image"></p><h5 id="苏黎世-国家博物馆"><a href="#苏黎世-国家博物馆" class="headerlink" title="苏黎世 国家博物馆"></a>苏黎世 国家博物馆</h5><p><img src="https://i.loli.net/2017/10/24/59eee291c8655.png" alt="image"></p><h5 id="台北-101大厦"><a href="#台北-101大厦" class="headerlink" title="台北 101大厦"></a>台北 101大厦</h5><p><img src="https://i.loli.net/2017/10/24/59eee28f1fb93.png" alt="image"></p><h5 id="武藏野美术大学"><a href="#武藏野美术大学" class="headerlink" title="武藏野美术大学"></a>武藏野美术大学</h5><p><img src="https://i.loli.net/2017/10/24/59eee302a76e7.png" alt="image"></p><h5 id="西雅图-水族馆"><a href="#西雅图-水族馆" class="headerlink" title="西雅图 水族馆"></a>西雅图 水族馆</h5><p><img src="https://i.loli.net/2017/10/24/59eee31e3be1c.png" alt="image"></p><h5 id="悉尼-邦迪海滩"><a href="#悉尼-邦迪海滩" class="headerlink" title="悉尼 邦迪海滩"></a>悉尼 邦迪海滩</h5><p><img src="https://i.loli.net/2017/10/24/59eee318b541b.png" alt="image"></p><h5 id="香港-维多利亚港"><a href="#香港-维多利亚港" class="headerlink" title="香港 维多利亚港"></a>香港 维多利亚港</h5><p><img src="https://i.loli.net/2017/10/24/59eee31c890f9.png" alt="image"></p><h5 id="新加坡-圣淘沙岛"><a href="#新加坡-圣淘沙岛" class="headerlink" title="新加坡 圣淘沙岛"></a>新加坡 圣淘沙岛</h5><p><img src="https://i.loli.net/2017/10/24/59eee31257c24.png" alt="image"></p><h5 id="新宿-二丁目"><a href="#新宿-二丁目" class="headerlink" title="新宿 二丁目"></a>新宿 二丁目</h5><p><img src="https://i.loli.net/2017/10/24/59eee31ee6069.png" alt="image"></p><h5 id="伊斯坦布尔-清真寺"><a href="#伊斯坦布尔-清真寺" class="headerlink" title="伊斯坦布尔 清真寺"></a>伊斯坦布尔 清真寺</h5><p><img src="https://i.loli.net/2017/10/24/59eee31f6d4d9.png" alt="image"></p><h5 id="札幌-电视塔"><a href="#札幌-电视塔" class="headerlink" title="札幌 电视塔"></a>札幌 电视塔</h5><p><img src="https://i.loli.net/2017/10/24/59eee31cc3b1d.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;像是了一桩心事，像是自我娱乐了一番。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;如果真能如我所愿，再好不过，是我过分自私了，你们要去哪，不该由我问。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;我们共存于同一个物理空间，却是完全不同的人。&lt;/p&gt;
&lt;p&gt;&amp;em
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据新闻作品</title>
    <link href="http://yoursite.com/2017/09/05/dataVisualization/"/>
    <id>http://yoursite.com/2017/09/05/dataVisualization/</id>
    <published>2017-09-04T16:00:00.000Z</published>
    <updated>2018-06-26T14:37:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么样的手机品牌在三四线城市卖得更好？"><a href="#什么样的手机品牌在三四线城市卖得更好？" class="headerlink" title="什么样的手机品牌在三四线城市卖得更好？"></a>什么样的手机品牌在三四线城市卖得更好？</h2><blockquote><p>此文感谢新一线的各位老师</p></blockquote><p>新一酱有一个小问题想问问大家，你觉得什么样的手机品牌在三四线城市会更好卖呢？</p><p>Hmmm，你大概已经能够猜到答案了。为了验证你心里已经有了的答案，新一酱花了3天从高德地图上获取了苹果、三星、华为、OPPO、vivo、小米和魅族这7个主流手机品牌在中国338个地级以上城市销售点的位置信息，结果如下：</p><p><img src="https://ooo.0o0.ooo/2017/09/07/59b12951e837b.png" alt="1"></p><p>尽管新一酱暂时还没有办法拿到各手机品牌在城市的销售额数据，但你依然可以从销售点数量上大致看出问题的答案。</p><p>对比不同城市级别中的7大品牌门店数量，在一线城市，苹果、三星、华为、OPPO和vivo的体量几乎没有差异，但当城市级别开始往低线走，三星和华为是首先退出新一线城市“一城百店”竞争格局的两个品牌。</p><p>苹果经销商失去优势是从三线城市逐步开始的——苹果官方的Apple Store目前还没有进入任何一个中国三线城市，这里的苹果手机都是依靠经销商卖出。最终，OPPO和vivo成为了三四五线城市的最大赢家。</p><p>销售点分布差异的背后，其实与每个品牌的价格定位有关。新一酱又统计了7个手机品牌的在售机型价格区间和均价。</p><p>综合考察它们均价的高低以及定位的目标消费者，你可以很容易将它们分为三类：第一类品牌是苹果、三星和华为组成的高端机阵营，第二类是OPPO和vivo的组合，第三类品牌是擅长做互联网营销而不那么重视线下渠道的小米和魅族。</p><p><img src="https://i.loli.net/2017/09/07/59b129d819ac0.png" alt="2"></p><p>于是新一酱就能解释一部分前面那张门店城市分布图表的原因了——在消费水平更高的一线城市，用户对于高端手机品牌的认同感更强，但五六千元的手机在三线以下城市的消费人群就要小得多了。</p><p>“上海没法跟外地比，你走在大街上看到用得最多的手机肯定是苹果，本地消费者对OPPO的并没有太强的认知。”在上海火车站附近的不夜城商厦7楼做OPPO二级代理商的李家阳对新一酱说。</p><p>李家阳知道在上海这样的一线城市做OPPO的生意并不是最好的选择，但两年前第一次来到不夜城商厦的时候，他仍然看到了商家身上可以挖掘的潜力。</p><p>以OPPO最新的机型R11为例，上海的经销商从李家阳手上拿货之后，每台可以保证大约400元的毛利，并且不用“背库存”——销售点的经销商不用准备货款，只要向像李家阳这样更高级别的代理商提货销售，最后与代理商直接结算利润。此外，代理商还会负责店面的装修。</p><p>对于不夜城的商铺小老板来说，这比卖其他品牌的手机更有利可图。可想而知，如果到了物价水平更低的低线城市，这样的毛利意味着更高的收入。“现在做手机这个行当，除了二手机和维修手机，利润最高的就是卖OPPO和vivo了。”李家阳这样对新一酱表示。</p><p>新一酱用7个手机品牌在全国的销售点信息计算出了每一个城市的人均手机销售点的拥有量。其中东莞每1万人拥有的品牌手机销售点数达到了2.55家，是这个数字最高的城市。</p><p><img src="https://ooo.0o0.ooo/2017/09/07/59b12a8c9c9fd.png" alt="3"></p><p>不过一线城市仍然是人均手机销售点城市均值最高区域，同时也是手机品牌竞争最为激烈的区域。</p><p>不同于低线城市，OPPO在一线城市的策略更侧重于品牌形象的搭建，而不是单纯地比拼销售点数量的增长。一位OPPO总部的工作人员介绍说，一线城市要求店铺装修更精、质感更好，销售点的并不追求数量，不是照搬在三四线城市的做法。</p><p>根据新一酱的了解，OPPO的线下渠道早在“步步高时代”（关于步步高、OPPO、vivo之间有一段错综复杂的关系，新一酱这里就不赘述了，有兴趣的自行度娘哦）就已成体系。现在OPPO在全国共设有36个一级代理商，在一级代理商之下设二级代理商，二级代理商再往下便是当地的经销商。</p><p>李家阳就属于上海地区负责数码市场的二级代理商。除了给经销商供货，并帮助他们完成门店的装修，李家阳也会开设自己经营的、规模更大的品牌体验店。这样的体验店选址更讲究，通常会在人流量大、商业氛围较好的地段。</p><p>截至目前，OPPO在上海已有101家这样的形象体验店在营业，更多体验店的开业也已被提上日程。按照李家阳的说法，接下来开业的体验店的装修风格也会转型，“更苹果化”——在描述这种风格时，他觉得这样是最贴切的形容了。</p><p><img src="https://i.loli.net/2017/09/07/59b12af1b9462.gif" alt="4"></p><p>你可以从上面的图中看出在上海不同类别的手机品牌销售点与商业资源之间的分布关系——灰色的背景是上海整体的商业资源布局情况，颜色源深代表商业资源越集聚，彩色的点是各类手机品牌的具体位置。</p><p>新一酱发现OPPO、vivo的销售点分布比其他品牌更为均匀，没有集中分布于商业资源较集中的区域。相反，Ⅰ类的苹果、三星和华为的销售点集中分布于市中心或副中心的繁华地带，属于Ⅲ类的小米和魅族因为策略不支持大量铺设线下渠道铺设，门店更偏向于形象的展示，分布形态上与Ⅰ类相似，甚至上海销售点所在栅格的商业均值比Ⅰ类品牌更高。</p><p><img src="https://i.loli.net/2017/09/07/59b12b130d291.gif" alt="5"></p><p>佛山的情况也类似。OPPO和vivo的手机销售点所在栅格的商业均值明显的低于Ⅰ类和Ⅲ类手机品牌。</p><p>新一酱没有找到佛山的经销商，但是佛山却和李家阳描述的另一个城市——苏州很类似，它们都有成片的制造业工厂，这些工厂周边是Ⅰ类和Ⅲ类手机品牌不会涉足的地方，但OPPO和vivo都渗透了进去。</p><p><img src="https://i.loli.net/2017/09/07/59b12b3b6acdd.gif" alt="6"></p><p>OPPO和vivo已经完全占领了三线城市商丘，它们不仅仅抓住了商业资源分布最密集的中心区域，而且也大量分布于商业资源稀疏的乡镇区域——比起只到县城的Ⅰ类和Ⅲ类手机品牌，这可深入多了。</p><p>商丘的形态勾起了新一酱的好奇心，想要进一步研究每家OPPO销售点的服务范围内有多少家竞争对手，为此引入了一个新的计算方式——泰森多边形。</p><p>泰森多边形是对空间平面的一种分割方法，其特点是多边形内的任何位置离该多边形的离散点的距离最近，离相邻多边形内离散点的距离远，且每个多边形内含且仅包含一个离散点。简单点讲，它给任意两家店之间划分了中线，这些线条围成的几何形态就是店铺的服务范围。</p><p>在用商丘所有的OPPO销售点位置计算了泰森多边形后，新一酱又将其他6个手机品牌的销售点都投影了上去。结果更明显了，在商丘，每家OPPO销售点覆盖的区域比上海、佛山更广，且到乡镇级别后几乎没有竞争对手。</p><p><img src="https://i.loli.net/2017/09/07/59b12b48bf743.png" alt="7"></p><p>用数据的表达是：如果计算每家OPPO销售点服务范围内的竞争对手数量（即每个泰森多边形内其他点的数量），上海的平均值是3.59，佛山是2.38，而商丘的这个数值只有0.49。</p><p>从上海到佛山再到商丘，城市的等级在不断地下降，同时OPPO销售点服务范围内的竞争对手的数量也在下降，OPPO通过渠道的不断下沉最终在三四线城市确立起了优势地位。</p><p>“上海今年的销售量增加比全国其他城市偏少，总部这个月刚给我们下了业务增长的军令状。”李家阳说。不过对于OPPO来说，真正的市场是不是在上海，只有它自己最清楚。  </p><p><br><br><br>文/杨子豪</p><p>视觉/朱颖伦 王方宏</p><blockquote><p><em>新一线城市研究所拥有文章版权</em></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么样的手机品牌在三四线城市卖得更好？&quot;&gt;&lt;a href=&quot;#什么样的手机品牌在三四线城市卖得更好？&quot; class=&quot;headerlink&quot; title=&quot;什么样的手机品牌在三四线城市卖得更好？&quot;&gt;&lt;/a&gt;什么样的手机品牌在三四线城市卖得更好？&lt;/h2&gt;&lt;bloc
      
    
    </summary>
    
    
  </entry>
  
</feed>
