<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Autobiography</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-01T13:29:16.152Z</updated>
  <id>http://yoursite.com/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ARKit by Tutorials Section Ⅱ 野生笔记</title>
    <link href="http://yoursite.com/2018/09/23/arkitSection2/"/>
    <id>http://yoursite.com/2018/09/23/arkitSection2/</id>
    <published>2018-09-22T16:00:00.000Z</published>
    <updated>2018-10-01T13:29:16.152Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter-7-Get-Started-Portal-App"><a href="#Chapter-7-Get-Started-Portal-App" class="headerlink" title="Chapter 7: Get Started: Portal App"></a>Chapter 7: Get Started: Portal App</h1><h2 id="Get-started"><a href="#Get-started" class="headerlink" title="Get started"></a>Get started</h2><ul><li><p>ARKit 处理所有的传感器和摄像头数据，但是不会生成任何虚拟内容，你需要依靠其他框架在场景中增加虚拟内容，例如 SceneKit 或 SpriteKit</p></li><li><p>ARSCNView 是苹果提供一种的框架，能够轻松整合 ARKit 数据和 SceneKit</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">@IBOutlet var sceneView: ARSCNView?</span><br><span class="line">// 2</span><br><span class="line">@IBOutlet weak var messageLabel: UILabel?</span><br><span class="line">// 3</span><br><span class="line">@IBOutlet weak var sessionStateLabel: UILabel?</span><br></pre></td></tr></table></figure><ol><li>sceneView 被用来给摄像头视图增加 3D 物体</li><li>显示指示信息</li><li>显示会话状态</li></ol><h2 id="Setting-up-ARKit"><a href="#Setting-up-ARKit" class="headerlink" title="Setting up ARKit"></a>Setting up ARKit</h2><ul><li>开始的第一步是使用摄像头去捕捉视频流，你将用到一个 ARSCNView 对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func runSession() &#123;</span><br><span class="line">  // 1  </span><br><span class="line">  let configuration = ARWorldTrackingConfiguration.init()</span><br><span class="line">  // 2</span><br><span class="line">  configuration.planeDetection = .horizontal</span><br><span class="line">  // 3</span><br><span class="line">  configuration.isLightEstimationEnabled = true</span><br><span class="line">  // 4</span><br><span class="line">  sceneView?.session.run(configuration)</span><br><span class="line"></span><br><span class="line">  // 5</span><br><span class="line">  #if DEBUG</span><br><span class="line">    sceneView?.debugOptions = [ARSCNDebugOptions.showFeaturePoints]</span><br><span class="line">  #endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>实例化了一个 ARWorldTrackingConfiguration，并为 ARSession 定义了配置，这有两种类型的配置：<code>ARSessionConfiguration</code> 和 <code>ARWorldTrackingConfiguration</code></li><li>configuration.planeDetection 被设置为侦测水平平面，平面范围大小可以改变，随着摄像机移动,多个平面可以合成为一个平面</li><li>启用光线估计计算，被生成图像的框架采用，使得虚拟内容看上去更加真实</li><li>根据配置来开启 AR 的处理进程。将会开启 AR 会话以及来自摄像头的视频流捕捉，最后显示在 sceneView 上</li><li>排错设置，增加可视的光点，覆盖在摄像头视图上</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func resetLabels() &#123;</span><br><span class="line">  messageLabel?.alpha = 1.0</span><br><span class="line">  messageLabel?.text =</span><br><span class="line">    &quot;Move the phone around and allow the app to find a plane.&quot; +</span><br><span class="line">    &quot;You will see a yellow horizontal plane.&quot;</span><br><span class="line">  sessionStateLabel?.alpha = 0.0</span><br><span class="line">  sessionStateLabel?.text = &quot;&quot;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>设置标签的默认值，调整 messageLabel 和 sessionStateLabel 的不透明度和内容，messageLabel 给用户显示指令，然而 sessionStateLabel 被用来显示错误信息，此情况下属于有地方出错</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">  super.viewDidLoad()    </span><br><span class="line">  resetLabels()</span><br><span class="line">  runSession()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>启动时加载视图的时候开启 ARKit session </li></ul><h2 id="Plane-detection-and-rendering"><a href="#Plane-detection-and-rendering" class="headerlink" title="Plane detection and rendering"></a>Plane detection and rendering</h2><ul><li>扩展  PortalViewController 以至于它能够执行 ARSCNViewDelegate 协议</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extension PortalViewController: ARSCNViewDelegate &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>设置 sceneView 的 delegate 为 PortalViewController</li></ul><blockquote><p>runSession()</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sceneView?.delegate = self</span><br></pre></td></tr></table></figure><blockquote><p>extension</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">func renderer(_ renderer: SCNSceneRenderer,</span><br><span class="line">              didAdd node: SCNNode,</span><br><span class="line">              for anchor: ARAnchor) &#123;</span><br><span class="line">  // 2</span><br><span class="line">  DispatchQueue.main.async &#123;</span><br><span class="line">    // 3</span><br><span class="line">    if let planeAnchor = anchor as? ARPlaneAnchor &#123;</span><br><span class="line">        // 4</span><br><span class="line">      #if DEBUG</span><br><span class="line">        // 5</span><br><span class="line">        let debugPlaneNode = createPlaneNode(</span><br><span class="line">          center: planeAnchor.center,</span><br><span class="line">          extent: planeAnchor.extent)</span><br><span class="line">        // 6  </span><br><span class="line">        node.addChildNode(debugPlaneNode)</span><br><span class="line">      #endif</span><br><span class="line">      // 7</span><br><span class="line">      self.messageLabel?.text =</span><br><span class="line">      &quot;Tap on the detected horizontal plane to place the portal&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ARPlaneAnchors 被自动添加给了 ARSession 的锚数组，ARSCNView 自动将 ARPlaneAnchor 对象转换成为 SCNNode nodes，为了去提供这些平面，你需要在 ARSCNViewDelegate 扩展中去执行 delegate 方法</li></ul><ol><li>当ARSession 侦测到了一个新的平面时，renderer(_:didAdd:for:) 被调用，ARSCNView 会自动为这个平面增加一个 ARPlaneAnchor</li><li>这个调用发生在后台线程，但在这里，你将代码块发送到主线程，因为任何更新 UI 的操作都应该在主线程中完成</li><li>检查了 ARAnchor 是否是一个 ARPlaneAnchor</li><li>检查你是否在排错模式</li><li>如果是这样，通过传入 planeAnchor 的中心和范围大小来创建 plane SCNNode</li><li>node 现在是一个空的 SCNNode，通过 ARSCNView 被自动添加到场景中，它的坐标与 ARAnchor 的位置一样，现在你需要添加 debugPlaneNode 作为一个子结点，以至于它能够放置于跟 node 一样的位置上 </li><li>最后，无论你是不是在排错模式，你都更新指示消息给玩家，表示准备完毕可以将门放入场景中</li></ol><blockquote><p>SCNNodeHelpers.swift</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import SceneKit</span><br><span class="line"></span><br><span class="line">  // 1</span><br><span class="line">func createPlaneNode(center: vector_float3,</span><br><span class="line">                     extent: vector_float3) -&gt; SCNNode &#123;</span><br><span class="line">  // 2</span><br><span class="line">  let plane = SCNPlane(width: CGFloat(extent.x),</span><br><span class="line">                      height: CGFloat(extent.z))</span><br><span class="line">  // 3</span><br><span class="line">  let planeMaterial = SCNMaterial()</span><br><span class="line">  planeMaterial.diffuse.contents = UIColor.yellow.withAlphaComponent(0.4)</span><br><span class="line">  // 4</span><br><span class="line">  plane.materials = [planeMaterial]</span><br><span class="line">  // 5</span><br><span class="line">  let planeNode = SCNNode(geometry: plane)</span><br><span class="line">  // 6</span><br><span class="line">  planeNode.position = SCNVector3Make(center.x, 0, center.z)</span><br><span class="line">  // 7</span><br><span class="line">  planeNode.transform = SCNMatrix4MakeRotation(-Float.pi / 2, 1, 0, 0)</span><br><span class="line">  // 8</span><br><span class="line">  return planeNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建一个新的 Swift 文件名为 SCNNodeHelpers.swift，这个文件将会包含所有与生成 SCNNode 相关的代码</li></ul><ol><li>createPlaneNode 方法有两个参数， 将提供的平面的中心和范围大小，都是 vector_float3 类型， 表示点坐标，返回一个 SCNNode </li><li>通过具体说明平面的宽度和广度实例化了 SCNPlane ，你从 extent 的 x 坐标中得到了宽度，从 z 坐标中得到了高度 </li><li>你初始化了 SCNMaterial 并为它配置了 diffuse content，被设置为半透明的黄色</li><li>SCNMaterial 被添加给了平面的 materials 数组，定义了平面的材质和颜色</li><li>使用 plane 的几何大小创建了一个 SCNNode，SCNPlane 继承自 SCNGeometry 类，这个类提供了可视对象的形状，并由 SceneKit 负责生成，. 你通过将几何图形依附在 SCNNod 进而规定了它的位置和朝向，多个 nodes 可以指向同一个几何大小，允许它出现在一个场景的不同位置</li><li>设置 planeNode 的位置，注意 node 被翻译为了 coordinates (center.x, 0, center.z) ，通过 ARPlaneAnchor instance</li><li>SceneKit 中的平面默认都是垂直的，因此你需要去旋转 90°使之水平</li><li>返回一个 planeNode 对象</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">func renderer(_ renderer: SCNSceneRenderer, didUpdate node: SCNNode,</span><br><span class="line">              for anchor: ARAnchor) &#123;</span><br><span class="line">  // 2              </span><br><span class="line">  DispatchQueue.main.async &#123;</span><br><span class="line">    // 3</span><br><span class="line">    if let planeAnchor = anchor as? ARPlaneAnchor,</span><br><span class="line">      node.childNodes.count &gt; 0 &#123;</span><br><span class="line">      // 4  </span><br><span class="line">      updatePlaneNode(node.childNodes[0],</span><br><span class="line">                      center: planeAnchor.center,</span><br><span class="line">                      extent: planeAnchor.extent)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ARKit 基于新发现的特征点持续更新平面的位置和范围大小，新增委托方法去接受这些更</li></ul><ol><li>当对应的锚更新时，renderer(_:didUpdate:for:) 方法被调用</li><li>UI 元素的更新应该在主线程中 </li><li>检查 ARAnchor 是一个 ARPlaneAnchor，然后确认至少它有一个子结点，与 plane’s SCNNode 相符</li><li>updatePlaneNode(_:center:extent:) 是一个不久将执行的方法，它通过 ARPlaneAnchor 中的更新值来更新平面的坐标和大小</li></ol><blockquote><p>SCNNodeHelpers.swift</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func updatePlaneNode(_ node: SCNNode,</span><br><span class="line">                     center: vector_float3,</span><br><span class="line">                     extent: vector_float3) &#123;</span><br><span class="line">  // 1                    </span><br><span class="line">  let geometry = node.geometry as? SCNPlane</span><br><span class="line">  // 2</span><br><span class="line">  geometry?.width = CGFloat(extent.x)</span><br><span class="line">  geometry?.height = CGFloat(extent.z)</span><br><span class="line">  // 3</span><br><span class="line">  node.position = SCNVector3Make(center.x, 0, center.z)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>检查是否 node 含有 SCNPlane geometry</li><li>使用传入的新值更新 node geometry，也就是使用 ARPlaneAnchor 的范围或大小去更新 plane 的宽度和高度</li><li>使用新的位置来更新 plane 的位置</li></ol><ul><li>运行时你将会看到平面的大小和位置随着侦测到新的特征点而改变，仍然有一个问题需要去解决，一旦侦测到平面，如果你离开应用在进来，你将会看到之前侦测到的平面现在在其他对象的顶部，不再匹配它之前侦测的平面，为了解决这个问题，你需要去移除 plane node 当 ARSession 中断时</li></ul><h1 id="Chapter-8-Add-Objects-to-your-World"><a href="#Chapter-8-Add-Objects-to-your-World" class="headerlink" title="Chapter 8: Add Objects to your World"></a>Chapter 8: Add Objects to your World</h1><h2 id="Get-started-1"><a href="#Get-started-1" class="headerlink" title="Get started"></a>Get started</h2><ul><li><p>现在你可以去侦测并生成水平平面，会话有任何中断你则需要去重启会话，当应用切换到后台或者多个应用在前台时，ARSession 会中断，一旦中断，视频捕捉将会失败，ARSession 将不可能做任何追踪，也将不再接受任何传感器数据，当应用返回前台时，生成的平面仍然会在场景中。然而，如果你的设备改变了位置和角度，ARSession 追踪将不再继续，因此你也需要去重启会话</p></li><li><p>ARSCNViewDelegate 执行 ARSessionObserver 协议，这个协议包括当 ARSession 侦测中断或者会话出错时调用的方法</p></li></ul><blockquote><p>extension</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">func session(_ session: ARSession, didFailWithError error: Error) &#123;</span><br><span class="line">  // 2</span><br><span class="line">  guard let label = self.sessionStateLabel else &#123; return &#125;</span><br><span class="line">  showMessage(error.localizedDescription, label: label, seconds: 3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3</span><br><span class="line">func sessionWasInterrupted(_ session: ARSession) &#123;</span><br><span class="line">  guard let label = self.sessionStateLabel else &#123; return &#125;</span><br><span class="line">  showMessage(&quot;Session interrupted&quot;, label: label, seconds: 3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 4</span><br><span class="line">func sessionInterruptionEnded(_ session: ARSession) &#123;</span><br><span class="line">  // 5</span><br><span class="line">  guard let label = self.sessionStateLabel else &#123; return &#125;</span><br><span class="line">  showMessage(&quot;Session resumed&quot;, label: label, seconds: 3)</span><br><span class="line"></span><br><span class="line">  // 6</span><br><span class="line">  DispatchQueue.main.async &#123;</span><br><span class="line">    self.removeAllNodes()</span><br><span class="line">    self.resetLabels()</span><br><span class="line">  &#125;</span><br><span class="line">  // 7</span><br><span class="line">  runSession()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>会话失败时，<code>session(_:, didFailWithError:)</code> 方法被调用。会话会终止并且不会收到任何传感器数据</li><li>因为会话失败，设置 sessionStateLabel 文本为错误信息。在规定的时间内， <code>showMessage(_:, label:, seconds:)</code> 在特定的标签上显示信息</li><li>切换到后台视频捕捉中断时，<code>sessionWasInterrupted(_:)</code> 方法被调用，直到中断结束也没有额外的帧更新被发送，在标签中显示 “Session interrupted” 三秒</li><li>会话中断已经结束时 <code>sessionInterruptionEnded(_:)</code> 方法被调用，一旦中断结束，会话将会从最后一个已知的状态开始，如果设备移动，任何锚都会错位，为了避免这种情况，你需要重启会话</li><li>显示 “Session resumed” 三秒</li><li>移除之前的生成对象并且重置所有标签，不久后你将执行这些方法，因这些方法更新 UI，因此需要在主线程中调用</li><li>重启会话</li></ol><ul><li>debugPlanes 是一组 SCNNode 对象，在排错模式中能够保存所有生成的水平平面</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var debugPlanes: [SCNNode] = []</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">func showMessage(_ message: String, label: UILabel, seconds: Double) &#123;</span><br><span class="line">  label.text = message</span><br><span class="line">  label.alpha = 1</span><br><span class="line"></span><br><span class="line">  DispatchQueue.main.asyncAfter(deadline: .now() + seconds) &#123;</span><br><span class="line">    if label.text == message &#123;</span><br><span class="line">      label.text = &quot;&quot;</span><br><span class="line">      label.alpha = 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2</span><br><span class="line">func removeAllNodes() &#123;</span><br><span class="line">  removeDebugPlanes()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3</span><br><span class="line">func removeDebugPlanes() &#123;</span><br><span class="line">  for debugPlaneNode in self.debugPlanes &#123;</span><br><span class="line">    debugPlaneNode.removeFromParentNode()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  self.debugPlanes = []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在标签中展示信息，一旦规定的时间过去，重新设置标签能见度和文本</li><li><code>removeAllNodes()</code> 移除场景中存在的所有 SCNNode objects，目前你只能移除生成的水平平面</li><li>移除场景中所有生成的水平平面，并重置 debugPlanes 数组</li></ol><blockquote><p>renderer(_:, didAdd:, for:) 中添加到 #if DEBUG 预处理程序末尾</p></blockquote><ul><li>将添加到场景中的水平平面增加到 debugPlanes 数组中去</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.debugPlanes.append(debugPlaneNode)</span><br></pre></td></tr></table></figure><ul><li>替换 <code>sceneView?.session.run(configuration)</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sceneView?.session.run(configuration,</span><br><span class="line">                       options: [.resetTracking, .removeExistingAnchors])</span><br></pre></td></tr></table></figure><p>通过传入配置和一组 ARSession.RunOptions 来开启会话, 有以下几种 options：</p><ol><li>resetTracking：会话不会继续之前配置中的设备位置和运动追踪</li><li>removeExistingAnchors：之前配置中任何与会话相关联的锚都会被移除</li></ol><ul><li>打开应用然后切换到后台，重新打开应用，注意场景中之前生成的水平平面已被移除，应用重置了标签显示正确的指令给用户</li></ul><h2 id="Hit-testing"><a href="#Hit-testing" class="headerlink" title="Hit testing"></a>Hit testing</h2><ul><li>你现在将物体放置与被侦测到的水平平面上，你将会使用 ARSCNView 的 hit testing 来侦测屏幕上的用户触摸去找到虚拟场景中他们准备放置物体的地方，屏幕上坐标系中的 2D 点能够通过线段指向 3D 坐标系的任何一点，Hit-testing 就是利用线段找到世界中的物体的过程</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var viewCenter: CGPoint &#123;</span><br><span class="line">  let viewBounds = view.bounds</span><br><span class="line">  return CGPoint(x: viewBounds.width / 2.0, y: viewBounds.height / 2.0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123;</span><br><span class="line">  // 2</span><br><span class="line">  if let hit = sceneView?.hitTest(viewCenter, types: [.existingPlaneUsingExtent]).first &#123;</span><br><span class="line">    // 3</span><br><span class="line">    sceneView?.session.add(anchor: ARAnchor.init(transform: hit.worldTransform))      </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>ARSCNView 使得触控有效，当用户点击场景时，touchesBegan() 方法被调用伴随一系列的 UITouch 对象和一个定义 touch 时间的 UIEvent，使此方法优先给 sceneView 增加一个 ARAnchor</li><li><p>你调用了 sceneVIew 的 <code>hitTest(_:, types:)</code>，这个 hitTest 方法有两个参数，首先取了一个 view 坐标系中的 CGPoint，也就是屏幕的中心，之后是 ARHitTestResult 要去搜索的类型。这里你使用 existingPlaneUsingExtent 类型，只考虑有限范围大小的平面。</p><p><code>hitTest(_:, types:)</code> 的结果是一组所有的 hit test，从最近到最远的，你选择第一个射线相交的第一个 plane，你将从 <code>hitTest(_:, types:)</code>得到结果任何时候，只要屏幕中心落在生成的水平平面上 </p></li><li><p>在你对象将要被放置的位置增加一个 ARAnchor，ARAnchor 被一个 transformation 矩阵所初始化，这个矩阵定义了锚在世界坐标系中的旋转，角度，转化以及大小</p></li></ol><p>当锚被添加时，在委托方法 <code>renderer(_:didAdd:for:)</code> 中 ARSCNView 接受了一个回调，这就是你生成出入口的地方</p><h2 id="Add-crosshairs"><a href="#Add-crosshairs" class="headerlink" title="Add crosshairs"></a>Add crosshairs</h2><ul><li>在你增加出入口到场景中之前，还有一件事情，之前你使用屏幕中心来侦测 hit testing，现在你将增加一个 view 去显示屏幕中心来帮助用户定位</li></ul><blockquote><p>extension</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">func renderer(_ renderer: SCNSceneRenderer,</span><br><span class="line">              updateAtTime time: TimeInterval) &#123;</span><br><span class="line">  // 2</span><br><span class="line">  DispatchQueue.main.async &#123;</span><br><span class="line">    // 3</span><br><span class="line">    if let _ = self.sceneView?.hitTest(self.viewCenter,</span><br><span class="line">      types: [.existingPlaneUsingExtent]).first &#123;</span><br><span class="line">      self.crosshair.backgroundColor = UIColor.green</span><br><span class="line">    &#125; else &#123; // 4</span><br><span class="line">      self.crosshair.backgroundColor = UIColor.lightGray</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>这个方法是 SCNSceneRendererDelegate 协议的一部分，这个协议被 ARSCNViewDelegate 执行，它包含很多回调能够被很多次使用去执行操作在生成的过程中，<code>renderer(_: updateAtTime:)</code> 每一帧都被精准地调用，并且应该被用于执行每一帧的逻辑</li><li>如果屏幕中心落在侦测的水平平面上，在主线程中同步更新 UI</li><li>如果 view center 确实与水平平面相交，就在 sceneView 上执行一次 hit test，如果至少有一个一个结果被侦测到，crosshair view 的背景颜色变为绿色background</li><li>hit test 没有返回任何结果，crosshair view 的背景色被设为浅灰色</li></ol><h2 id="Add-a-state-machine"><a href="#Add-a-state-machine" class="headerlink" title="Add a state machine"></a>Add a state machine</h2><ul><li>既然你已经设置侦测平面并且放置了锚，现在你可以开始增加出入口</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var portalNode: SCNNode? = nil</span><br><span class="line">var isPortalPlaced = false</span><br></pre></td></tr></table></figure><ul><li>makePortal() 正在创建一个出入口结点，其中还有一个方块对象作为占位符</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func makePortal() -&gt; SCNNode &#123;</span><br><span class="line">  // 1</span><br><span class="line">  let portal = SCNNode()</span><br><span class="line">  // 2</span><br><span class="line">  let box = SCNBox(width: 1.0,</span><br><span class="line">                   height: 1.0,</span><br><span class="line">                   length: 1.0,</span><br><span class="line">                   chamferRadius: 0)</span><br><span class="line">  let boxNode = SCNNode(geometry: box)</span><br><span class="line">  // 3</span><br><span class="line">  portal.addChildNode(boxNode)  </span><br><span class="line">  return portal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>创建一个 SCNNode 对象，它代表你的出入口 </li><li>初始化一个 SCNBox 对象，它其实一个方块，使用 SCNBox geometry 来生成</li><li>将 boxNode 作为一个子结点添加到你的出入口，然后返回 portal 结点</li></ol><ul><li>替换 <code>renderer(_:, didAdd:, for:)</code> 和 <code>renderer(_:, didUpdate:, for:)</code> </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">func renderer(_ renderer: SCNSceneRenderer, didAdd node: SCNNode, for anchor: ARAnchor) &#123;</span><br><span class="line">  DispatchQueue.main.async &#123;</span><br><span class="line">    // 1</span><br><span class="line">    if let planeAnchor = anchor as? ARPlaneAnchor, </span><br><span class="line">    !self.isPortalPlaced &#123;</span><br><span class="line">      #if DEBUG</span><br><span class="line">        let debugPlaneNode = createPlaneNode(</span><br><span class="line">          center: planeAnchor.center,</span><br><span class="line">          extent: planeAnchor.extent)</span><br><span class="line">        node.addChildNode(debugPlaneNode)</span><br><span class="line">        self.debugPlanes.append(debugPlaneNode)</span><br><span class="line">      #endif</span><br><span class="line">      self.messageLabel?.alpha = 1.0</span><br><span class="line">      self.messageLabel?.text = &quot;&quot;&quot;</span><br><span class="line">            Tap on the detected \</span><br><span class="line">            horizontal plane to place the portal</span><br><span class="line">            &quot;&quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    else if !self.isPortalPlaced &#123;// 2</span><br><span class="line">        // 3</span><br><span class="line">      self.portalNode = self.makePortal()</span><br><span class="line">      if let portal = self.portalNode &#123;</span><br><span class="line">        // 4</span><br><span class="line">        node.addChildNode(portal)</span><br><span class="line">        self.isPortalPlaced = true</span><br><span class="line">        // 5</span><br><span class="line">        self.removeDebugPlanes()</span><br><span class="line">        self.sceneView?.debugOptions = []</span><br><span class="line">        // 6</span><br><span class="line">        DispatchQueue.main.async &#123;</span><br><span class="line">          self.messageLabel?.text = &quot;&quot;</span><br><span class="line">          self.messageLabel?.alpha = 0</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func renderer(_ renderer: SCNSceneRenderer,</span><br><span class="line">              didUpdate node: SCNNode,</span><br><span class="line">              for anchor: ARAnchor) &#123;</span><br><span class="line">  DispatchQueue.main.async &#123;</span><br><span class="line">    // 7</span><br><span class="line">    if let planeAnchor = anchor as? ARPlaneAnchor,</span><br><span class="line">      node.childNodes.count &gt; 0,</span><br><span class="line">      !self.isPortalPlaced &#123;</span><br><span class="line">      updatePlaneNode(node.childNodes[0],</span><br><span class="line">                      center: planeAnchor.center,</span><br><span class="line">                      extent: planeAnchor.extent)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>只有当添加到场景中的锚是一个 ARPlaneAnchor 时，并且 isPortalPlaced 为假，意味着出入口还未被放置，给场景添加一个水平平面去展示侦测到的平面</li><li>如果被添加的锚不是一个 ARPlaneAnchor，并且出入口结点仍然没有被放置，那么这个锚一定是当用户点击屏幕时放置出入口所添加的锚</li><li>通过调用 makePortal() 来创建 出入口结点</li><li><code>renderer(_:, didAdd:, for:)</code> 在 node 被 放置于场景中时被调用，你想要将传送门结点放置到这个结点的位置上。所以你将传送门结点作为该结点的子结点，然后设置 isPortalPlaced 为真，去追踪传送门结点已经被添加</li><li>为了去清理场景，你移除了所有生成的水平平面，然后重置了 debugOptions 以至于特征点不再显示</li><li>主线程中更新 messageLabel 重置它的文本并且隐藏它</li><li><code>renderer(_:, didUpdate:, for:)</code>只有当所提供的锚是一个 ARPlaneAnchor 并且结点至少有一个子结点以及出入口还未被放置，你更新生成的水平平面</li></ol><blockquote><p>替换 removeAllNodes()</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func removeAllNodes() &#123;</span><br><span class="line">  // 1</span><br><span class="line">  removeDebugPlanes()</span><br><span class="line">  // 2</span><br><span class="line">  self.portalNode?.removeFromParentNode()</span><br><span class="line">  // 3</span><br><span class="line">  self.isPortalPlaced = false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>你移除了所有生成的水平平面</li><li>从 portalNode 的父结点中移除 portalNode</li><li>设置 isPortalPlaced 变量为假</li></ol><ul><li>运行应用，让应用侦测一个水平平面，当 crosshair view 变为绿色时，点击屏幕，你将会看到一个一个巨大的白色立方体</li></ul><h1 id="Chapter-9-Geomtry-Textrues-and-lighting"><a href="#Chapter-9-Geomtry-Textrues-and-lighting" class="headerlink" title="Chapter 9: Geomtry, Textrues, and lighting"></a>Chapter 9: Geomtry, Textrues, and lighting</h1><h2 id="The-SceneKit-coordinate-system"><a href="#The-SceneKit-coordinate-system" class="headerlink" title="The SceneKit coordinate system"></a>The SceneKit coordinate system</h2><ul><li>SceneKit 用于添加 3D 物体到场景中去，SceneKit 的内容视图由树形等级制度的结点构成，也被称为场景图，一个场景含有一个根结点组成，它为这个 scene 定义了坐标空间，其他的结点则用可视内容占据空间。每一个结点或者 3D 对象都是 SCNNode 类型的。SCNNode 相较于它的父结点定义了坐标空间的 transform (位置，朝向，大小)，但是 SCNNode 自身没有任何的可视内容</li><li>场景中的根结点定义了 SceneKit 所生成世界的坐标系统，每一个你添加给根结点的子结点都创造了它自己的坐标系统，并且被他们的子结点继承。SceneKit 使用右手定则的坐标系统，默认视野的方向是负 Z 轴 </li></ul><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fvnua4qnhnj31kw1daago.jpg" alt=""></p><ul><li>SCNNode 的位置使用一个 SCNVector3 来进行定义，它能够在父结点的坐标系统中准备定位自己，默认的位置是零向量，表示结点被放置于父节点坐标系统的原始位置，SCNVector3 由三元向量组成，每一个向量是浮点值，代表每一个轴上的坐标</li><li>SCNNode 的朝向，也就是 pitch（俯仰）, yaw（偏航）, 以及被 eulerAngles 属性定义的 roll angles（滚转角度），这些被一个 SCNVector3结构体所表示，其中的每一个分量都是弧度制中的一个角度</li></ul><h2 id="Textures"><a href="#Textures" class="headerlink" title="Textures"></a>Textures</h2><ul><li>SCNNode 它自己没有任何的可视内容，通过给结点增加 SCNGeometry 你才向场景中新添 2D 和 3D 对象</li><li>Geometries 附上可以决定对象外表的 SCNMaterial，一个 SCNMaterial 中有几个可视的属性，每一个可视属性是一个 SCNMaterialProperty 类的实例，提供了一个颜色，材质，或者其他的 2D 内容。这有许多有关阴影的可视属性，比如基于环境光的阴影，以及特效，能够使材质变得更加真实</li><li>依靠 SceneKit，你能给 nodes 增加 SCNLight 去给几何对象增加阴影效果</li></ul><h2 id="Building-the-portal"><a href="#Building-the-portal" class="headerlink" title="Building the portal"></a>Building the portal</h2><blockquote><p>SCNNodeHelpers.swift</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">let SURFACE_LENGTH: CGFloat = 3.0</span><br><span class="line">let SURFACE_HEIGHT: CGFloat = 0.2</span><br><span class="line">let SURFACE_WIDTH: CGFloat = 3.0</span><br><span class="line"></span><br><span class="line">// 2</span><br><span class="line">let SCALEX: Float = 2.0</span><br><span class="line">let SCALEY: Float = 2.0</span><br><span class="line"></span><br><span class="line">// 3</span><br><span class="line">let WALL_WIDTH:CGFloat = 0.2</span><br><span class="line">let WALL_HEIGHT:CGFloat = 3.0</span><br><span class="line">let WALL_LENGTH:CGFloat = 3.0</span><br></pre></td></tr></table></figure><ol><li>定义了传送门中地板和天花板的尺寸，屋顶和天花板的高度就是他们的厚度</li><li>定义了用于等比例放大质地和重复质地的常量</li><li>定义墙结点的宽度、高度和长度</li></ol><blockquote><p>SCNNodeHelpers.swift</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">func repeatTextures(geometry: SCNGeometry, scaleX: Float, scaleY: Float) &#123;</span><br><span class="line">  // 1</span><br><span class="line">  geometry.firstMaterial?.diffuse.wrapS = SCNWrapMode.repeat</span><br><span class="line">  geometry.firstMaterial?.selfIllumination.wrapS = SCNWrapMode.repeat</span><br><span class="line">  geometry.firstMaterial?.normal.wrapS = SCNWrapMode.repeat</span><br><span class="line">  geometry.firstMaterial?.specular.wrapS = SCNWrapMode.repeat</span><br><span class="line">  geometry.firstMaterial?.emission.wrapS = SCNWrapMode.repeat</span><br><span class="line">  geometry.firstMaterial?.roughness.wrapS = SCNWrapMode.repeat</span><br><span class="line"></span><br><span class="line">  // 2</span><br><span class="line">  geometry.firstMaterial?.diffuse.wrapT = SCNWrapMode.repeat</span><br><span class="line">  geometry.firstMaterial?.selfIllumination.wrapT = SCNWrapMode.repeat</span><br><span class="line">  geometry.firstMaterial?.normal.wrapT = SCNWrapMode.repeat</span><br><span class="line">  geometry.firstMaterial?.specular.wrapT = SCNWrapMode.repeat</span><br><span class="line">  geometry.firstMaterial?.emission.wrapT = SCNWrapMode.repeat</span><br><span class="line">  geometry.firstMaterial?.roughness.wrapT = SCNWrapMode.repeat</span><br><span class="line"></span><br><span class="line">  // 3</span><br><span class="line">  geometry.firstMaterial?.diffuse.contentsTransform =</span><br><span class="line">    SCNMatrix4MakeScale(scaleX, scaleY, 0)</span><br><span class="line">  geometry.firstMaterial?.selfIllumination.contentsTransform =</span><br><span class="line">    SCNMatrix4MakeScale(scaleX, scaleY, 0)</span><br><span class="line">  geometry.firstMaterial?.normal.contentsTransform =</span><br><span class="line">    SCNMatrix4MakeScale(scaleX, scaleY, 0)</span><br><span class="line">  geometry.firstMaterial?.specular.contentsTransform =</span><br><span class="line">    SCNMatrix4MakeScale(scaleX, scaleY, 0)</span><br><span class="line">  geometry.firstMaterial?.emission.contentsTransform =</span><br><span class="line">    SCNMatrix4MakeScale(scaleX, scaleY, 0)</span><br><span class="line">  geometry.firstMaterial?.roughness.contentsTransform =</span><br><span class="line">    SCNMatrix4MakeScale(scaleX, scaleY, 0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义了一个方法在 X 和 Y 轴的方向上去重复质地图像</li></ul><ol><li>这个方法将一个 SCNGeometry 和 X 和 Y 等比例缩放因子作为输入，质地地图使用 S 和 T 坐标系统，其实 S 对应 X，T 对应 Y，这里你为所有可见属性都定义了 S 维度的 wrapping mode 为 SCNWrapMode.repeat</li><li>为所有可见属性都定义了 T 维度的 wrapping mode 为 SCNWrapMode.repeat</li><li>这里，每一个可视特性 contentsTransform 都被设置成了 SCNMatrix4 结构体表示的 scale transform，你分别设置 X 和 Y 的缩放比例因子为 scaleX 和 scaleY</li></ol><blockquote><p>SCNNodeHelpers:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func makeOuterSurfaceNode(width: CGFloat,</span><br><span class="line">                          height: CGFloat,</span><br><span class="line">                          length: CGFloat) -&gt; SCNNode &#123;</span><br><span class="line">  // 1</span><br><span class="line">  let outerSurface = SCNBox(width: SURFACE_WIDTH,</span><br><span class="line">                            height: SURFACE_HEIGHT,</span><br><span class="line">                            length: SURFACE_LENGTH,</span><br><span class="line">                            chamferRadius: 0)</span><br><span class="line">  </span><br><span class="line">  // 2</span><br><span class="line">  outerSurface.firstMaterial?.diffuse.contents = UIColor.white</span><br><span class="line">  outerSurface.firstMaterial?.transparency = 0.000001</span><br><span class="line">  </span><br><span class="line">  // 3</span><br><span class="line">  let outerSurfaceNode = SCNNode(geometry: outerSurface)</span><br><span class="line">  outerSurfaceNode.renderingOrder = 10</span><br><span class="line">  return outerSurfaceNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>用户进入传送门中，才显示出地板和天花板，其他时候你都需要去隐藏它们</li></ul><ol><li>使用地板和天花板的尺寸大小去创建一个 outerSurface 场景立方几何体</li><li>为立方体设置漫反射属性使其渲染出来，设置透明度为一个非常低的值以至于对象能够在视图中隐藏 </li><li>通过 outerSurface geometry 来创建一个 SCNNode，为 node 设置渲染 为 10，渲染顺序越大也就越后渲染，为了使天花板和地板在传送口的外部不可见，你要使内部天花板和地板的远远大于 10</li></ol><blockquote><p>SCNNodeHelpers</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">func makeFloorNode() -&gt; SCNNode &#123;</span><br><span class="line">  // 1</span><br><span class="line">  let outerFloorNode = makeOuterSurfaceNode(</span><br><span class="line">                       width: SURFACE_WIDTH,</span><br><span class="line">                       height: SURFACE_HEIGHT,</span><br><span class="line">                       length: SURFACE_LENGTH)</span><br><span class="line">  </span><br><span class="line">  // 2</span><br><span class="line">  outerFloorNode.position = SCNVector3(SURFACE_HEIGHT * 0.5,</span><br><span class="line">                                       -SURFACE_HEIGHT, 0)</span><br><span class="line">  let floorNode = SCNNode()</span><br><span class="line">  floorNode.addChildNode(outerFloorNode)</span><br><span class="line"></span><br><span class="line">  // 3</span><br><span class="line">  let innerFloor = SCNBox(width: SURFACE_WIDTH,</span><br><span class="line">                          height: SURFACE_HEIGHT,</span><br><span class="line">                          length: SURFACE_LENGTH,</span><br><span class="line">                          chamferRadius: 0)</span><br><span class="line">  </span><br><span class="line">  // 4</span><br><span class="line">  innerFloor.firstMaterial?.lightingModel = .physicallyBased</span><br><span class="line">  innerFloor.firstMaterial?.diffuse.contents =</span><br><span class="line">    UIImage(named: </span><br><span class="line">    &quot;Assets.scnassets/floor/textures/Floor_Diffuse.png&quot;)</span><br><span class="line">  innerFloor.firstMaterial?.normal.contents =</span><br><span class="line">    UIImage(named: </span><br><span class="line">    &quot;Assets.scnassets/floor/textures/Floor_Normal.png&quot;)</span><br><span class="line">  innerFloor.firstMaterial?.roughness.contents =</span><br><span class="line">    UIImage(named:</span><br><span class="line">    “Assets.scnassets/floor/textures/Floor_Roughness.png&quot;)</span><br><span class="line">  innerFloor.firstMaterial?.specular.contents =</span><br><span class="line">    UIImage(named: </span><br><span class="line">    &quot;Assets.scnassets/floor/textures/Floor_Specular.png&quot;)</span><br><span class="line">  innerFloor.firstMaterial?.selfIllumination.contents =</span><br><span class="line">    UIImage(named: </span><br><span class="line">    &quot;Assets.scnassets/floor/textures/Floor_Gloss.png&quot;)</span><br><span class="line">  </span><br><span class="line">  // 5  </span><br><span class="line">  repeatTextures(geometry: innerFloor, </span><br><span class="line">                 scaleX: SCALEX, scaleY: SCALEY)</span><br><span class="line">  </span><br><span class="line">  // 6</span><br><span class="line">  let innerFloorNode = SCNNode(geometry: innerFloor)</span><br><span class="line">  innerFloorNode.renderingOrder = 100</span><br><span class="line">  </span><br><span class="line">  // 7</span><br><span class="line">  innerFloorNode.position = SCNVector3(SURFACE_HEIGHT * 0.5, </span><br><span class="line">                                       0, 0)</span><br><span class="line">  floorNode.addChildNode(innerFloorNode)</span><br><span class="line">  return floorNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>使用地板的大小来创建外层地板结点</li><li>放置 outerFloorNode，使其位于地板节点的底面下方，将其添加到 floorNode 上,这个节点将会同时持有地板的内层和外层表面</li><li>使用 SCNBox 来生成地板的几何形状</li><li>地板材质的光照模型被设置为 physicallyBased，这种类型的阴影包含了一种物理光和物理材质的真实抽象感觉，材质可见属性的内容都来自 scnassets catalog 中的质地图片</li><li>材质的质地使用你之前定义的 repeatTextures() 方法在 X 和 Y 方向上重复</li><li>使用 innerFloor geometry object 给地板创建一个结点，然后设置渲染顺序高于outerFloorNode，这确保了当用户位于传送门之外时，地板结点将不可见</li><li>最后，设置 innerFloorNode 的位置位于 outerFloorNode 之上，并添加给 floorNode 作为子结点，返回地板结点给函数调用者</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let POSITION_Y: CGFloat = -WALL_HEIGHT*0.5</span><br><span class="line">let POSITION_Z: CGFloat = -SURFACE_LENGTH*0.5</span><br></pre></td></tr></table></figure><ul><li>这些常量代表结点在 Y 和 Z 维度上的偏移</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func makePortal() -&gt; SCNNode &#123;</span><br><span class="line">  // 1</span><br><span class="line">  let portal = SCNNode()</span><br><span class="line">  </span><br><span class="line">  // 2</span><br><span class="line">  let floorNode = makeFloorNode()</span><br><span class="line">  floorNode.position = SCNVector3(0, POSITION_Y, POSITION_Z)</span><br><span class="line">  </span><br><span class="line">  // 3</span><br><span class="line">  portal.addChildNode(floorNode)</span><br><span class="line">  return portal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>创建一个 SCNNode 来存储传送门</li><li>使用定义的 makeFloorNode() 方法来创建地板结点，使用位置偏移量来设置地板结点的位置。SCNGeometry 的中心会被设置为对准父节点坐标系中的坐标位置</li><li>为传送门结点增添地板结点然后返回传送门结点，注意，当用户点击视图时，renderer(_ :, didAdd:, for:) 中传送门结点被添加给了锚位置上所创建的结点</li></ol><ul><li>运行之后，你会发现地板结点是黑暗的，因为你还没有添加光源，现在开始添加天花板结点</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">func makeCeilingNode() -&gt; SCNNode &#123;</span><br><span class="line">  // 1</span><br><span class="line">  let outerCeilingNode = makeOuterSurfaceNode(</span><br><span class="line">                          width: SURFACE_WIDTH,</span><br><span class="line">                          height: SURFACE_HEIGHT,</span><br><span class="line">                          length: SURFACE_LENGTH)</span><br><span class="line">  </span><br><span class="line">  // 2                                            </span><br><span class="line">  outerCeilingNode.position = SCNVector3(SURFACE_HEIGHT * 0.5,</span><br><span class="line">                                         SURFACE_HEIGHT, 0)</span><br><span class="line">  let ceilingNode = SCNNode()</span><br><span class="line">  ceilingNode.addChildNode(outerCeilingNode)</span><br><span class="line"></span><br><span class="line">  // 3</span><br><span class="line">  let innerCeiling = SCNBox(width: SURFACE_WIDTH,</span><br><span class="line">                            height: SURFACE_HEIGHT,</span><br><span class="line">                            length: SURFACE_LENGTH,</span><br><span class="line">                            chamferRadius: 0)</span><br><span class="line">  </span><br><span class="line">  // 4                            </span><br><span class="line">  innerCeiling.firstMaterial?.lightingModel = .physicallyBased</span><br><span class="line">  innerCeiling.firstMaterial?.diffuse.contents =</span><br><span class="line">    UIImage(named: </span><br><span class="line">    &quot;Assets.scnassets/ceiling/textures/Ceiling_Diffuse.png&quot;)</span><br><span class="line">  innerCeiling.firstMaterial?.emission.contents =</span><br><span class="line">    UIImage(named: </span><br><span class="line">    &quot;Assets.scnassets/ceiling/textures/Ceiling_Emis.png&quot;)</span><br><span class="line">  innerCeiling.firstMaterial?.normal.contents =</span><br><span class="line">    UIImage(named: </span><br><span class="line">    &quot;Assets.scnassets/ceiling/textures/Ceiling_Normal.png&quot;)</span><br><span class="line">  innerCeiling.firstMaterial?.specular.contents =</span><br><span class="line">    UIImage(named: </span><br><span class="line">    &quot;Assets.scnassets/ceiling/textures/Ceiling_Specular.png&quot;)</span><br><span class="line">  innerCeiling.firstMaterial?.selfIllumination.contents =</span><br><span class="line">    UIImage(named: </span><br><span class="line">    &quot;Assets.scnassets/ceiling/textures/Ceiling_Gloss.png&quot;)</span><br><span class="line">  </span><br><span class="line">  // 5</span><br><span class="line">  repeatTextures(geometry: innerCeiling, scaleX: </span><br><span class="line">                 SCALEX, scaleY: SCALEY)</span><br><span class="line">  </span><br><span class="line">  // 6</span><br><span class="line">  let innerCeilingNode = SCNNode(geometry: innerCeiling)</span><br><span class="line">  innerCeilingNode.renderingOrder = 100</span><br><span class="line">  // 7</span><br><span class="line">  innerCeilingNode.position = SCNVector3(SURFACE_HEIGHT * 0.5, </span><br><span class="line">                                         0, 0)</span><br><span class="line">  ceilingNode.addChildNode(innerCeilingNode)  </span><br><span class="line">  return ceilingNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>类似于地板结点，你用地板的大小创建了一个 outerCeilingNode </li><li>设置外层天花板结点的位置以至于它能够位于天花板的上方，创建一个结点去持有内层天花板和外层天花板，增加 outerCeilingNode 为 ceilingNode 的子结点</li><li>给 innerCeiling 创建一个 SCNBox object</li><li>地板材质的光照模型被设置为 physicallyBased，材质可见属性的内容都来自 scnassets catalog 中的质地图片</li><li>材质的质地使用你之前定义的 repeatTextures() 方法在 X 和 Y 方向上重复</li><li>使用 innerCeiling geometry 创建 innerCeilingNode，然后设置它的 渲染顺序为高值，为了能够在 outerCeilingNode 之后被渲染</li><li>在父节点中设置 innerCeilingNode 的位置，然后将它添加作为 ceilingNode 的子结点，返回 ceilingNode 给调用者</li></ol><blockquote><p>makePortal() 中添加到 return 之前</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">let ceilingNode = makeCeilingNode()</span><br><span class="line">ceilingNode.position = SCNVector3(0,</span><br><span class="line">                                  POSITION_Y+WALL_HEIGHT,</span><br><span class="line">                                  POSITION_Z)</span><br><span class="line">// 2</span><br><span class="line">portal.addChildNode(ceilingNode)</span><br></pre></td></tr></table></figure><ol><li><p>使用你刚刚定义的 makeCeilingNode() 来创建天花板结点，设置 ceilingNode 的位置为  SCNVector3 struct，中心点的Y坐标,偏移了地板厚度加墙壁高度的位置.</p><p>你也可以减掉 SURFACE_HEIGHT 来得到天花板的厚度，类似于地板，Z坐标偏移也设置为POSITION_Z，这就是天花板中心点到摄像机在Z轴上的距离</p></li><li><p>添加 ceilingNode 作为传送门的子节点</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">func makeWallNode(length: CGFloat = WALL_LENGTH,</span><br><span class="line">                  height: CGFloat = WALL_HEIGHT,</span><br><span class="line">                  maskLowerSide:Bool = false) -&gt; SCNNode &#123;</span><br><span class="line">    </span><br><span class="line">  // 1                      </span><br><span class="line">  let outerWall = SCNBox(width: WALL_WIDTH,</span><br><span class="line">                         height: height,</span><br><span class="line">                         length: length,</span><br><span class="line">                         chamferRadius: 0)</span><br><span class="line">  // 2                        </span><br><span class="line">  outerWall.firstMaterial?.diffuse.contents = UIColor.white</span><br><span class="line">  outerWall.firstMaterial?.transparency = 0.000001</span><br><span class="line"></span><br><span class="line">  // 3</span><br><span class="line">  let outerWallNode = SCNNode(geometry: outerWall)</span><br><span class="line">  let multiplier: CGFloat = maskLowerSide ? -1 : 1</span><br><span class="line">  outerWallNode.position = SCNVector3(WALL_WIDTH*multiplier,0,0)</span><br><span class="line">  outerWallNode.renderingOrder = 10</span><br><span class="line">  </span><br><span class="line">  // 4</span><br><span class="line">  let wallNode = SCNNode()</span><br><span class="line">  wallNode.addChildNode(outerWallNode)</span><br><span class="line"></span><br><span class="line">  // 5</span><br><span class="line">  let innerWall = SCNBox(width: WALL_WIDTH,</span><br><span class="line">                         height: height,</span><br><span class="line">                         length: length, chamferRadius: 0)</span><br><span class="line">  </span><br><span class="line">  // 6                       </span><br><span class="line">  innerWall.firstMaterial?.lightingModel = .physicallyBased</span><br><span class="line">  innerWall.firstMaterial?.diffuse.contents =</span><br><span class="line">    UIImage(named: </span><br><span class="line">    &quot;Assets.scnassets/wall/textures/Walls_Diffuse.png&quot;)</span><br><span class="line">  innerWall.firstMaterial?.metalness.contents =</span><br><span class="line">    UIImage(named: </span><br><span class="line">    &quot;Assets.scnassets/wall/textures/Walls_Metalness.png&quot;)</span><br><span class="line">  innerWall.firstMaterial?.roughness.contents =</span><br><span class="line">    UIImage(named: </span><br><span class="line">    &quot;Assets.scnassets/wall/textures/Walls_Roughness.png&quot;)</span><br><span class="line">  innerWall.firstMaterial?.normal.contents =</span><br><span class="line">    UIImage(named: </span><br><span class="line">    &quot;Assets.scnassets/wall/textures/Walls_Normal.png&quot;)</span><br><span class="line">  innerWall.firstMaterial?.specular.contents =</span><br><span class="line">    UIImage(named: </span><br><span class="line">    &quot;Assets.scnassets/wall/textures/Walls_Spec.png&quot;)</span><br><span class="line">  innerWall.firstMaterial?.selfIllumination.contents =</span><br><span class="line">    UIImage(named: </span><br><span class="line">    &quot;Assets.scnassets/wall/textures/Walls_Gloss.png&quot;)</span><br><span class="line"></span><br><span class="line">  // 7</span><br><span class="line">  let innerWallNode = SCNNode(geometry: innerWall)</span><br><span class="line">  wallNode.addChildNode(innerWallNode)  </span><br><span class="line">  return wallNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>创建一个 outerWall 结点放置在墙壁的外侧，以至于从外面看是透明的，创建一个 SCNBox 来匹配墙壁的尺寸 </li><li>设置材质的 diffuse contents 为白色以及极地的透明度，帮助达到外部透视的效果</li><li><p>使用 outerWall geometry 创建了一个结点，multiplier 是根据外层墙壁的哪一面需要被渲染而被决定的，如果 maskLowerSide 被设置为真，那么外层墙壁在墙壁节点的坐标系统中会被放置在内层墙壁的下面，否则，它就被放置在内层的上面</p><p>设置节点的位置，这样外层墙壁在 X 维度上偏移了墙壁的宽度，设置外层墙壁的渲染顺序为一个较低的数值，这样它就会被优先渲染，这样会使墙壁从外面不可见</p></li><li><p>创建一个节点来持有墙壁，并将 outerWallNode 添加为其子节点.</p></li><li>为 innerWall 创建一个 SCNBox，尺寸为墙壁的尺寸</li><li>设置 lightingModel 为 physicallyBased，类似于天花板和地板节点,设置可见属性的内容为各种质地图像</li><li>最后,使用 innerWall geometry 创建一个 innerWallNode 对象，添加这个节点到父节点 wallNode 对象上，默认情况下,innerWallNode 会被放置在wallNode 的原点上，返回节点给函数调用者</li></ol><blockquote><p>makePortal() 中添加到 return 之前</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">let farWallNode = makeWallNode()</span><br><span class="line"></span><br><span class="line">// 2</span><br><span class="line">farWallNode.eulerAngles = SCNVector3(0, </span><br><span class="line">                                     90.0.degreesToRadians, 0)</span><br><span class="line"></span><br><span class="line">// 3</span><br><span class="line">farWallNode.position = SCNVector3(0,</span><br><span class="line">                                  POSITION_Y+WALL_HEIGHT*0.5,</span><br><span class="line">                                  POSITION_Z-SURFACE_LENGTH*0.5)</span><br><span class="line">portal.addChildNode(farWallNode)</span><br></pre></td></tr></table></figure><ol><li>创建远处墙壁的节点 farWallNode 需要遮蔽低侧，所以使用 maskLowerSide 的默认值 false 就可以了.</li><li>给节点设置 eulerAngles 因为墙壁是沿 Y 轴旋转的并垂直于摄像机,所以第二个分量旋转为 90 度，在 X 和 Z 轴方向不旋转</li><li>设置 farWallNode 的中心位置,使其高度偏移为 POSITION_Y，它的深度计算是，天花板中心点的深度加上从天花板中心点到远端的距离</li></ol><ul><li>下一步我们将要添加左边和右边的墙壁</li></ul><blockquote><p>添加到 makePortal() 的 return 之前</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">let rightSideWallNode = makeWallNode(maskLowerSide: true)</span><br><span class="line"></span><br><span class="line">// 2</span><br><span class="line">“rightSideWallNode.eulerAngles = SCNVector3(0, 180.0.degreesToRadians, 0)</span><br><span class="line"></span><br><span class="line">// 3</span><br><span class="line">rightSideWallNode.position = SCNVector3(WALL_LENGTH*0.5,</span><br><span class="line">                              POSITION_Y+WALL_HEIGHT*0.5,</span><br><span class="line">                              POSITION_Z)</span><br><span class="line">portal.addChildNode(rightSideWallNode)</span><br><span class="line"></span><br><span class="line">// 4</span><br><span class="line">let leftSideWallNode = makeWallNode(maskLowerSide: true)</span><br><span class="line"></span><br><span class="line">// 5</span><br><span class="line">leftSideWallNode.position = SCNVector3(-WALL_LENGTH*0.5,</span><br><span class="line">                            POSITION_Y+WALL_HEIGHT*0.5,</span><br><span class="line">                            POSITION_Z)</span><br><span class="line">portal.addChildNode(leftSideWallNode)</span><br></pre></td></tr></table></figure><ol><li>为右墙创建一个结点，你想把外墙放在结点的低侧，所以你设置 maskLowerSide 为真</li><li>设置墙壁沿 Y 轴旋转180度，这样确保了墙壁的内侧对着右边.</li><li>设置墙壁的位置，使其与远处墙壁的右侧，天花板，还有地板平齐，将rightSideWallNode 添加为传送门的子节点.</li><li>类似于右墙结点，创建一个结点去表示左墙，并设置 maskLowerSide 为真</li><li>左墙不需要任何旋转，但你还是需要调增它的位置，以至于它与远处墙壁的左侧，地板，天花板齐平，你将左侧墙壁设置为传送门结点的子结点 </li></ol><ul><li>现在你的传送门有了三面墙，并且从外面看时无法看见墙 </li></ul><h2 id="Add-the-doorway"><a href="#Add-the-doorway" class="headerlink" title="Add the doorway"></a>Add the doorway</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let DOOR_WIDTH:CGFloat = 1.0</span><br><span class="line">let DOOR_HEIGHT:CGFloat = 2.4</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func addDoorway(node: SCNNode) &#123;</span><br><span class="line">  // 1</span><br><span class="line">  let halfWallLength: CGFloat = WALL_LENGTH * 0.5</span><br><span class="line">  let frontHalfWallLength: CGFloat = </span><br><span class="line">                   (WALL_LENGTH - DOOR_WIDTH) * 0.5</span><br><span class="line"></span><br><span class="line">  // 2</span><br><span class="line">  let rightDoorSideNode = makeWallNode(length: frontHalfWallLength)</span><br><span class="line">  rightDoorSideNode.eulerAngles = SCNVector3(0,270.0.degreesToRadians, 0)</span><br><span class="line">  rightDoorSideNode.position = SCNVector3(halfWallLength - 0.5 * DOOR_WIDTH,</span><br><span class="line">                                          POSITION_Y+WALL_HEIGHT*0.5,</span><br><span class="line">                                          POSITION_Z+SURFACE_LENGTH*0.5)</span><br><span class="line">  node.addChildNode(rightDoorSideNode)</span><br><span class="line"></span><br><span class="line">  // 3</span><br><span class="line">  let leftDoorSideNode = makeWallNode(length: frontHalfWallLength)</span><br><span class="line">  leftDoorSideNode.eulerAngles = SCNVector3(0, 270.0.degreesToRadians, 0)</span><br><span class="line">  leftDoorSideNode.position = SCNVector3(-halfWallLength + 0.5 * frontHalfWallLength,</span><br><span class="line">                                         POSITION_Y+WALL_HEIGHT*0.5,</span><br><span class="line">                                         POSITION_Z+SURFACE_LENGTH*0.5)</span><br><span class="line">  node.addChildNode(leftDoorSideNode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>定义常量来存储墙长度的一半，以及门两侧墙壁的长度</li><li>用上一步声明的常量，创建一个节点来代表入门右侧的墙壁，你还需要调整一下节点的位置和旋转，以使它对准到右侧墙壁，天花板与地板的接缝处，然后将rightDoorSideNode 添加到指定 node 上，成为其子节点</li><li>创建门框通道的左侧节点，设置 leftDoorSideNode 位置和旋转，最后用 addChildNode() 将其添加到 node 上作为子节点</li></ol><blockquote><p>makePortal() 中添加到 return 之前</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addDoorway(node: portal)</span><br></pre></td></tr></table></figure><ul><li>运行app.你将看到时空门上的门框,但是目前门的上方直通到天花板.我们需要再加一块墙壁来让门框高度达到预告定义的DOOR_HEIGHT.</li></ul><blockquote><p>addDoorway(node:): 中添加到底部</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">let aboveDoorNode = makeWallNode(length: DOOR_WIDTH,</span><br><span class="line">                                 height: WALL_HEIGHT - DOOR_HEIGHT)</span><br><span class="line">// 2                                 </span><br><span class="line">aboveDoorNode.eulerAngles = SCNVector3(0, 270.0.degreesToRadians, 0)</span><br><span class="line">// 3</span><br><span class="line">aboveDoorNode.position =</span><br><span class="line">  SCNVector3(0,</span><br><span class="line">              POSITION_Y+(WALL_HEIGHT-DOOR_HEIGHT)*0.5+DOOR_HEIGHT,</span><br><span class="line">              POSITION_Z+SURFACE_LENGTH*0.5)                                    </span><br><span class="line">node.addChildNode(aboveDoorNode)</span><br></pre></td></tr></table></figure><ol><li>创建一个墙壁节点，尺寸参照上面的入口</li><li>调整aboveDoorNode的旋转，使它在时空门的前面，掩蔽的面朝外</li><li>设置节点的位置，使其正好放置在门框通道的上方，将其添加为node的子节点</li></ol><ul><li>这个时空门看起来并不是太诱人，事实上，它相当暗淡和阴郁，你可以添加一个光源来照亮它们</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func placeLightSource(rootNode: SCNNode) &#123;</span><br><span class="line">  // 1</span><br><span class="line">  let light = SCNLight()</span><br><span class="line">  light.intensity = 10</span><br><span class="line">  // 2</span><br><span class="line">  light.type = .omni</span><br><span class="line">  // 3</span><br><span class="line">  let lightNode = SCNNode()</span><br><span class="line">  lightNode.light = light</span><br><span class="line">  // 4</span><br><span class="line">  lightNode.position = SCNVector3(0,</span><br><span class="line">                                 POSITION_Y+WALL_HEIGHT,</span><br><span class="line">                                 POSITION_Z)</span><br><span class="line">  rootNode.addChildNode(lightNode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>创建一个SCNLight对象并设置它的intensity(强度).因为我们使用的是physicallyBased(基于物理的)灯光模型,这个值就是光源的光通量.默认值是1000流明,但你想要一个较低的强度,让它看起来稍暗些.</li><li>灯光类型决定了灯光的形状和方向,同时还有一系列的属性来修改灯光的行为表现.这里,你设置灯光类型为omnidirectional(全方向),也就是点光源灯光.一个全方向灯光强度和方向是固定的.灯光相对于场景中其它物体的位置决定了光的方向.</li><li>创建一个节点来持有灯光,并将light对象附加到节点的light属性上.</li><li>用Y和Z偏移值,将灯放在天花板的中央,然后将lightNode添加为rootNode的子节点.</li></ol><ul><li>makePortal() 中在 return 之前添加</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">placeLightSource(rootNode: portal)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Chapter-7-Get-Started-Portal-App&quot;&gt;&lt;a href=&quot;#Chapter-7-Get-Started-Portal-App&quot; class=&quot;headerlink&quot; title=&quot;Chapter 7: Get Started: Port
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ARKit by Tutorials Section Ⅰ 野生笔记</title>
    <link href="http://yoursite.com/2018/09/18/arkitSection1/"/>
    <id>http://yoursite.com/2018/09/18/arkitSection1/</id>
    <published>2018-09-17T16:00:00.000Z</published>
    <updated>2018-10-22T07:58:01.133Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter-2-Creat-a-Basic-ARkit-Application"><a href="#Chapter-2-Creat-a-Basic-ARkit-Application" class="headerlink" title="Chapter 2: Creat a Basic ARkit Application"></a>Chapter 2: Creat a Basic ARkit Application</h1><h2 id="ARSCNView"><a href="#ARSCNView" class="headerlink" title="ARSCNView"></a>ARSCNView</h2><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fvtmajg2d7j31kw0r4184.jpg" alt=""></p><ul><li><p>使你将 3D 物体覆盖于摄像头返回的实时视频流，并提供 ARKit 和 SceneKit 无缝的整合 </p></li><li><p>ARSKView，也可以提供 ARKit 和 SpriteKit 的整合，只不过显示的是 2D SpriteKit 内容 而不是 3D SceneKit 内容</p></li></ul><h2 id="View-Controller"><a href="#View-Controller" class="headerlink" title="View Controller"></a>View Controller</h2><ul><li>ViewController 直接继承自标准的 UIViewController，提供很多基础设施，用于管理基于 UIKit 应用的各种视图</li><li>同样遵循 ARKit 中的 ARSCNViewDelegate 协议，其中很多方法可使你的 SceneKit content 和你的 AR session 同步</li></ul><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fvtmi50w9sj31kw0qh7t5.jpg" alt=""></p><h2 id="Creat-an-asset-catalog"><a href="#Creat-an-asset-catalog" class="headerlink" title="Creat an asset catalog"></a>Creat an asset catalog</h2><ul><li><p>这是一个专门用于 SceneKit assets 的特殊文件夹，SceneKit 是一个强大的的高级图形框架，可以创建和管理所有的图像和声音内容。这个文件夹就是你放置 scenes，textures， 3D models，animation，sound effects 和 music 的地方</p></li><li><p>创建流程</p></li></ul><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fvtn6befp3j31kw0zjnpd.jpg" alt=""></p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fvtn6p4ha8j31kw0yyngv.jpg" alt=""></p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fvtn7rt7krj31kw0v5azj.jpg" alt=""></p><ul><li>.scnassets 文件扩展名类型告诉 Xcode 文件夹的内容包括与 SceneKit 有关的文件，这个文件夹，以及它的内容，都会成为你应用包的一部分，将会被部署给设备</li></ul><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fvtn8h3jgtj31kw0z11e8.jpg" alt=""></p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fvtn8x1p6fj31kw0gbare.jpg" alt=""></p><h2 id="Creat-an-new-SceneKit-scene"><a href="#Creat-an-new-SceneKit-scene" class="headerlink" title="Creat an new SceneKit scene"></a>Creat an new SceneKit scene</h2><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fvtnihmnwoj30qs0w41kx.jpg" alt=""></p><h2 id="Load-SceneKit-scenes"><a href="#Load-SceneKit-scenes" class="headerlink" title="Load SceneKit scenes"></a>Load SceneKit scenes</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let scene = SCNScene(named: &quot;PokerDice.scnassets/SimpleScene.scn&quot;)!</span><br></pre></td></tr></table></figure><h2 id="Get-rid-of-status-bar"><a href="#Get-rid-of-status-bar" class="headerlink" title="Get rid of status bar"></a>Get rid of status bar</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">override var prefersStatusBarHidden: Bool &#123;</span><br><span class="line">    return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Chapter-3-Basic-Session-Management"><a href="#Chapter-3-Basic-Session-Management" class="headerlink" title="Chapter 3: Basic Session Management"></a>Chapter 3: Basic Session Management</h1><h2 id="Mark-out-sections"><a href="#Mark-out-sections" class="headerlink" title="Mark out sections"></a>Mark out sections</h2><p><img src="https://i.loli.net/2018/09/22/5ba5ae2c6c97c.png" alt=""></p><h4 id="View-Management"><a href="#View-Management" class="headerlink" title="View Management"></a>View Management</h4><ul><li>这里面都是与 View 有关联的，不会修改过多，除了 <code>viewDidLoad()</code>，一直在添加各种初始化函数</li></ul><h4 id="Initialization"><a href="#Initialization" class="headerlink" title="Initialization"></a>Initialization</h4><ul><li><p>这里有之前提到的各种初始化函数</p><ul><li><code>initSceneView()</code> 负责设置 sceneView 的 delegate</li><li><code>initScene()</code>负责加载你的场景</li><li><code>initARSession()</code>现在还只是个空壳</li></ul></li></ul><h4 id="The-ARSCNViewDelegate-protocol-extension"><a href="#The-ARSCNViewDelegate-protocol-extension" class="headerlink" title="The ARSCNViewDelegate protocol extension"></a>The ARSCNViewDelegate protocol extension</h4><ul><li>这个协议被移到自己的扩展中，提高整个代码可读性</li></ul><h2 id="Create-the-configuration"><a href="#Create-the-configuration" class="headerlink" title="Create the configuration"></a>Create the configuration</h2><ul><li><p>ARSCNView view 本质上就是 SceneKit view，它包括一个 ARSession ，负责 ARKit 的运动追踪和图像处理，这是基于 session 的，意味着你必须创建一个 ARSession 实例，通过 “run” 来开启 AR 的追踪过程</p></li><li><p>在开启 ARSession 之前，你必须去创建一个 ARSession 配置，这个配置被用于建立现实世界和虚拟世界的联系，也就是你的设备位置和虚拟内容的位置关系</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func initARSession() &#123;</span><br><span class="line">    guard ARWorldTrackingConfiguration.isSupported else &#123;</span><br><span class="line">      print(&quot;*** ARConfig: AR World Tracking Not Supported&quot;)</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    // 1</span><br><span class="line">    let config = ARWorldTrackingConfiguration()</span><br><span class="line">    // 2</span><br><span class="line">    config.worldAlignment = .gravity</span><br><span class="line">    // 3</span><br><span class="line">    config.providesAudioData = false</span><br><span class="line">    // 4</span><br><span class="line">    sceneView.session.run(config)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol><li>创建一个 ARWorldTrackingConfiguration 实例，分配给 config </li><li>设置 worldAlignment 的属性，也就是具体说明虚拟的内容将如何与现实世界相关联</li><li>不允许 ARSession 捕捉声音，还有一个属性 <code>isLightEstimationEnabled 之后会学到</code></li><li>运行 ARSession ，并使用你刚刚设置好的配置，现在实时追踪 6DOF 维度的数据</li></ol><h2 id="Controll-an-ARSession"><a href="#Controll-an-ARSession" class="headerlink" title="Controll an ARSession"></a>Controll an ARSession</h2><ul><li>虽然 ARSession 已经在运行了，但是你需要根据你的应用内的具体情况来管理 ARSession</li></ul><ol><li>Pause：暂停 ARSession 的捕捉，可以用于用户切换应用时<br><code>ARSession.pause()</code></li><li>Resume：继续一个中断的 session，使用已经存在的配置去重新继续捕捉过程<br><code>ARSession.run()</code></li><li>Update：用于更新配置，也许你想要启用声音捕捉，首先你需要得到当前的 session，修改它的配置，之后重新用新配置开启会话<br><code>ARSession.run(ARSessionConfig)</code></li><li>Reset：重启 ARSession<br><code>ARSession.run(_:options:)</code></li></ol><h2 id="Update-the-status-message"><a href="#Update-the-status-message" class="headerlink" title="Update the status message"></a>Update the status message</h2><blockquote><p>Properties</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var trackingStatus: String = &quot;&quot;</span><br></pre></td></tr></table></figure><blockquote><p>SceneKit Management</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func renderer(_ renderer: SCNSceneRenderer, </span><br><span class="line">   updateAtTime time: TimeInterval) &#123;</span><br><span class="line">   DispatchQueue.main.async &#123;</span><br><span class="line">     self.statusLabel.text = self.trackingStatus</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意：当更新 UI 中的元素时，例如 status bar label，你必须在主线程  DispatchQueue.main.async { … } 中进行更新</li></ul><h2 id="Handle-AR-session-errors"><a href="#Handle-AR-session-errors" class="headerlink" title="Handle AR session errors"></a>Handle AR session errors</h2><blockquote><p>Session Error Management</p></blockquote><ol><li>Session 失败</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func session(_ session: ARSession, didFailWithError error: Error) &#123;</span><br><span class="line">  trackingStatus = &quot;AR Session Failure: \(error)&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>Session 中断</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func sessionWasInterrupted(_ session: ARSession) &#123;</span><br><span class="line">  trackingStatus = &quot;AR Session Was Interrupted!&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>Session 中断结束</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func sessionInterruptionEnded(_ session: ARSession) &#123;</span><br><span class="line">  trackingStatus = &quot;AR Session Interruption Ended&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Handle-AR-session-state-changes"><a href="#Handle-AR-session-state-changes" class="headerlink" title="Handle AR session state changes"></a>Handle AR session state changes</h2><ul><li>当 ARSession 运行时，会话能够根据外部条件和事件来改变捕捉状态，每一次会话的状态改变，<code>session(_ session: ARSession, cameraDidChangeTrackingState camera: ARCamera)</code>方法都会被触发，我们需要监视所有的 ARCamera.trackingStatus 的状态改变。</li></ul><blockquote><p>Session State Management</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">func session(_ session: ARSession,</span><br><span class="line">               cameraDidChangeTrackingState camera: ARCamera) &#123;</span><br><span class="line">    switch camera.trackingState &#123;</span><br><span class="line">    // 1</span><br><span class="line">    case .notAvailable:</span><br><span class="line">      trackingStatus = &quot;Tacking:  Not available!&quot;</span><br><span class="line">      break</span><br><span class="line">    // 2</span><br><span class="line">    case .normal:</span><br><span class="line">      trackingStatus = &quot;Tracking: All good!&quot;</span><br><span class="line">      break</span><br><span class="line">    // 3</span><br><span class="line">    case .limited(let reason):</span><br><span class="line">      switch reason &#123;</span><br><span class="line">      case .excessiveMotion:</span><br><span class="line">        trackingStatus = &quot;Tracking: Limited due to excessive motion!&quot;</span><br><span class="line">      // 3.1</span><br><span class="line">      case .insufficientFeatures:</span><br><span class="line">        trackingStatus = &quot;Tracking: Limited due to insufficient features!&quot;</span><br><span class="line">      // 3.2</span><br><span class="line">      case .initializing:</span><br><span class="line">        trackingStatus = &quot;Tracking: Initializing...&quot;</span><br><span class="line">      // 3.3</span><br><span class="line">      case .relocalizing:</span><br><span class="line">        trackingStatus = &quot;Tracking: Relocalizing...&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="Show-debug-options"><a href="#Show-debug-options" class="headerlink" title="Show debug options"></a>Show debug options</h2><blockquote><p>initSceneView()</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sceneView.debugOptions = [</span><br><span class="line">      ARSCNDebugOptions.showFeaturePoints,</span><br><span class="line">      ARSCNDebugOptions.showWorldOrigin,</span><br><span class="line">      SCNDebugOptions.showBoundingBoxes,</span><br><span class="line">      SCNDebugOptions.showWireframe</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><h1 id="Chapter-4-Add-3D-Objects-and-Textures"><a href="#Chapter-4-Add-3D-Objects-and-Textures" class="headerlink" title="Chapter 4: Add 3D Objects and Textures"></a>Chapter 4: Add 3D Objects and Textures</h1><h2 id="Create-the-dice-scene"><a href="#Create-the-dice-scene" class="headerlink" title="Create the dice scene"></a>Create the dice scene</h2><ul><li><p>COLLADA 是一种 3D 物体流行的文件格式，Xcode 完全兼容这种格式，你只需要插入这种格式的文件，使用 Xcode 将它们转换为本地的 SceneKit 模型</p><blockquote><p>步骤：</p><ol><li>COLLDA 格式 –&gt; 转换为 SceneKit scene file format (.scn)</li><li>新建 DiceScene.scn ，在里面复制粘贴出五个 dice  </li></ol></blockquote></li></ul><h2 id="Load-3D-objects"><a href="#Load-3D-objects" class="headerlink" title="Load 3D objects"></a>Load 3D objects</h2><ul><li>创建一个新的场景 ，使得骰子进入增强现实场景</li></ul><blockquote><p>initScene()</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let scene = SCNScene()</span><br></pre></td></tr></table></figure><ul><li>为 AR scene 准备一个 environment map 。现在 scene 已经为基于 PBR 的 3D 物体准备好了一个合适的 lighting environment map </li></ul><blockquote><p>initScene()</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scene.lightingEnvironment.contents = </span><br><span class="line">   &quot;PokerDice.scnassets/Textures/Environment_CUBE.jpg&quot;</span><br><span class="line">scene.lightingEnvironment.intensity = 2</span><br></pre></td></tr></table></figure><ul><li>创建一个数组，因为你刚刚创建了五个风格不一的 dice node</li></ul><blockquote><p>Properties</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var diceNodes: [SCNNode] = []</span><br></pre></td></tr></table></figure><ul><li>现在需要把这些 dice nodes 加载进入数组</li></ul><blockquote><p>Load Models</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func loadModels() &#123;</span><br><span class="line">  // 1      </span><br><span class="line">  let diceScene = SCNScene(</span><br><span class="line">    named: &quot;PokerDice.scnassets/Models/DiceScene.scn&quot;)!</span><br><span class="line">  // 2</span><br><span class="line">  for count in 0..&lt;5 &#123;</span><br><span class="line">    // 3</span><br><span class="line">    diceNodes.append(diceScene.rootNode.childNode(</span><br><span class="line">      withName: &quot;dice\(count)&quot;, </span><br><span class="line">      recursively: false)!)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol><li>加载 DiceScene.scn 并存储进 diceScene</li><li>循环五次</li><li>childNode() 搜索 diceScene.rootNode scene， 寻找所有的骰子，一旦发现，添加 dice node 到 diceNodes 数组</li></ol><ul><li>在一开始就调用方法</li></ul><blockquote><p>viewDidLoad()</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.loadModels()</span><br></pre></td></tr></table></figure><h2 id="Place-3D-objects"><a href="#Place-3D-objects" class="headerlink" title="Place 3D objects"></a>Place 3D objects</h2><ul><li>dice nodes 已被加载，准备放入增强现实场景中 </li></ul><blockquote><p>Properties</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var diceCount: Int = 5</span><br><span class="line">var diceStyle: Int = 0</span><br><span class="line">var diceOffset: [SCNVector3] = [SCNVector3(0.0,0.0,0.0),</span><br><span class="line">                           SCNVector3(-0.05, 0.00, 0.0),</span><br><span class="line">                           SCNVector3(0.05, 0.00, 0.0),</span><br><span class="line">                           SCNVector3(-0.05, 0.05, 0.02),</span><br><span class="line">                           SCNVector3(0.05, 0.05, 0.02)]</span><br></pre></td></tr></table></figure><ul><li>diceCount：计数手中还有多少骰子</li><li>diceStyle：代表不同风格的骰子</li><li>diceOffset：一组位置偏移</li></ul><blockquote><p>Helper Functions</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func throwDiceNode(transform: SCNMatrix4, offset: SCNVector3) &#123;</span><br><span class="line">    // 1</span><br><span class="line">    let position = SCNVector3(transform.m41 + offset.x,</span><br><span class="line">                              transform.m42 + offset.y,</span><br><span class="line">                              transform.m43 + offset.z)</span><br><span class="line">    // 2</span><br><span class="line">    let diceNode = diceNodes[diceStyle].clone()</span><br><span class="line">    diceNode.name = &quot;dice&quot;</span><br><span class="line">    diceNode.position = position</span><br><span class="line">    //3</span><br><span class="line">    sceneView.scene.rootNode.addChildNode(diceNode)</span><br><span class="line">    //diceCount -= 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>将转换后的数据和传入函数的数据联合创建了一个位置偏移量</li><li>克隆了一个被选中的 dice node，重新命名为 “dice” ，并且设置它的位置</li><li>克隆的 dice node 被放置于增强现实场景中，diceCount 自减表示手中少了一个骰子</li></ol><h2 id="Add-a-swipe-gesture"><a href="#Add-a-swipe-gesture" class="headerlink" title="Add a swipe gesture"></a>Add a swipe gesture</h2><blockquote><p>Actions</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@IBAction func swipeUpGestureHandler(_ sender: Any) &#123;</span><br><span class="line">    // 1</span><br><span class="line">    guard let frame = self.sceneView.session.currentFrame else &#123; return &#125;</span><br><span class="line">    // 2</span><br><span class="line">    for count in 0..&lt;diceCount &#123;</span><br><span class="line">      throwDiceNode(transform: SCNMatrix4(frame.camera.transform),</span><br><span class="line">                    offset: diceOffset[count])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol><li>currentFrame 是一个 ARFrame 对象，连接着增强现实场景，它包含最近捕捉的视频帧图像的，同时还有捕捉的深度数据，AR 相机，当前的环境估计光，锚，特征点，这行代码确保这有一个可用的画面</li><li>遍历了五个骰子，使用 AR 相机的转换矩阵，它包含关于相机位置和旋转的信息，一次抛出一个骰子进入 AR scene ，最后将会抛出你手中所有的骰子 </li></ol><h2 id="Change-dice-styles"><a href="#Change-dice-styles" class="headerlink" title="Change dice styles"></a>Change dice styles</h2><blockquote><p>Actions</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@IBAction func styleButtonPressed(_ sender: Any) &#123;</span><br><span class="line">    diceStyle = diceStyle &gt;= 4 ? 0 : diceStyle + 1</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="Chapter-5-Detect-Surface"><a href="#Chapter-5-Detect-Surface" class="headerlink" title="Chapter 5: Detect Surface"></a>Chapter 5: Detect Surface</h1><h2 id="Define-game-states"><a href="#Define-game-states" class="headerlink" title="Define game states"></a>Define game states</h2><blockquote><p>Game State</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum GameState: Int16 &#123;</span><br><span class="line">  case detectSurface  </span><br><span class="line">  case pointToSurface   </span><br><span class="line">  case swipeToPlay</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>detectSurface：ARKit 需要花费一点时间去理解它的环境，然后开始检测平面。只要游戏处于这个状态中，玩家就必须去扫描他们的环境以寻找合适的水平平面,一旦玩家对于 ARKit 所侦测到的平面满意，就可以进入下一阶段。</li><li>pointToSurface：玩家现在将设备指向侦测到的平面，出现一个准心光标，准心光标表示目标点，也就是骰子将会掷向的地方</li><li>swipeToPlay：一旦目标点出现，玩家向准心光标掷出骰子</li></ul><h2 id="Add-game-state-messages"><a href="#Add-game-state-messages" class="headerlink" title="Add game state messages"></a>Add game state messages</h2><blockquote><p>Properties</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var gameState: GameState = .detectSurface</span><br><span class="line">var statusMessage: String = &quot;&quot;</span><br></pre></td></tr></table></figure><blockquote><p>Helper Functions</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func updateStatus() &#123;</span><br><span class="line">  // 1</span><br><span class="line">  switch gameState &#123;</span><br><span class="line">    case .detectSurface:</span><br><span class="line">      statusMessage = &quot;Scan entire table surface...\nHit START when ready!&quot;</span><br><span class="line">    case .pointToSurface:</span><br><span class="line">      statusMessage = &quot;Point at designated surface first!&quot;</span><br><span class="line">    case .swipeToPlay:</span><br><span class="line">      statusMessage = &quot;Swipe UP to throw!\nTap on dice to collect it again.&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  // 2    </span><br><span class="line">  self.statusLabel.text = trackingStatus != &quot;&quot; ? </span><br><span class="line">    &quot;\(trackingStatus)&quot; : &quot;\(statusMessage)&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>SceneKit Management</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func renderer(_ renderer: SCNSceneRenderer, updateAtTime time: TimeInterval) &#123;</span><br><span class="line">    DispatchQueue.main.async &#123;</span><br><span class="line">      //self.statusLabel.text = self.trackingStatus</span><br><span class="line">      self.updateStatus()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="Anchors"><a href="#Anchors" class="headerlink" title="Anchors"></a>Anchors</h2><ul><li>ARKit 使用一个虚拟的锚去固定你的 3D 物体，当玩家在现实世界移动设备时，可以保持 3D 物体的位置</li><li><strong>ARAnchor 包含一个真实世界中的位置和朝向，并且不可见，它只是一个 ARKit 场景中的一个对象。ARKit 会默认给每一个 ARAnchor 配对一个空的 SCNNode，你要做的就是添加你的 3D 物体作为这个 node 的子对象</strong></li><li>ARPlaneAnchor 是一种特殊类型的锚，包含了一个真实世界的位置和朝向，并且还附加了平面信息，包括中心点，朝向，以及范围大小，你能够使用这些信息去创造一个 SceneKit plane node</li></ul><h2 id="Detect-surfaces"><a href="#Detect-surfaces" class="headerlink" title="Detect surfaces"></a>Detect surfaces</h2><blockquote><p>Initialization</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func initARSession() &#123;</span><br><span class="line">    guard ARWorldTrackingConfiguration.isSupported else &#123;</span><br><span class="line">      print(&quot;*** ARConfig: AR World Tracking Not Supported&quot;)</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    let config = ARWorldTrackingConfiguration()</span><br><span class="line">    config.worldAlignment = .gravity</span><br><span class="line">    config.providesAudioData = false</span><br><span class="line">    config.planeDetection = .horizontal</span><br><span class="line">    sceneView.session.run(config)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>ARKit 将会开始侦测水平平面，并且为每一个侦测到的平面自动生成 ARPlaneAnchor</li><li>通过使用 <code>.vertical</code> 代替，你还可以侦测垂直的平面</li></ul><h2 id="Create-new-planes"><a href="#Create-new-planes" class="headerlink" title="Create new planes"></a>Create new planes</h2><ul><li>当一个新的 plane anchor 被添加时，此函数可以创建一个对应的可视对象，这个函数接受 ARPlaneAnchor 以及 UIColor 作为参数，现在我们可以生成一个 SceneKit Plane node</li></ul><blockquote><p>Helper Functions</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func createARPlaneNode(planeAnchor: ARPlaneAnchor, color: UIColor) -&gt; SCNNode &#123;</span><br><span class="line">    </span><br><span class="line">    // 1 </span><br><span class="line">    let planeGeometry = SCNPlane(width: CGFloat(planeAnchor.extent.x),</span><br><span class="line">                                 height: CGFloat(planeAnchor.extent.z))</span><br><span class="line">    </span><br><span class="line">    // 2</span><br><span class="line">    let planeMaterial = SCNMaterial()</span><br><span class="line">    planeMaterial.diffuse.contents = &quot;PokerDice.scnassets/Textures/Surface_DIFFUSE.png&quot; //color</span><br><span class="line">    planeGeometry.materials = [planeMaterial]</span><br><span class="line">    </span><br><span class="line">    // 3</span><br><span class="line">    let planeNode = SCNNode(geometry: planeGeometry)</span><br><span class="line">    planeNode.position = SCNVector3Make(planeAnchor.center.x, 0, planeAnchor.center.z)</span><br><span class="line">    planeNode.transform = SCNMatrix4MakeRotation(-Float.pi / 2, 1, 0, 0)</span><br><span class="line">    </span><br><span class="line">    return planeNode</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol><li>使用锚的范围大小来生成 plane 的几何形状</li><li>创建一个新的材质，然后设置它的 diffuse.contents 属性</li><li>创建 plane node</li></ol><blockquote><p>第三步详解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 1 </span><br><span class="line">let planeNode = SCNNode(geometry: planeGeometry)</span><br><span class="line">// 2</span><br><span class="line">planeNode.position = SCNVector3Make(</span><br><span class="line">  planeAnchor.center.x, 0, planeAnchor.center.z)</span><br><span class="line">// 3</span><br><span class="line">planeNode.transform = SCNMatrix4MakeRotation(-Float.pi / 2, 1, 0, 0)</span><br><span class="line">// 4        </span><br><span class="line">return planeNode</span><br></pre></td></tr></table></figure></blockquote><ol><li>通过传入之前生成的 plane geometry，创建了一个新的 plane node</li><li>基于锚的中心点设置了 plane node 的位置</li><li>通过 SCNPlane 生成的几何形状默认是垂直的，所以你需要绕 X 轴顺时针旋转 90 度，使得 plane 平躺，当你直接创建垂直平面的时候，你可以直接忽略这一步</li><li>返回给调用者</li></ol><h2 id="Handle-new-plane-anchors"><a href="#Handle-new-plane-anchors" class="headerlink" title="Handle new plane anchors"></a>Handle new plane anchors</h2><ul><li>随着平面侦测的激活，ARKit 会自动为每一个它侦测到的水平平面创建 ARPlaneAnchors，当添加新的锚时，renderer(_:didAdd:for) 方法被调用。你需要去做的就是等待这个事件被触发，然后为锚创建一个对应的 SceneKit plane</li></ul><blockquote><p>Plane Management</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">func renderer(_ renderer: SCNSceneRenderer, didAdd node: SCNNode, for anchor: ARAnchor) &#123;</span><br><span class="line"> // 2</span><br><span class="line">    guard let planeAnchor = anchor as? ARPlaneAnchor else &#123; return &#125;</span><br><span class="line">    // 3</span><br><span class="line">    DispatchQueue.main.async &#123;</span><br><span class="line">      // 4</span><br><span class="line">      let planeNode = self.createARPlaneNode(planeAnchor: planeAnchor,</span><br><span class="line">                                             color: UIColor.yellow.withAlphaComponent(0.5))</span><br><span class="line">      // 5                                                        </span><br><span class="line">      node.addChildNode(planeNode)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol><li>注意这个委托方法接受了一个 SCNNode，这是一个新的 SceneKit node，会与接受到的 ARAnchor node 进行配对</li><li>你只关注 ARPlaneAnchors，因此将会筛选出这一类的锚</li><li>你只能在主线程里面创建可视对象</li><li>调用你刚刚创建的 createARPlaneNode()，传入锚的信息和颜色 </li><li>plane node 被添加作为 ARKit 所创建的 node 的子对象</li></ol><h2 id="Update-planes"><a href="#Update-planes" class="headerlink" title="Update planes"></a>Update planes</h2><ul><li>ARKit 一开始可能没有侦测到整个平面，随着玩家移动你需要去更新之前侦测到的平面</li><li>你需要使用全新的位置，朝向，尺寸大小去更新一个已经存在的 plane node</li></ul><blockquote><p>Helper Functions</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func updateARPlaneNode(planeNode: SCNNode, planeAchor: ARPlaneAnchor) &#123;</span><br><span class="line">  let planeGeometry = planeNode.geometry as! SCNPlane</span><br><span class="line">  // 1</span><br><span class="line">  planeGeometry.width = CGFloat(planeAchor.extent.x)</span><br><span class="line">  planeGeometry.height = CGFloat(planeAchor.extent.z)</span><br><span class="line">  // 2</span><br><span class="line">  planeNode.position = SCNVector3Make(planeAchor.center.x, 0, planeAchor.center.z)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>从 plane node 那取回了之前生成的 planeGeometry，然后基于之前的 planeAnchor 更新了它的宽度和高度信息</li><li>基于之前 planeAnchor 的位置信息更新 planeNode 的位置</li></ol><ul><li>如果之前侦测的平面有新的信息更新，ARKit 将会触发 renderer(_:didUpdate:for) 方法，</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">func renderer(_ renderer: SCNSceneRenderer, didUpdate node: SCNNode, for anchor: ARAnchor) &#123;</span><br><span class="line">  // 2</span><br><span class="line">  guard let planeAnchor = anchor as? ARPlaneAnchor else &#123; return &#125;</span><br><span class="line">    // 3</span><br><span class="line">    DispatchQueue.main.async &#123;</span><br><span class="line">      // 4</span><br><span class="line">      self.updateARPlaneNode(planeNode: node.childNodes[0],</span><br><span class="line">        planeAchor: planeAnchor)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>注意这个代理方法接受了一个 SCNNode，这是一个一直存在的 node，之前添你将 planeNode 添加到此 node 中</li><li>再一次，你只感兴趣 ARPlaneAnchors，所以将会筛选出此类的锚</li><li>你只能在主线程里更新可视对象</li><li>最后调用 updatePlane()，你正在传入第一个子 node，以及一个相关联的 plane anchor</li></ol><h2 id="Create-a-focus-node"><a href="#Create-a-focus-node" class="headerlink" title="Create a focus node"></a>Create a focus node</h2><ul><li>现在你的 AR 游戏正在侦测平面，当用户掷出骰子时你应该提供用户某样东西可以去参照，如何将 focus node 置于平面之上，也就是用户所指之处，答案就是 ray casting</li></ul><h4 id="load-focus-node"><a href="#load-focus-node" class="headerlink" title="load focus node"></a>load focus node</h4><blockquote><p>Properties</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var focusNode: SCNNode!</span><br></pre></td></tr></table></figure><blockquote><p>loadModels()</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let focusScene = SCNScene(</span><br><span class="line">  named: &quot;PokerDice.scnassets/Models/FocusScene.scn&quot;)!</span><br><span class="line">focusNode = focusScene.rootNode.childNode(</span><br><span class="line">  withName: &quot;focus&quot;, recursively: false)!</span><br><span class="line">sceneView.scene.rootNode.addChildNode(focusNode)</span><br></pre></td></tr></table></figure><ul><li>加载了新场景，然后保存到 focusNode 中去</li></ul><h4 id="Ray-casting"><a href="#Ray-casting" class="headerlink" title="Ray casting"></a>Ray casting</h4><ul><li>Ray casting 是当玩家搜寻 3D 物体时，从屏幕中心投射虚拟射线进入场景中。在这种特殊情况中，场景中的射线与 plane nodes 产生相交点，一旦相交，相交位置就被用来放置 focus node</li></ul><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fvgx0ii2eqj31kw115kjm.jpg" alt=""></p><h4 id="Create-the-focus-point"><a href="#Create-the-focus-point" class="headerlink" title="Create the focus point"></a>Create the focus point</h4><blockquote><p>Properties</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var focusPoint:CGPoint!</span><br></pre></td></tr></table></figure><blockquote><p>initSceneView()</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">focusPoint = CGPoint(x: view.center.x, y: view.center.y + view.center.y * 0.25)</span><br></pre></td></tr></table></figure><h4 id="Handle-orientation-changes"><a href="#Handle-orientation-changes" class="headerlink" title="Handle orientation changes"></a>Handle orientation changes</h4><blockquote><p>View Management</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@objc func orientationChanged() &#123;</span><br><span class="line">  focusPoint = CGPoint(x: view.center.x, y: view.center.y + view.center.y * 0.25)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>initSceneView()</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NotificationCenter.default.addObserver(self, </span><br><span class="line">  selector: #selector(ViewController.orientationChanged),</span><br><span class="line">  name: NSNotification.Name.UIDeviceOrientationDidChange,</span><br><span class="line">  object: nil)</span><br></pre></td></tr></table></figure><ul><li>当用户改变设备朝向的时候，NSNotification.Name.UIDeviceOrientationDidChange 被触发</li><li>现在每一次设备的朝向改变你都会得到通知，同时你也保持 focusPoint 一直更新</li></ul><h4 id="Update-the-focus-node"><a href="#Update-the-focus-node" class="headerlink" title="Update the focus node"></a>Update the focus node</h4><ul><li>基于屏幕的 focus point 持续地更新 focus node</li></ul><blockquote><p>Helper Functions</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func updateFocusNode() &#123;</span><br><span class="line">  // 1</span><br><span class="line">  let results = self.sceneView.hitTest(self.focusPoint, </span><br><span class="line">    types: [.existingPlaneUsingExtent])</span><br><span class="line">  // 2 </span><br><span class="line">  if results.count == 1 &#123;</span><br><span class="line">    if let match = results.first &#123;</span><br><span class="line">      // 3</span><br><span class="line">      let t = match.worldTransform</span><br><span class="line">     // 4</span><br><span class="line">      self.focusNode.position = SCNVector3( x: t.columns.3.x, y: t.columns.3.y,</span><br><span class="line">        z: t.columns.3.z)</span><br><span class="line">      self.gameState = .swipeToPlay</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 5</span><br><span class="line">    self.gameState = .pointToSurface</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>sceneView.hitTest() 执行一个 ray cast，你提供一个屏幕位置，也就是发射射线的位置，你也需要提供你正在寻找的对象的类型，.existingPlaneUsingExtent 具体说明了你只搜寻那些基于自身范围大小的已侦测到的平面，hits 被保存在 results 中。当然你还可以基于其他类型执行 ray cast，例如 featurePoints，estimatedHorizontalPlane，existingPlane.</li><li>你只需要寻找第一个 hit 结果，因此一旦发现，你要准备去更新 focus node</li><li>你将会使用 hit 结果的 worldTransform，这个矩阵包括位置，朝向，以及范围大小信息</li><li>你将基于 hit 结果 的 transform matrix 来更新 focus node 的位置，位置信息位于 transform matrix 的第三列</li><li>如果结果未被发现，游戏将会持续指导玩家去指向已被侦测到的平面</li></ol><blockquote><p>SceneKit Management</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func renderer(_ renderer: SCNSceneRenderer, updateAtTime time: TimeInterval) &#123;</span><br><span class="line">    DispatchQueue.main.async &#123;</span><br><span class="line">      //self.statusLabel.text = self.trackingStatus</span><br><span class="line">      self.updateStatus()</span><br><span class="line">      self.updateFocusNode()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>你现在应该看见了侦测到的平面，focus node 会立即弹出并且跟随你，随着你的指向而移动</li></ul><h4 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h4><ul><li>你可能会注意到有时候你的平面会部分重叠，ARKit 有时会合并多个侦测到的平面为一个平面，为了做到这个，ARKit 在创建新的之前需要去删除旧的平面，问题在于你还未执行 renderer(_:didRemove:for) 方法</li></ul><blockquote><p>Helper Functions</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func removeARPlaneNode(node: SCNNode) &#123;</span><br><span class="line">    for childNode in node.childNodes &#123;</span><br><span class="line">      childNode.removeFromParentNode()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>Plane Management</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func renderer(_ renderer: SCNSceneRenderer, didRemove node: SCNNode, for anchor: ARAnchor) &#123;</span><br><span class="line">    guard anchor is ARPlaneAnchor else &#123; return &#125;</span><br><span class="line">    DispatchQueue.main.async &#123;</span><br><span class="line">      self.removeARPlaneNode(node: node)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="Chapter-6-Add-Physics"><a href="#Chapter-6-Add-Physics" class="headerlink" title="Chapter 6: Add Physics"></a>Chapter 6: Add Physics</h1><h2 id="The-physics-body"><a href="#The-physics-body" class="headerlink" title="The physics body"></a>The physics body</h2><ul><li><p>为了使对象能够参与到 SceneKit 内置的物理模拟环境中，你必须要为 SCNode 新增SCNPhysicsBody</p></li><li><p>这里有三种基本的物理形态：</p></li></ul><ol><li>静态：本质上就是静止，例如城墙，在模拟环境中，其他物理形态物体将会和静态物体相互作用，但不会有任何反应，它将保持静止状态</li><li>动态: 完全被物理引擎所控制，在模拟环境中，动态物体可以四处移动与其他物理形态物体相互作用，例如骰子和球</li><li>运动态: 不被物理模拟环境所控制，被编程控制。允许你创建动态可移动的对象参与到物理模拟环境中去，例如越狱类游戏中的短浆</li></ol><h2 id="Controll-the-physics-world-speed"><a href="#Controll-the-physics-world-speed" class="headerlink" title="Controll the physics world speed"></a>Controll the physics world speed</h2><blockquote><p>initScene()</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scene.physicsWorld.speed = 0.05</span><br></pre></td></tr></table></figure><h2 id="Controll-the-physics-simulation-speed"><a href="#Controll-the-physics-simulation-speed" class="headerlink" title="Controll the physics simulation speed"></a>Controll the physics simulation speed</h2><blockquote><p>initScene()</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scene.physicsWorld.timeStep = 1.0 / 60.0</span><br></pre></td></tr></table></figure><h2 id="Recover-fallen-dice"><a href="#Recover-fallen-dice" class="headerlink" title="Recover fallen dice"></a>Recover fallen dice</h2><ul><li>为了防止骰子掉入无尽的深渊，你需要实时监视每一个骰子的位置，当位置低于特定的点时，骰子可以返回玩家手中</li></ul><blockquote><p>Helper Functions</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func updateDiceNodes() &#123;       </span><br><span class="line">   // 1</span><br><span class="line">   for node in sceneView.scene.rootNode.childNodes &#123;</span><br><span class="line">     // 2</span><br><span class="line">     if node.name == &quot;dice&quot; &#123;</span><br><span class="line">       if  node.presentation.position.y &lt; -2 &#123;</span><br><span class="line">         // 3</span><br><span class="line">         node.removeFromParentNode()</span><br><span class="line">         diceCount += 1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>你遍历了场景中所有可用的结点</li><li>你只对名字为 “dice”，且低于地面两米的骰子感兴趣</li><li>一旦你发现了符合条件的骰子结点，你将会把它从场景中移除掉，然后 diceCountOnce 增加 1 ，本质上就是骰子重新回到了玩家手中</li></ol><blockquote><p>SceneKit Management</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func renderer(_ renderer: SCNSceneRenderer, updateAtTime time: TimeInterval) &#123;</span><br><span class="line">    DispatchQueue.main.async &#123;</span><br><span class="line">      //self.statusLabel.text = self.trackingStatus</span><br><span class="line">      self.updateStatus()</span><br><span class="line">      self.updateFocusNode()</span><br><span class="line">      self.updateDiceNodes()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="Add-plane-physics"><a href="#Add-plane-physics" class="headerlink" title="Add plane physics"></a>Add plane physics</h2><blockquote><p>Helper Functions</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func createARPlanePhysics(geometry: SCNGeometry) -&gt; SCNPhysicsBody &#123;</span><br><span class="line">    // 1</span><br><span class="line">    let physicsBody = SCNPhysicsBody(</span><br><span class="line">        type: .kinematic,</span><br><span class="line">        // 2</span><br><span class="line">        shape: SCNPhysicsShape(geometry: geometry,</span><br><span class="line">          options: nil))</span><br><span class="line">    // 3</span><br><span class="line">    physicsBody.restitution = 0.5</span><br><span class="line">    physicsBody.friction = 0.5</span><br><span class="line">    // 4</span><br><span class="line">    return physicsBody</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>创建了一个运动态，除了你可以移动它之外，其他都与静态非常类似</li><li>第二个参数是一个物理形状，SCNPhysicsShape() 非常聪明，如果你提供对象的几何信息，它将会自动地为 3D 物体创建一个合适的形状，还有一个为 nil 的附加选项，由于你都是使用简单的平面，物理形状都会非常简单</li><li>调整平面的弹性和粗糙程度</li><li>返回结果给调用者</li></ol><blockquote><p>createARPlaneNode(planeAnchor:color:)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">planeNode.physicsBody = createARPlanePhysics(geometry: planeGeometry)</span><br></pre></td></tr></table></figure><ul><li>当创建 AR 平面结点时，你同时也需要为平面结点创建物理形态，现在，当 AR 平面结点被创建时，它会附有一个物理形态</li></ul><blockquote><p>updateARPlaneNode(planeNode:planeAchor:)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">planeNode.physicsBody = nil</span><br><span class="line">planeNode.physicsBody = createARPlanePhysics(geometry: planeGeometry)</span><br></pre></td></tr></table></figure><ul><li>通过设置 nil 来达到摧毁之前的物理形态的目的，然后重新创建物理形态，现在，当平面得到更新时，物理形态也同时更新</li></ul><h2 id="Randomize-rotation"><a href="#Randomize-rotation" class="headerlink" title="Randomize rotation"></a>Randomize rotation</h2><blockquote><p>throwDiceNode(transform:offset:)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let rotation = SCNVector3(Double.random(min: 0, max: Double.pi),</span><br><span class="line">  Double.random(min: 0, max: Double.pi),</span><br><span class="line">  Double.random(min: 0, max: Double.pi))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diceNode.eulerAngles = rotation</span><br></pre></td></tr></table></figure><h2 id="Add-force"><a href="#Add-force" class="headerlink" title="Add force"></a>Add force</h2><ul><li><p>Force 能够在一个特定的点上被施加，可分为有推动力的和无推动力的，有推动力的只能作用于物理形态上，比如投掷出一个骰子。无推动力的会作用于模拟环境的每一步，SceneKit 会将所有的力共同作用于物体并且加速物理形态，比如火箭的推进器，那里的力是持续的</p></li><li><p>Transform 是一个 SCNMatrix4，也就是 4 x 4 的数学矩阵，当你看到 m41 时，这就是指四行一列的矩阵，矩阵中的每一行都关联了一个 transform 值</p></li></ul><blockquote><p>throwDiceNode(transform:offset:)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">let distance = simd_distance(focusNode.simdPosition,</span><br><span class="line">  simd_make_float3(transform.m41,</span><br><span class="line">    transform.m42,</span><br><span class="line">    transform.m43))</span><br><span class="line">// 2        </span><br><span class="line">let direction = SCNVector3(-(distance * 2.5) * transform.m31,</span><br><span class="line">  -(distance * 2.5) * (transform.m32 - Float.pi / 4),</span><br><span class="line">  -(distance * 2.5) * transform.m33)</span><br></pre></td></tr></table></figure><ol><li>你需要施加一个方向不定的的力给骰子，这个力需要去包括筛子到 focus node 的距离，这行代码计算出了他们两者的距离</li><li>你想要去向前投掷出骰子，创建一个向前方向的矢量，包含你刚刚创建的距离，以及骰子的旋转</li></ol><blockquote><p>throwDiceNode(transform:offset:)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">diceNode.physicsBody?.resetTransform()</span><br><span class="line">// 2</span><br><span class="line">diceNode.physicsBody?.applyForce(direction, asImpulse: true)</span><br></pre></td></tr></table></figure><ul><li>更新了骰子物理形态的位置去匹配它实际的位置</li><li>给筛子施加了一个力，将它掷入到特定的方向，并伴随一个小的推动</li></ul><h2 id="Add-a-shadow-casting-light"><a href="#Add-a-shadow-casting-light" class="headerlink" title="Add a shadow-casting light"></a>Add a shadow-casting light</h2><blockquote><p>Properties</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var lightNode: SCNNode!</span><br></pre></td></tr></table></figure><blockquote><p>loadModels()</p></blockquote><ul><li>从 diceScene 中加载方向光，然后将它添加到 AR 场景</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lightNode = diceScene.rootNode.childNode(withName: &quot;directional&quot;, recursively: false)!</span><br><span class="line">sceneView.scene.rootNode.addChildNode(lightNode)</span><br></pre></td></tr></table></figure><h2 id="Light-estimation"><a href="#Light-estimation" class="headerlink" title="Light estimation"></a>Light estimation</h2><blockquote><p>initARSession()</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.isLightEstimationEnabled = true</span><br></pre></td></tr></table></figure><ul><li><p>允许 ARKit 基于侦测到的环境光强度来管理光的强度</p></li><li><p>当玩家在明亮的环境中，光的强度就会很高，当玩家在黑暗的环境中，光的强度将会变低</p></li></ul><h2 id="Suspend-AR-plane-detection"><a href="#Suspend-AR-plane-detection" class="headerlink" title="Suspend AR plane detection"></a>Suspend AR plane detection</h2><blockquote><p>Helper Functions</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func suspendARPlaneDetection() &#123;</span><br><span class="line">  // 1</span><br><span class="line">  let config = sceneView.session.configuration as!</span><br><span class="line">    ARWorldTrackingConfiguration</span><br><span class="line">  // 2</span><br><span class="line">  config.planeDetection = []</span><br><span class="line">  // 3</span><br><span class="line">  sceneView.session.run(config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>从 session 中得到了目前的配置信息</li><li>通过设置空数组清除了 planeDetection 属性 </li><li>重新运行，现在 ARKit 知道侦测更多的平面时该如何不去耗能</li></ol><h2 id="Hide-visible-planes"><a href="#Hide-visible-planes" class="headerlink" title="Hide visible planes"></a>Hide visible planes</h2><ul><li>显示所有被侦测的平面是无意义的，最好的办法是把它们移除</li></ul><blockquote><p>Helper Functions</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func hideARPlaneNodes() &#123;</span><br><span class="line">    // 1</span><br><span class="line">    for anchor in</span><br><span class="line">      (self.sceneView.session.currentFrame?.anchors)! &#123;</span><br><span class="line">      // 2 </span><br><span class="line">      if let node = self.sceneView.node(for: anchor) &#123;</span><br><span class="line">        // 3</span><br><span class="line">        for child in node.childNodes &#123;</span><br><span class="line">          // 4</span><br><span class="line">          let material = child.geometry?.materials.first!</span><br><span class="line">          material?.colorBufferWriteMask = []</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在 SceneView 遍历出所有可获得的锚，这一步是通过访问当前的 frame 来实现</li><li>得到当前锚相关联的结点</li><li>一旦你得到了相关联的结点，隐藏它和它的子对象</li><li>你只干星期第一个可获得的 material，一旦你得到它，你就能够通过设置空数组来清除它的颜色，这就简单地清除了结点 material 的所有颜色信息，最终达到隐藏结点的目的</li></ol><h2 id="Block-swipe-gestures"><a href="#Block-swipe-gestures" class="headerlink" title="Block swipe gestures"></a>Block swipe gestures</h2><ul><li>游戏还未开始，玩家不允许去投掷骰子</li></ul><blockquote><p>swipeUpGestureHandler(_:)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">guard gameState == .swipeToPlay else &#123; return &#125;</span><br></pre></td></tr></table></figure><h2 id="Start-the-game"><a href="#Start-the-game" class="headerlink" title="Start the game"></a>Start the game</h2><blockquote><p>Helper Functions </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func startGame() &#123;</span><br><span class="line">  DispatchQueue.main.async &#123;</span><br><span class="line">    self.startButton.isHidden = true</span><br><span class="line">    self.suspendARPlaneDetection()</span><br><span class="line">    self.hideARPlaneNodes()</span><br><span class="line">    self.gameState = .pointToSurface</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>startButtonPressed(_:)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.startGame()</span><br></pre></td></tr></table></figure><h2 id="Reset-the-game"><a href="#Reset-the-game" class="headerlink" title="Reset the game"></a>Reset the game</h2><blockquote><p>Helper Functions</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func resetARSession() &#123;</span><br><span class="line">  // 1</span><br><span class="line">  let config = sceneView.session.configuration as!</span><br><span class="line">    ARWorldTrackingConfiguration</span><br><span class="line">  config.planeDetection = .horizontal</span><br><span class="line">  sceneView.session.run(config,</span><br><span class="line">    // 2</span><br><span class="line">    options: [.resetTracking, .removeExistingAnchors])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过调整存在的 AR 配置来重新启动水平平面侦测</li><li>重新运行配置时，你传入了附加选项<ul><li>.resetTracking 本质上将会重启 ARKit</li><li>.removeExistingAnchors 将会摧毁之前侦测到的所有锚以及所有侦测到的平面结点</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func resetGame() &#123;</span><br><span class="line">  DispatchQueue.main.async &#123;</span><br><span class="line">    self.startButton.isHidden = false</span><br><span class="line">    self.resetARSession()</span><br><span class="line">    self.gameState = .detectSurface</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>resetButtonPressed(_:)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.resetGame()</span><br></pre></td></tr></table></figure><blockquote><p>sessionInterruptionEnded()</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.resetGame()</span><br></pre></td></tr></table></figure><ul><li>当出现问题的时候，这一招会特别好用， 例如当用户切换到另一个 App 时，或者是玩游戏的时候接了一个电话，这些情况发生时，直接重置游戏</li></ul><h2 id="Add-interaction"><a href="#Add-interaction" class="headerlink" title="Add interaction"></a>Add interaction</h2><ul><li>Hit test：有专门的函数可以执行 hit test，你需要做的只是提供用户触摸屏幕时的位置，SceneKit 将会发射一束射线进入增强现实场景，被射线所命中的物体将会被认为是 “hit” </li></ul><blockquote><p>Actions</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">override func touchesBegan(_ touches: Set&lt;UITouch&gt;,</span><br><span class="line">  with event: UIEvent?) &#123;</span><br><span class="line">  DispatchQueue.main.async &#123;</span><br><span class="line">    // 1</span><br><span class="line">    if let touchLocation = touches.first?.location(</span><br><span class="line">      in: self.sceneView) &#123;</span><br><span class="line">      // 2</span><br><span class="line">      if let hit = self.sceneView.hitTest(touchLocation,</span><br><span class="line">        options: nil).first &#123;</span><br><span class="line">        // 3</span><br><span class="line">        if hit.node.name == &quot;dice&quot; &#123;</span><br><span class="line">          // 4</span><br><span class="line">          hit.node.removeFromParentNode()</span><br><span class="line">          self.diceCount += 1</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>获得用户触摸屏幕的位置</li><li>使用被触摸的点作为 hit test 的开始点</li><li>你只感兴趣玩家触摸的是否是骰子</li><li>如果玩家确实触摸的是一个骰子，把它从场景中移除掉，并且通过增加 diceCount 来达到返回到玩家的手中的目的</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Chapter-2-Creat-a-Basic-ARkit-Application&quot;&gt;&lt;a href=&quot;#Chapter-2-Creat-a-Basic-ARkit-Application&quot; class=&quot;headerlink&quot; title=&quot;Chapter 2:
      
    
    </summary>
    
    
  </entry>
  
</feed>
