<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 初级密码学 · Hexo</title><meta name="description" content="初级密码学 - null"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Hexo"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/youngzihao" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">初级密码学</h1><div class="post-info">Dec 26, 2017</div><div class="post-content"><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

<blockquote>
<p>本文整理自《图解密码技术：第3版》</p>
</blockquote>
<h2 id="一、概览"><a href="#一、概览" class="headerlink" title="一、概览"></a>一、概览</h2><ul>
<li><p>六大密码技术：</p>
<p>（1）对称密码（symmetric cryptography）：加密和解密时使用<strong>同一密钥</strong>的方式。</p>
<p>（2） 公匙密码（asymmetric cryptography）：加密和解密时使用<strong>不同密钥</strong>的方式，也称为非对称密码，现代计算机和互联网体系很大程度上依赖于公钥密码。</p>
<p>（3） 单向散列函数（one-way hash function）：为防止软件遭到篡改，软件发布者会在发布软件的      同时发布散列值，散列值就是用单向散列函数计算所得。可保证数据<strong>完整性</strong>，可以检测数据是否被<strong>篡改</strong>过。</p>
<p>（4）消息认证码（message authentication code）：不但能确认消息是否被<strong>篡改</strong>过，而且能够确认消息是否来自所期待的通信对象，也就是<strong>认证</strong>机制。</p>
<p>（5） 数字签名（digital signature）：不仅能确保<strong>完整性</strong>、提供<strong>认证</strong>而且能够<strong>防止否认</strong>的密码技术。</p>
<p>（6） 伪随机数生成器（Pseudo Random Number Generator，PRNG）：一种能够模拟产生随机数的算法，承担着<strong>密钥生成</strong>的职责。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fmsuk5s0euj30sg0lcn0g.jpg" alt="1"></p>
</li>
<li><p>隐写术：密码是让消息变得无法解读，而隐写术是能够隐藏消息本身，数字水印技术就采用了隐写术的方法。</p>
</li>
<li><p>密码与信息安全常识：</p>
<p>（1）不要使用保密的密码算法。</p>
<p>（2）使用低强度的密码比不进行任何加密更危险。</p>
<p>（3）任何密码总有一天会被破解。</p>
<p>（4）密码只是信息安全的一部分。</p>
</li>
</ul>
<h2 id="二、简单密码"><a href="#二、简单密码" class="headerlink" title="二、简单密码"></a>二、简单密码</h2><ul>
<li><p>凯撒密码（Caesar cipher）：通过将明文所使用的字母表按照一定的字数平移来进行加密，可被<strong>暴力破解</strong>（brute-force attack）。</p>
</li>
<li><p>简单替换密码（simple substitution cipher）：将明文中所使用的字母表替换成另外一套字母表的密码，很难通过暴力破解，但可以使用<strong>频率分析</strong>来破解。</p>
</li>
<li><p>Enigma（谜）：一种由键盘、齿轮、电池和灯泡组成的机器，可完成加密和解密两种操作，使用了<strong>密钥加密密钥</strong>（Key Encrypting Key，KEK），即用通信密码加密消息，用每日密码来加密通信密码，最终被 Alan Turing 破解。</p>
</li>
</ul>
<h2 id="三、对称密码"><a href="#三、对称密码" class="headerlink" title="三、对称密码"></a>三、对称密码</h2><ul>
<li><p>编码（encoding）：将现实世界中的东西映射为<strong>比特序列</strong>的操作。</p>
</li>
<li><p>异或（Exclusive OR，XOR）：如果 a、b 两个值不相同，则异或结果为 1 ，如果 a、b 两个值相同，异或结果为 0 。</p>
</li>
<li><p>一次性密码本（one-time pad）：又称<strong>维纳密码</strong>（Vernam cipher），原理是将明文与一串随机的比特序列进行 XOR 运算，在理论上是无法破译的（香农于 1949 年通过数学方法加以证明）就算通过暴力破解，也<strong>无法得知结果是否是正确的明文</strong>。</p>
</li>
<li><p>流密码（stream cipher）：一次性密码本孕育出了流密码，流密码使用的并不是真正的随机比特序列，而是伪随机数生成器产生的比特序列，只要使用高性能的伪随机数生成器就能构建出强度较高的密码系统。</p>
</li>
<li><p>DES（Data Encryption Standard）：是 1977 年美国联邦信息处理标准（FIPS）中所采用的一种对称密码。DES 以 64 比特的明文（比特序列）为一个单位来进行加密，这个 64 比特的单位称为<strong>分组</strong>，以分组为单位进行处理的密码算法称为<strong>分组密码</strong>（block cipher），DES 每次只能加密 64 比特的数据，如果加密的明文较长，就需要对 DES 加密进行迭代，而迭代的具体方式称为<strong>模式</strong>。</p>
<p>DES 的基本结构是由 Horst Feistel 设计的，因此也被称为 <strong>Feistel 网络</strong>（结构/密码），在 Feistel 网络中，加密的各个步骤称为<strong>轮</strong>，整个加密过程就是进行若干次轮的循环，DES 是一种 16 轮循环的 Feistel 网络。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fmsuk5g3jlj30sg0lcac8.jpg" alt="2"></p>
<p>在 Feistel 网络中，每一轮都需要使用一个不同的子密钥，它只是一个局部密钥，因此才被称为子密钥（subkey）。</p>
<p>轮函数的作用是根据“右侧”和子密钥生成对“左侧”进行加密的比特序列，是整个密码系统的核心。</p>
<p>Feistel 网络的特点：</p>
<p>（1）轮数可以任意增加。</p>
<p>（2）加密时无论使用任何函数作为轮函数都可以正确解密。</p>
<p>（3）加密和解密可以用完全相同的结构来实现。</p>
</li>
<li><p>三重DES（triple-DES）：是为了增加 DES 的强度，将 DES 重复三次所得到的一种密码算法，也称为 TDEA（Triple Data Encryption Algorithm），通常缩写为 3DES 。</p>
<p> <img src="https://ws4.sinaimg.cn/large/006tNc79gy1fmsuk56u5ej30sg0lc41h.jpg" alt="3"></p>
<p> 从图中我们可以发现，三重 DES 并不是进行三次 DES 加密（加密—加密—加密），而是加密-<strong>解密</strong>-加密的过程，在加密算法中加入解密操作目的是为了让三重 DES 能够兼容普通的 DES ，这个方法由 IBM 设计，当三重 DES 中的所有密钥都相同时，三重 DES 也就等于普通的 DES 了，也就是说三重 DES 具有向下兼容性。</p>
<p> 三重 DES 目前还被银行等机构使用，但其处理速度不高，除了特别重视向下兼容性的情况外，很少被用于新的用途。</p>
</li>
<li><p>AES（Advanced Encrying Standard）：是取代前任 DES 而成为新标准的一种对称算法，Rijindael于 2000 年被选为新一代的标准密码算法—— AES 。DES 使用 Feistel 网络作为基本结构，而Rijindael 使用了 <strong>SPN 结构</strong>。</p>
<p>  加密过程：逐字节替换（SubBytes）——平移行（ShiftRows）——混合列（MixColumns）——与轮密匙进行XOR（AddRoundKey）</p>
</li>
</ul>
<h2 id="四、分组密码的模式"><a href="#四、分组密码的模式" class="headerlink" title="四、分组密码的模式"></a>四、分组密码的模式</h2><ul>
<li><p>分组密码（block cipher）：每次只能处理特定长度数据的一类密码算法。</p>
</li>
<li><p>流密码（stream cipher）：是对数据进行连续处理的一类密码算法，一般以 1 比特、8 比特或 32 比特为单位进行加密和解密的。分组密码处理完一个分组就结束了，因此不需要通过内部状态来记录加密的进度，相对地，流密码是对一串数据流进行连续处理，因此需要<strong>保持内部状态</strong>。</p>
</li>
<li><p>模式：分组密码算法只能加密固定长度的分组，但是我们需要加密的明文长度可能会超过分组密码的分组长度，这时就需要对分组密码算法进行迭代，以便将一段很长的明文全部加密，而<strong>迭代的方法</strong>就称为分组密码的模式。</p>
</li>
<li><p>电子密码本模式（Electronic CodeBook，ECB）：<strong>在 ECB 模式中，将明文分组加密之后的结果直接成为密文分组</strong>，相同的明文分组会转换为相同的密文分组，我们可以将其理解为一个巨大的“明文分组——密文分组”的对应表，因此被称为<strong>电子密码本模式</strong>。</p>
<p>   <img src="https://ws2.sinaimg.cn/large/006tNc79gy1fmsuk4wk7gj30sg0lcaep.jpg" alt="4"></p>
<p>  攻击方式：<strong>无需破译密文就能操纵明文</strong>。</p>
</li>
<li><p>密文分组链接模式（Cipher Block Chaining，CBC）：在 CBC 模式中，首先<strong>将明文分组与前一个密文分组进行 XOR 运算，然后再进行加密</strong>。</p>
<p>  <img src="https://ws2.sinaimg.cn/large/006tNc79gy1fmsuk4hxotj30sg0lcjxi.jpg" alt="5"></p>
<p>  初始化向量（Initialization Vector，IV）：每次加密时都会产生一个不同的比特序列来作为初始化向量。</p>
<p>  特点：</p>
<p>  （1）在 CBC 模式加密过程中，我们无法单独对一个中间的明文分组进行加密，需要<strong>凑齐</strong>之前的明文分组。</p>
<p>  （2）在 CBC 模式解密过程中，若有一个密文分组<strong>损坏</strong>了，只要密文分组的长度没有发生改变，则解密时最多只有两个分组受到数据损坏的影响。</p>
<p>  （3）在 CBC 模式解密过程中，若密文文组有一些比特<strong>缺失</strong>了，此时即便缺失了 1 比特，也会导致密文分组的长度发生改变，此后的分组发生错位，缺失比特的位置之后的密文分组也就全部无法解密了。</p>
<p>  应用实例：确保互联网通信安全的通信协议之一的 SSL/TLS 就是使用 CBC 模式进行加密的。</p>
<p>  攻击方式：</p>
<p>  （1）填充式攻击（Padding Oracle Attack）：是一种利用分组密码中的填充部分来进行攻击的方法。在分组密码中，当明文长度不为分组长度的整数倍时，需要在最后一个分组中填充一些数据凑满一个分组长度，攻击者会反复发送一段密文，每次发送都对填充的数据进行少许的改变，由于接收者在无法正确解密时会返回一个错误消息，攻击者通过这一错误消息可以获得一部分与明文有关的消息。</p>
<p>  （2）对初始化向量进行攻击：初始化向量必须使用不可预测的随机数。然而在 SSL/TLS 的 TLS 1.0 版本协议中 IV 并没有使用不可预测的随机数，而是使用了上一次 CBC 模式加密时的最后一个分组。</p>
<p>  （3）假设主动攻击者目的是通过修改密文来操纵解密后的明文，攻击者如果能够对初始化向量中的任意比特进行反转，则解密后得到的明文分组中相应的比特也会被反转，因为第一个明文分组会和初始化向量进行 XOR 运算。</p>
<p>但是如果想要对密文分组也进行同样的攻击就非常困难了，假设主动攻击者将密文分组 1 中的某个比特进行了反转，则明文分组 2 中的相应比特也会被反转，然后这 1 比特的变化却会对解密后的明文分组 1 中的多个比特造成影响，也就是说，只让明文分组 1 中主动攻击者所期待的特定比特发生变化是很困难的。</p>
</li>
<li><p>密文反馈模式（Cipher FeedBack，CFB）：在 CFB 模式中，前一个密文分组会被送回密码算法的输入端。在 ECB 模式和 CBC 模式中，明文分组都是通过密码算法进行加密的，而在 CFB 模式中，明文分组并没有通过密码算法加密。</p>
<p>  <img src="https://ws4.sinaimg.cn/large/006tNc79gy1fmsuk44gxkj30sg0lcgr3.jpg" alt="6"></p>
<p>CFB 模式与流密码：</p>
<p>CFB 模式与之前的一次性密码本十分相似，一次性密码本是通过将“明文”与“随机比特序列”进行 XOR 运算来生成“密文”的。CFB 模式则是通过将“明文分组”与“密码算法的输出”进行 XOR 运算来生成“密文分组”的。CFB 模式中由密码算法所生成的比特序列称为<strong>密钥流</strong>，密码算法相当于生成密钥流的伪随机数生成器。</p>
<p> 在 CFB 模式中，明文数据可以被逐比特加密，因此可以将 CFB 模式看作是一种使用分组密码来实现流密码的方式</p>
<p> 攻击方式：<strong>重放攻击</strong></p>
</li>
<li><p>输出反馈模式（Output-Feedback，OFB）：在 OFB 模式中，密码算法的输出会反馈到密码算法的输入中，因此被称为输出反馈模式。OFB 模式并不是通过密码算法对明文直接进行加密的，而是通过将“明文分组”和“密码算法的输出”进行异或来产生“密文分组”的，这一点上 OFB 模式和 CFB 模式很像。</p>
<p>  <img src="https://ws3.sinaimg.cn/large/006tNc79gy1fmsuk3ueq5j30sg0lc7a5.jpg" alt="7"></p>
<p>  OFB 模式与 CFB 模式的区别：在于两者密码算法的输入，前者密码算法的输入是密码算法的前一个输出，后者密码算法的输入是前一个密文分组，两者名称也因此不同。</p>
</li>
<li><p>计数器模式（CounTeR，CTR）：<strong>是一种通过将逐次累加的计数器进行加密来生成密匙流的流密码</strong>。</p>
<p>  <img src="https://ws3.sinaimg.cn/large/006tNc79gy1fmsuk3igkfj30sg0lctes.jpg" alt="8"><br>  CTR 模式中，每个分组对应一个逐次累加的计数器，并通过对计数器进行加密来生成密匙流，最终的密文分组是通过将计数器加密得到的比特序列，与明文分组 XOR 所得到的。</p>
<p>  由于计数器的值每次都不同，因此每个分组中将计数器进行加密所得到的密钥流也是不同的，也就是说，这种方法就是用分组密码来模拟生成随机的比特序列。</p>
<p>  特点：</p>
<p>  （1）加密和解密使用了完全相同的结构，因此在程序上容易实现，这一特点与同为流密码的 OFB 模式是一样的。</p>
<p>  （2）CTR 模式可以以任意顺序对分组进行加密和解密，因此在加密和解密时需要用到的“计数器”的值可以由 nonce 和分组序号直接计算出来，这一性质是 OFB 不具备的。</p>
<p>  （3）能够以任意顺序处理分组，意味能够实现并行计算，在支持并行计算的系统中，CTR的速度是最快的。</p>
<p>  错误与机密性方面：</p>
<p>  CTR 模式具备和 OFB 模式差不多的性质，假设 CTR 密文分组中有 1 个比特被反转了，则解密之后明文分组中仅有与之对应的比特会被反转，这一错误不会放大。换言之，主动攻击者可以利用通过反转密文分组中的某些比特，来引起解密之后的明文中相应比特发生反转，这一弱点和 OFB 模式是相同的。</p>
<p>  不过 CTR 模式具备一个比 OFB 模式要好的性质，在 OFB 模式中，如果对密钥流的一个分组进行加密后其结果碰巧和加密前是一样的，那么这一分组之后的密钥流就会变成同一值得不断反复，在 CTR 模式中就不存在这种问题。</p>
</li>
</ul>
<h2 id="五、公钥密码"><a href="#五、公钥密码" class="headerlink" title="五、公钥密码"></a>五、公钥密码</h2><ul>
<li><p>解决<strong>密钥配送问题</strong>的四个方法</p>
<p> （1）通过<strong>事先共享密钥</strong>来解决</p>
<p> （2）通过<strong>密钥分配中心</strong>来解决</p>
<p> （3）通过 <strong>Diffie-Hellman 密钥交换</strong>来解决</p>
<p> （4）通过<strong>公钥密码</strong>解决</p>
</li>
<li><p>公钥密码（public-key cryptography）：也被称为非对称密码（asymmetric cryptography）在公钥密码中，密钥分为加密密钥（<strong>公钥</strong>，可以公开）和解密密钥（<strong>私钥</strong>，不能公开）两种，发送者用加密密钥对消息进行加密，接受者用解密密钥对密文进行解密。公钥和私钥是一一对应的，一对公钥和私钥统称为密钥对。</p>
<p>公钥密码无法解决的问题：</p>
<p>（1）我们需要判断所得到的公钥是否正确合法，也就是<strong>公钥认证</strong>问题。</p>
<p>（2）处理<strong>速度</strong>只有对称密码的几百分之一。</p>
</li>
<li><p>时钟运算：</p>
<p>（1）加法：时针的指针向右旋转相当于做加法，不过不是单纯的加法，而是“除法求余数（mod）”</p>
<p>（2）减法：实际上是加法的逆运算，可将减法转换为加法。</p>
<p>（3）乘法：相当于加法的多次重复。</p>
<p>（4） 除法：实际上是乘法的逆运算，例如：7 × ■ mod 12 = 1，在乘法中我们的思路是“在 mod 12    的世界里，7 乘以几等于 1 ”。换句话就是“在 mod 12 的世界里，1 ÷ 7 等于几”。</p>
<p>我们再来看下面这个算式：</p>
<p>● × ■ mod 12 = 1</p>
<p>当我们把 mod 12 遮住的时候，我们发现 ● 与 ■ <strong>互为倒数</strong>，当然我们需要加上“在以 12 为模的世界中”这个条件。在 0 到 11 的数字中，有哪些数存在与之相应的倒数呢，实际上，时钟运算中“某个数是否存在倒数”这个问题，与公钥算法 RSA 中“一个公钥是否存在相对应的私钥”这个问题是直接相关的。</p>
<p>某个数是否存在倒数，可以通过这个数和 12 的最大公约数是否为 1 这个条件来判断，和 12 的最大公约数为 1 的数（5、7、11），在数学上称为“和 12 互质的数”，可以理解为“相对于 12 的质数”。</p>
<p>（5）乘方：相当于乘法的多次重复。</p>
<p>（6）对数：时钟运算中的对数称为<strong>离散对数</strong>，例如：7 <sup>■</sup> mod 13 = 8 ，尝试下来我们知道 ■ 为 9 ，当数字很大的时候，求离散对数就非常困难，能够快速求出离散对数的算法现在还没被发现，Diffie-Hellman 密钥交换协议以及 ElGamel 公钥算法中就运用了离散对数。</p>
</li>
<li><p>RSA：是目前使用最为广泛的公钥密码算法，名字是由它的三位开发者的姓氏首字母组成的，可被用于公钥密码和数字签名。</p>
<p>  <img src="https://ws2.sinaimg.cn/large/006tNc79gy1fmsuk37xabj30sg0lcq4y.jpg" alt="9"></p>
<p>  加密过程：</p>
<blockquote>
<p>密文 = 明文<sup><em>E</em></sup> mod <em>N</em></p>
</blockquote>
<p>  其中 <em>E</em>（Encryption） 和 <em>N</em>（Number） 是 RSA 加密的密钥，<strong>因此<em>E</em> 和 <em>N</em> 的组合就是公钥</strong>。 </p>
<p>  解密过程：</p>
<blockquote>
<p>明文 = 密文<sup><em>D</em></sup> mod <em>N</em></p>
</blockquote>
<p>  这里所使用的 <em>N</em> 与加密时使用的是一致的，<strong>因此<em>D</em>（Decryptio） 和 <em>N</em> 的组合就是私钥</strong>。</p>
<p>  由于 <em>E</em> 和 <em>N</em> 是公钥，<em>D</em> 和 <em>N</em> 是私钥，因此求 <em>E</em>、<em>N</em>、<em>D</em> 这三个数就是<strong>生成密钥对</strong>，生成步骤如下：</p>
<blockquote>
<p>（1）求 <em>N</em> ：</p>
</blockquote>
<blockquote>
<p>首先准备两个很大的质数 <em>p</em> 和 <em>q</em> 。 过小容易被破解，要求出这样大的质数，需要通过伪随机数生成器生成一个 512 比特大小的数，判断是不是质数，如果不是，则重新生成。</p>
</blockquote>
<blockquote>
<p>准备好之后，将这两个数相乘，其结果就是 <em>N</em> ，可用以下公示表达。</p>
</blockquote>
<blockquote>
<p><em>N</em> = <em>p</em> × <em>q</em></p>
</blockquote>
<blockquote>
<p>（2）求 <em>L</em> （只在生成密钥对的过程中出现）：</p>
</blockquote>
<blockquote>
<p><em>L</em> 是 <em>p</em> -1和 <em>q</em> -1的最小公倍数（least common multple，lcm），如果用 lcm(<em>X</em>,<em>Y</em> ) 来表示“ <em>X</em> 与 <em>Y</em> 的最小公倍数”，则 <em>L</em> 可以写成以下形式。</p>
</blockquote>
<blockquote>
<p><em>L</em> = lcm(<em>p</em> -1, <em>q</em> -1)     </p>
</blockquote>
<blockquote>
<p>（3）求 <em>E</em> ：</p>
</blockquote>
<blockquote>
<p><em>E</em> 是一个比 1 大、比 <em>L</em> 小的数，此外 <em>E</em> 和 <em>L</em> 的最大公约数（greatest common divisor，gcd）必须为1。如果用 gcd(<em>X</em>,<em>Y</em> ) 来表示 <em>X</em> 和 <em>Y</em> 的最大公约数，则 <em>E</em> 和 <em>L</em> 存在以下关系。</p>
</blockquote>
<blockquote>
<p>1 &lt; <em>E</em> &lt; <em>L</em></p>
</blockquote>
<blockquote>
<p>gcd(<em>E</em>, <em>L</em>) = 1</p>
</blockquote>
<blockquote>
<p>使用伪随机数生成器，在 1 &lt; <em>E</em> &lt; <em>L</em>范围内生成 <em>E</em> 的候选数，然后再判断是否满足 gcd(<em>E</em>, <em>L</em>) = 1 这个条件。</p>
</blockquote>
<blockquote>
<p>（4）求 <em>D</em> :</p>
</blockquote>
<blockquote>
<p>数 <em>D</em> 是由数 <em>E</em> 计算得到的。<em>D</em> 、 <em>E</em> 、 <em>L</em> 之间必须具备下列关系。</p>
</blockquote>
<blockquote>
<p>1 &lt; <em>D</em> &lt; <em>L</em></p>
</blockquote>
<blockquote>
<p><em>E</em> × <em>D</em> mod <em>L</em> = 1</p>
</blockquote>
<blockquote>
<p>只要满足以上条件，则通过 <em>E</em> 和 <em>N</em> 进行加密的密文，就可以通过 <em>D</em> 和 <em>N</em> 进行解密。</p>
</blockquote>
<p>  对 RSA 的攻击：</p>
<p>  （1）通过密文求得明文：RSA 的加密过程如下，由于密码破译者知道密文、<em>E</em> 、<em>N</em> ，如果没有 mod <em>N</em> 的话就会变成看作是一个求对数的问题，但是加上 mod <em>N</em> 的话，就会变成一个求离散对数的问题，目前还没发现求离散对数的高效算法。</p>
<blockquote>
<p>密文 = 明文<sup><em>E</em></sup> mod <em>N</em></p>
</blockquote>
<blockquote>
<p>密文 = 明文<sup><em>E</em></sup> <del>mod <em>N</em></del></p>
</blockquote>
<p>  （2）通过暴力破解：只要能知道 <em>D</em> 就能对密文进行破解，因此我们可以逐一尝试有可能作为 <em>D</em> 的数字来破译 RSA ，也就是暴力破解法。但暴力破解的难度会随着 <em>D</em> 长度的增加而变大，当 <em>D</em> 足够长的时候就不可能在现实的时间内通过暴力破解找出 <em>D</em> 。</p>
<p>   现在，RSA 中使用的 <em>p</em> 和 <em>q</em> 的长度都是 1024 比特以上，<em>N</em> 的长度为 2048 比特以上，由于 <em>E</em> 和 <em>D</em> 的长度可以和 <em>N</em> 差不多，因此要找出 <em>D</em> 就需要进行 2048 比特以上的暴力破解，这样的长度下暴力破解是很困难的。</p>
<p>   （3）通过 <em>E</em> 和 <em>N</em> 求出 <em>D</em>：密码破译者不知道 <em>D</em> ，但是却知道公钥中的 <em>E</em> 和 <em>N</em> ，回忆一下生成密钥对的方法：</p>
<blockquote>
<p><em>E</em> × <em>D</em> mod <em>L</em> = 1</p>
</blockquote>
<p>   出现的数字是<em>L</em> ， 而 <em>L</em> 是 = lcm(<em>p</em> -1, <em>q</em> -1)，可以看出由 <em>E</em> 计算 <em>D</em> 需要使用 <em>p</em> 和 <em>q</em> ，因此<strong>质数 <em>p</em> 和 <em>q</em> 不能被密码破译者知道</strong>，把 <em>p</em> 和 <em>q</em> 交给密码破译者与把私钥交给密码破译者是等价的。</p>
<p>   <em>p</em> 和 <em>q</em> 不能被密码破译者知道，但是 <em>N</em> = <em>p</em> × <em>q</em> ，并且 <em>N</em> 是公开的，因此由 <em>N</em> 求 <em>p</em> 和 <em>q</em> 只能通过将 <em>N</em> 进行<strong>质因数分解</strong>来完成，<strong>一旦发现了对大整数进行质因数分解的高效算法，RSA 就能够被破解</strong>，然而现在还未发现此类高效算法。</p>
<p>   即使不进行质因数分解，密码破译者还是有可能知道 <em>p</em> 和 <em>q</em> 。由于 <em>p</em> 和 <em>q</em> 是通过伪随机数生成器产生的，一旦伪随机数生成器的算法很差，密码破译者就很有可能推测出来。</p>
<p>   （4）中间人攻击（man-in-the-middle-attack）：这种方法虽然不能破译 RSA ，但却是一种针对机密性的有效攻击，所谓中间人攻击，就是主动攻击者混入发送者和接受者的中间，对发送者伪装成接受者，对接受者伪装成发送者的攻击方式。要防御中间人攻击我们需要一种手段确认所收到的公钥是否是真正的发送者发来的，也就是公钥的证书。</p>
<p>   （5）选择密文攻击（Chosen Ciphertext Attack）：我们假设攻击者可以使用这样一种服务，即“发送任意数据，服务器都会将其当做密文来解密并返回解密的结果”，这种服务被称为<strong>解密提示</strong>（Decryption Oracle）。攻击者可以生成不同的数据，并让解密提示来尝试解密，从而获得生成密文时使用的密钥以及和明文有关的信息，反过来说，如果一种密码算法能够抵御选择密文攻击，则我们就可以认为这种算法的强度很高。</p>
<p>   只要我们在解密时能够判断“密文是否是由知道明文的人通过合法的方式产生的”就可以了，也就是认证。RSA-OAEP（Optimal Asymmetric Encryption Padding，最优非对称加密填充）正是基于上述思路设计的一种 RSA 改良算法。</p>
<p>   RSA-OAEP在加密时会在明文前面填充一些认证信息，包括明文的散列值以及一定数量的 0 ，然后再对填充后的明文进行 RSA 加密。在 RSA-OAEP 解密过程中，如果在 RSA 解密后的数据的开头没有找到正确的认证信息，则可以判定“这段密文不是由知道明文的人生成的”，并返回错误提示，因此能够抵御选择密文攻击。在实际运用中，还会通过随机数使得每次生成的密文呈现不同的排列方式，从而提高安全性。</p>
</li>
<li><p>其他公钥密码算法：</p>
<p>（1）ElGamal 方式：RSA 利用了质因数分解的困难度，而 ElGamal 则利用了 mod <em>N</em> 下求离散对数的困难度。</p>
<p>（2）Rabin 方式：利用了 mod <em>N</em> 下求平方根的困难度。</p>
<p>（3）椭圆曲线密码（Elliptic Curve Cryptography，ECC）：利用了在椭圆曲线上乘法运算的逆运算非常难这一特点。</p>
</li>
</ul>
<h2 id="六、混合密码"><a href="#六、混合密码" class="headerlink" title="六、混合密码"></a>六、混合密码</h2><ul>
<li><p>公钥密码的两大缺陷：</p>
<p>（1）处理速度远低于对称密码（解决方法：混合密码）</p>
<p>（2）难以抵御中间人攻击（解决方法：认证）</p>
</li>
<li><p>混合密码系统（hybrid cryptosystem）：用快速的对称密码来加密消息，用公钥密码加密对称密码的密钥。混合密码系统解决了公钥密码速度慢的问题、并通过公钥密码解决了对称密码的密钥配送问题。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fmsuk2xlotj30sg0lcwie.jpg" alt="10"></p>
</li>
<li><p>应用实例：著名的密码软件 PGP 、以及网络上的密码通信所使用的 SSL/TLS 都运用了混合密码技术。</p>
</li>
</ul>
<h2 id="七、单向散列函数"><a href="#七、单向散列函数" class="headerlink" title="七、单向散列函数"></a>七、单向散列函数</h2><ul>
<li><p>单向散列函数（one-way hash function）：有一个输入和输出，输入被称为<strong>消息</strong>，输出被称为<strong>散列值</strong>（hash value），单向散列函数可以根据消息的内容计算出散列值，用来检查消息的<strong>完整性</strong>。</p>
</li>
<li><p>单向散列函数的性质：</p>
<p>（1）根据任意长度的消息计算出固定长度的散列值。</p>
<p>（2）快速计算散列值。</p>
<p>（3）消息不同，散列值不同。 </p>
<p>（4）单向性，无法通过散列值反算出消息的性质。</p>
</li>
<li><p>碰撞（collision）：两个不同的消息产生同一个散列值的情况称为“碰撞”。</p>
</li>
<li><p>抗碰撞性（collision resistance）：难以发现发现碰撞的性质。</p>
</li>
<li><p>弱抗碰撞性：找到和该条消息具有相同散列值的另外一条消息是非常困难的性质。</p>
</li>
<li><p>强抗碰撞性：找到散列值相同的两条不同的消息是非常困难的性质。密码技术中所使用的单向散列函数，不仅要具备弱抗碰撞性，还必须具备强抗碰撞性。</p>
</li>
<li><p>术语：<strong>单向散列函数</strong>也称<strong>消息摘要函数</strong>（message digest function）、<strong>哈希函数</strong>、<strong>杂凑函数</strong>。<strong>消息</strong>也被称为<strong>原像</strong>（pre-image），<strong>散列值</strong>也被称为<strong>消息摘要</strong>、<strong>指纹</strong>（fingerprint），<strong>完整性</strong>也被称为<strong>一致性</strong>。</p>
</li>
<li><p>应用实例：</p>
<p>（1）检测软件是否被篡改</p>
<p>（2）用于基于口令的加密（Password Based Encryption，PBE）PBE的原理是将口令和盐（salt，通过伪随机生成器产生的随机值）混合后计算其散列值，然后将这个散列值作为加密的密钥，通过这样的方法能够有效防御针对口令的字典攻击。</p>
<p>（3）构造消息认证码</p>
<p>（4）构造数字签名</p>
<p>（5）构造伪随机数生成器</p>
<p>（6）构造一次性口令（one-time password），一次性口令被用于服务器对客户端的合法性认证，使用单向散列函数可以保证口令只在通信链路上传送一次，即使被窃听了口令，也无法使用。</p>
</li>
</ul>
<ul>
<li><p>传统单向散列函数：</p>
<p> （1）MD4、MD5：两者分别是 Rivest 于 1990、1991 年设计的单向散列函数，能够产生 128 比特的散列值，MD是消息摘要（Message Digest）的缩写，现均已被攻破。</p>
<p> （2）SHA-1：SHA-1是由NIST（National Institute of Standards and Technology，美国国家标准技术研究所）设计的一种能够产生 160 比特的散列值的单向散列函数，已被攻破。</p>
<p> （3）SHA-256、SHA-384、SHA-512：由NIST设计的单向散列函数，统称为 SHA-2 ，抗碰撞性尚未攻破。</p>
<p> （4）RIPEMD-160：是于 1996 年设计的一种能够产生 160 比特散列值的单向散列函数，RIPEMD-160 是欧盟 RIPE 项目所设计的 RIPEMD 单向散列函数的修订版，这一系列的函数还包括RIPEMD-128、RIPEMD-25 、RIPEMD-320 等，RIPEMD 的强抗碰撞性已被攻破，但RIPEMD-160尚未攻破，比特币中使用的就是 RIPEMD-160 。</p>
</li>
<li><p>SHA-3（Secure Hash Algorithm-3）：在 2005 年 SHA-1 被攻破的背景下，NIST 开始着手制定下一代单向散列函数 SHA-3，最终于 2012 年正式确定将 Keccak 算法作为 SHA-3 标准。</p>
<p>Keccak 可以生成任意长度的散列值，但为了配合 SHA-2 的散列长度，SHA-3 标准中共规定了 SHA3-224、SHA3-256、SHA3-384、SHA3-512 这 4 种版本。输入数据方面 SHA-3 无长度限制。</p>
<p>（1）海绵结构：Keccak 采用了与 SHA-1 、SHA-2 完全不同的<strong>海绵结构</strong>（sponge construction），在海绵结构中，输入的数据在进行填充之后，要经过<strong>吸收阶段</strong>（absorbing phase）和<strong>挤出阶段</strong>（squeezing phase），最终生成输出的散列值。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fmsuk2l3d6j30sg0lc42l.jpg" alt="11"></p>
<p>函数 <em>f</em> 的作用是将输入的数据进行复杂的搅拌操作并输出结果（输入和输出的长度均为 <em>b</em> = <em>r</em> + <em>c</em> 个比特），其操作对象是长度为 <em>b</em> = <em>r</em> + <em>c</em> 个比特的内部状态，内部状态的初始值为 0 ，也就是说，通过反复将输入分组的内容搅拌进来，整个消息就会被一点一点地吸收到海绵的内部结构中，每次吸收的输入分组长度为 <em>r</em> 个比特，因此 <em>r</em> 被称为<strong>比特率</strong>（bit rate）</p>
<p>函数 <em>f</em> 的输入长度并不是 <em>r</em> 个比特，而是 <em>r</em> + <em>c</em> 个比特，这意味着内部状态中有 <em>c</em> 个比特是不受输入分组内容的直接影响的（但会受到函数 <em>f</em> 的简介影响），这里的 <em>c</em> 被称为<strong>容量</strong>（capacity）。</p>
<p>在挤出阶段中，内部状态 <em>r</em> + <em>c</em> 个比特的容量（ <em>c</em> 个比特）部分是不会直接进入输出分组的，这部分数据只会通过函数 <em>f</em> 间接影响输出的内容，因此容量 <em>c</em> 的意义在于防止将输入消息中的一些特征泄漏出去。</p>
<p>（2）双工结构：作为海绵结构的变形，Keccak 中还提出了一种双工结构。在海绵结构中，只要将输入的消息全部吸收完毕后之后才能输出，但在双工结构中，输入和输出是以相同的速率进行的。</p>
<p>（3）对 Keccak 的攻击：Keccak 之前的单向散列函数都是通过循环执行压缩函数的方式来生成散列值的，称为 <strong>MD 结构</strong>（Merkle-Damagard construction）。MD4、MD5、RIPEMD、RIPEMD-160、SHA-1、SHA-2 等几乎所有的传统的单向散列函数算法都是基于 MD 结构的。而 Keccak 则采用了和 MD 结构完全不同的海绵结构，因此目前为止还未出现能对 Keccak 算法形成威胁的攻击方法。</p>
</li>
<li><p>对单向散列函数的攻击：</p>
<p>（1）暴力破解：利用文件的<strong>冗余性</strong>生成具有相同散列值的另一个文件，所谓冗余性就是指不改变文档意思的前提下能够对文件的内容进行修改的程度。现在我们需要寻找的是一条具备特定散列值的消息。这相当于<strong>试图破解单向散列函数的“弱抗碰撞性”的攻击</strong>。找出具有指定散列值的消息的攻击分为两种，即“原像攻击“和”第二原像攻击”。<strong>原像攻击</strong>（Pre-Image Attack）是指给定一个散列值，找出具有该散列值的任意消息。<strong>第二原像攻击</strong>（Secend Pre-Image Attack）是指定一条消息 1 ，找出另外一条消息 2 ，消息 2 的散列值和消息 1 相同。</p>
<p>（2）生日攻击：要找到散列值相同的两条消息，散列值可以是任意的，这样的攻击被称为<strong>生日攻击</strong>或<strong>冲突攻击</strong>（collision attack）”，这是一种<strong>试图破解单向散列函数的“强碰撞性”的攻击</strong>。</p>
</li>
<li><p>单向散列函数无法解决的问题：<strong>能够辨认出篡改，并无法辨认出伪装</strong>，因此我们需要认证。</p>
</li>
</ul>
<h2 id="八、消息认证码"><a href="#八、消息认证码" class="headerlink" title="八、消息认证码"></a>八、消息认证码</h2><ul>
<li><p>消息认证码（Message Authentication Code，MAC）：是一种确认完整性并认证的技术。</p>
<p>消息认证码的输入包括任意长度的消息和一个发送者与接收者之间的共享的密钥，它可以输出固定长度的数据，这个数据被称为 <strong>MAC 值</strong>。</p>
<p>根据任意长度的消息输出固定长度的数据，这一点和单向散列函数很像，因此可以理解<strong>消息认证码是一种与密钥相关的单向散列函数</strong>。</p>
</li>
<li><p>应用实例：</p>
<p>（1）SWIFT（Society for Worldwide Interbank Financial Telecommunication，环球银行金融电信协会），1973年成立的国际组织，目的是为国际银行间的交易保驾护航，银行与银行之间就是通过SWIFT 来传递消息，SWIFT 中使用了消息认证码。</p>
<p>（2）IPsec：是对互联网基本协议——IP 协议（Internet Protocol）增加安全的一种方式，在 IPsec中，对通信内容的认证和完整性校验都是采用消息认证码来完成的。</p>
<p>（3）SSL / TLS：对通信内容的认证和完整性校验也使用了消息认证码。</p>
</li>
<li><p>实现方法：</p>
<p>（1）使用<strong>单向散列函数</strong>实现：使用 SHA-2 之类的单向散列函数就可以实现消息认证码，其中一种实现方法称为 HMAC 。</p>
<p>（2）使用<strong>分组密码</strong>实现：使用 AES 之类的分组密码也可以实现消息认证码，将分组密码的密钥作为消息认证码的共享密钥来使用，并用 CBC 模式将消息全部加密，此外初始化向量（IV）是固定的。因为 CBC 模式的最后一个密文分组会受到整个信息以及密钥的双重影响，因此我们可以将它作为消息认证码，将除最后一个分组以外的密文部分全部丢弃。例如：AES-CMAC 就是一种基于 AES 实现的消息认证码。</p>
</li>
<li><p>HMAC：是一种使用单向散列函数来构造消息认证码的方法（RFC2104），其中 HMAC 的 H 就是 Hash 的意思。</p>
<p>  <img src="https://ws3.sinaimg.cn/large/006tNc79gy1fmsuk2b6qfj30sg0lcdi4.jpg" alt="12"></p>
<p>HMAC 中所使用的单向散列函数并不仅限于一种，任何高强度的单向散列函数都可以被用于 HMAC，使用 SHA1、SHA-224、SHA-256、SHA-384、SHA-512 所构造的 HMAC ，分别被称为HMAC-SHA1、HMAC-SHA-224、HMAC-SHA-256、HMAC-SHA-384、HMAC-SHA-512 。</p>
<p>实现原理：</p>
<p>（1）密钥填充：如果密钥比单向散列函数的分组长度要短，就需要在末尾填充 0 ，直到长度达到单向散列函数的分组长度为止。如果密钥比分组长度要长，则要单向散列函数求出密钥的散列值，然后将这个散列值用作 HMAC 的密钥。</p>
<p>（2）将填充后的密钥与被称为 <strong>ipad</strong> 的比特序列进行 XOR 运算：ipad 是将 00110110 这一比特序列不断循环往复直到达到分组长度所形成的比特序列，其中 ipad 的 i 代表 inner（内部）的意思。</p>
<p>XOR 运算所得到的值，就是一个和单向散列函数的分组长度相同，且和<strong>密钥相关的比特序列</strong>，称为 ipadkey 。</p>
<p>（3）与消息组合：也就是将比特序列（ipadkey）依附在消息的开头。</p>
<p>（4）输入单向散列函数，计算散列值。</p>
<p>（5）将填充后的密钥与被称为 <strong>opad</strong> 的比特序列进行 XOR 运算：opad 是将 01011100 这一比特序列不断循环往复直到达到分组长度所形成的比特序列，其中 opad 的 o 代表 outer（内部）的意思。</p>
<p>XOR 运算所得到的值，就是一个和单向散列函数的分组长度相同，且和密钥相关的比特序列，称为 opadkey 。</p>
<p>（6）将散列值拼在 opadkey 后面。</p>
<p>（7）输入单向散列函数，计算散列值，这就是最终的 MAC 值，一个和输入的消息和密钥都相关的长度固定的比特序列。</p>
</li>
<li><p>认证加密：2000以后，关于认证加密（Authenticated Encryption，AE，Authenticated Encryption with Associated Data，AD）的研究逐渐展开，认证加密是一种将对称密码和消息认证码相结合，同时满足机密性、完整性和认证三大功能的机制。</p>
<p>有一种认证加密方式叫作 Encrypt-then-MAC ，这种方式是先用对称密码将明文加密，然后计算密文的MAC值，另外还有 Encypt-and-MAC（将明文用对称密码加密，并对明文计算 MAC 值）和 MAC-then-Encrypt（先计算明文的 MAC 值，然后将明文和 MAC 值同时用对称密码加密）。</p>
<p>GCM（Galois/Counter Mode）是一种认证加密方式，GCM 中使用 AES 等 128 比特分组密码的 CTR 模式，并使用了一个反复进行加法和乘法运算的散列函数来计算 MAC 值，由于 CTR 模式本质是对递增的计数器值进行加密，因此可通过对若凡分组进行并行处理来提高速度，并且 CTR 模式加密与 MAC 值得计算使用的是相同的密钥，因此密钥管理也十分方便。</p>
</li>
<li><p>对消息认证码的攻击：</p>
<p>（1）重放攻击：通过事先保存的正确的 MAC 值不断重放来发动攻击。（可以使用序号、时间戳、nonce 来防御重放攻击）</p>
<p>（2）密钥推测攻击：和单向散列函数一样，对消息认证码也可以进行<strong>暴力破解</strong>和<strong>生日攻击</strong>，对于消息认证码来说，应该保证<strong>不能根据 MAC 值推测出通信双方所使用的密钥</strong>。此外生成消息认证码所使用的密钥，必须使用高强度的伪随机数生成器。</p>
</li>
<li><p>消息认证码无法解决的问题：</p>
<p>（1）无法对第三方证明</p>
<p>（2）无法防止否认</p>
</li>
</ul>
<h2 id="九、数字签名"><a href="#九、数字签名" class="headerlink" title="九、数字签名"></a>九、数字签名</h2><ul>
<li><p>数字签名（digital signature）：在数字签名中出现了两种行为，<strong>生成签名</strong>的行为和<strong>验证签名</strong>的行为。其中使用签名密钥来生成签名，使用验证密钥来验证签名。  数字签名对这两种密钥做了区分，使用验证密钥无法生成签名，此外，<strong>签名密钥只能由签名的人持有，而验证密钥则是任何需要验证签名的人都可以持有</strong>。 </p>
<p>实际上，数字签名就是通过将公钥密钥反过来实现的。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">私钥</th>
<th style="text-align:center">公钥</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">公钥密码</td>
<td style="text-align:center">接受者解密时使用</td>
<td style="text-align:center">发送者加密时使用</td>
</tr>
<tr>
<td style="text-align:center">数字签名</td>
<td style="text-align:center">签名者生成签名时使用</td>
<td style="text-align:center">验证者验证签名时使用</td>
</tr>
<tr>
<td style="text-align:center">谁持有密钥？</td>
<td style="text-align:center">个人持有</td>
<td style="text-align:center">只要需要任何人可以持有</td>
</tr>
</tbody>
</table>
<ul>
<li><p>实现方法：</p>
<p>（1）直接对消息签名的方法（实际上并不会使用）</p>
<p>（2）对消息的散列值签名的方法（实际上会使用）</p>
<p>   <img src="https://ws4.sinaimg.cn/large/006tNc79gy1fmsuk1zccnj30sg0lcq5j.jpg" alt="13"></p>
</li>
<li><p>对数字签名的疑问：</p>
<p>（1）密文为什么能作为签名使用？</p>
<p>数字签名是利用了“没有私钥的人事实上无法生成使用该私钥所生成的密文”这一性质来实现的，这里所生成的密文并非被用于确保机密性，而是被用于代表一种只有持有该密钥的人才能生成的信息。这样的信息被称为认证符号（authenticator），消息认证码也是认证符号的一种，数字签名也是一样。</p>
<p>（2）数字签名能保证机密性吗？</p>
<p>数字签名的作用本来就不是确保机密性。</p>
<p>（3）数字签名被复制之后，还可以用作签名吗？</p>
<p>签名可以被复制，并不意味着签名会失去意义，因为签名所表达的意义是特定的签名者对特定的消息进行了签名，即便签名被复制，也并不会改变签名者和消息的内容。并且，签名是不是原件不重要，重要的是特定的签名者与特定的消息绑定在了一起这一事实。</p>
<p>（4）消息会不会被任意修改？</p>
<p>数字签名要实现的并不是防止修改，而是识别修改。</p>
<p>（5）能不能同时修改消息和签名，使得验证签名成功？</p>
<p>只要消息被修改 1 比特，重新计算散列值就会发生很大的变化，要拼凑出合法的签名，必须在不知道私钥的前提下对新产生的散列值进行加密，事实上这是无法做到的，因为不知道私钥就无法生成用该私钥才能生成的密文。</p>
<p>（6）签名能不能被重复使用？</p>
<p>将签名部分提取出来并附加到别的消息后面，验证签名会失败。在数字签名中，签名与消息具有对应关系，因此事实上无法做到将签名提取出来重复使用。</p>
<p>（7）删除签名也无法作废合同吗？</p>
<p>带有数字签名的借据即便删除掉也无法作废，因为不知道其他地方是否留有副本，要作废带有数字签名的借据，可以重新创建一份相当于收据的文书，并让对方在这份文书上加上数字签名。</p>
<p>也可以在消息中声明该消息的有效期并加上数字签名。</p>
<p>（8）数字签名如何防止否认？</p>
<p>在数字签名中，能够生成签名的私钥是只有发送者才持有的，因此只有发送者才能够生成签名，无法进行否认，但严格来说，也存在私钥被窃取的情况。</p>
<p>（9）数字签名能否取代真实的签名与盖章？</p>
<p>美国于 2001 年颁布了 E-SIGN 法案，日本也于 2001 年颁布了电子签名及其认证业务的相关法律，我国于 2005 年颁布了《中华人民共和国电子签名法》，这些法律为将电子手段实现的签名与手写的签名和盖章同等处理提供了法律基础。数字签名在未来将发挥重要的作用，但是单纯地认为数字签名比普通的盖章或手写签名更可信是很危险的，一种新技术只有被广泛地认知，并对各种问题制定相应的解决方法之后，才能被社会真正地接受。</p>
</li>
<li><p>应用实例：</p>
<p>（1）安全信息公告: 信息发布的目的是尽量让更多的人知道，因此我们没有必要对信息进行加密，但是必须排除有人恶意伪装成该组织来发布假消息的风险，因此我们不加密消息，而只是对消息加上数字签名，这种对明文消息所施加的签名，一般称为明文签名（clearsign）</p>
<p>（2）软件下载：智能手机上广泛使用的 Android 系统是无法安装没有数字签名的应用软件的，在签署数字签名时，为了识别应用开发者的身份等信息，需要使用证书，这个证书只被用于识别应用开发者的身份等信息，并不是经过认证机构（Certificate Authority）签名的。不过数字签名只是能够检测软件是否被篡改过，无法保证软件本身不做出恶意行为。</p>
<p>（3）公钥证书：在验证数字签名时我们需要合法的公钥，那么怎么才知道我们的公钥是否合法呢，我们可以将公钥当做消息，对他加上数字签名，像这样对公钥施加数字签名所得到的就是公钥证书。</p>
<p>（4）SSL/TLS：在认证服务器身份是否合法时会使用服务器证书，它就是加上了数字签名的服务器公钥，相对地，服务器为了客户端进行认证也会使用客户端证书。</p>
</li>
</ul>
<ul>
<li><p>使用 RSA 实现数字签名：</p>
<p>用 RSA 生成签名</p>
<blockquote>
<p>签名 = 消息<sup><em>D</em></sup> mod <em>N</em></p>
</blockquote>
<p>其中 <em>D</em> 和 <em>N</em> 就是签名者的私钥，生成之后，将消息和签名发送给接受者。</p>
<p>用 RSA 验证签名</p>
<blockquote>
<p>由签名求得的消息 = 签名<sup><em>E</em></sup> mod <em>N</em></p>
</blockquote>
<p>其中 <em>E</em> 和 <em>N</em> 就是签名者的公钥，将“由签名求得的消息”与发送者直接发送而来的“消息”进行比对，两者一致则签名验证成功。</p>
</li>
<li><p>对数字签名的攻击：</p>
<p>（1）中间人攻击：对发送者伪装成接受者，对接受者伪装成发送者。</p>
<p>（2）对单向散列函数的攻击：数字签名中所使用的单向散列函数必须具有抗碰撞性，否则攻击者就可以生成另外一条不同的消息，使其与签名所绑定的消息具有相同的散列值。</p>
<p>（3）利用数字签名攻击公钥密码：</p>
<p>在 RSA 中，生成签名的公式是：</p>
<blockquote>
<p>签名 = 消息<sup><em>D</em></sup> mod <em>N</em></p>
</blockquote>
<p>这个公式和公钥密码中解密的操作是一样的，也就是说可以将“请对消息签名”这一请求理解成“请解密消息”。利用这一点攻击者可以发动一种巧妙的攻击，即利用数字签名来破译密文。</p>
<p>对于这样的攻击所采取的措施：首先不要直接对消息进行签名，对散列值进行签名比较安全。其次，公钥密码和数字签名最好分别使用不同的密钥对。最重要的是<strong>绝对不要对意思不清楚的消息进行签名</strong>。</p>
<p>（4）潜在伪造：如果攻击者能够生成合法的数字签名（即攻击者生成的签名能够正常通过校验），我们也应该将其当成是对这种签名算法的一种潜在威胁，这种情况被称为对数字签名的潜在伪造。</p>
<p>在用 RSA 来解密消息的数字签名算法中，潜在伪造是可能的，因为我们只要把随机比特序列 <em>S</em> 用 RSA 的公钥加密生成密文 <em>M</em> ，那么 <em>S</em> 就是 <em>M</em> 的合法数字签名，由于攻击者是可以获取公钥的，因此对数字签名进行潜在伪造也就可以实现。</p>
<p>为了应对潜在伪造，人们在改良 RSA 的基础上开发了一种签名算法，叫做 RSA-PSS（Probabilistic Signature Scheme）, RSA-PSS并不是对消息本身进行签名，而是对其散列值进行签名，另外为了提高安全性，在计算散列值的时候还要对消息加盐（salt）。</p>
<p>（5）其他攻击：针对公钥密码的攻击方法大部分都能够被用于攻击数字签名，例如暴力破解找出私钥，或者尝试对 RSA 的 N 进行质因数分解等。</p>
</li>
<li><p>其他数字签名：</p>
<p>（1）ElGamal 方式：利用了 mod <em>N</em> 中求离散对数的困难度，可被用于公钥密钥和数字签名。</p>
<p>（2）DSA（Digital Signature Algorithm）：是一种数字签名算法，是由 NIST（National Institute of Standards and Technology，美国国家标准技术研究所） 于 1991 年制定的数字签名规范（DSS）。</p>
<p>（3）ECDSA（Elliptic Curve Digital Signature Algorithm）：是一种利用椭圆曲线密码来实现的数字签名算法。</p>
<p>（4）Rabin 方式：利用了在 mod <em>N</em> 中求平方根的困难度，可被用于公钥密码和数字签名。 </p>
</li>
<li><p>数字签名无法解决的问题：使用数字签名我们同时实现了确认消息的完整性、进行认证以及防止否认，然而要正确使用数字签名，有一大前提就是用于验证签名的公钥必须属于真正的发送者，为了确认自己得到的公钥是否合法，我们需要证书，所谓证书，就是将公钥当作一条消息，由一个可信的第三方对其签名后得到的公钥。当然，这样只是把问题转移了而已，为了对证书上施加的数字签名进行验证，我们必定需要另一个公钥，如何才能构建一个可信的数字签名链条？又由谁来颁发可信的证书？因此我们需要让公钥以及数字签名成为一种社会性的基础设施，即公钥基础设施（Public Key Infrastructure，PKI）。</p>
</li>
</ul>
<h2 id="十、证书"><a href="#十、证书" class="headerlink" title="十、证书"></a>十、证书</h2><ul>
<li><p>公钥证书（Public-Key Certificate，PKC）：里面记录了姓名、组织、邮箱地址等个人信息，以及属于此人的公钥，并由<strong>认证机构</strong>（Certificate Authority、Certifying Authority，CA）施加数字签名，只要看到公钥证书，我们就可以知道认证机构认定该公钥确属于此人，公钥证书简称为<strong>证书</strong>（certificate）。有名的认证机构包括 <strong>VerSign</strong> 等。</p>
<p>  <img src="https://ws1.sinaimg.cn/large/006tNc79gy1fmsuk1pf4kj30sg0lctd6.jpg" alt="14"></p>
</li>
<li><p>证书标准规范：证书是由认证机构颁发的，使用者需要对证书进行验证，因此如果证书的格式千奇百怪那就不方便了，于是，人们制定了证书的标准规范，其中使用最为广泛的是由 ITU（International Telecommunication Union，国际电信联盟）和 ISO（International Organization for Standardization，国际标准化组织）制定的 X.509 规范，很多应用程序都支持 X.509 并将其作为证书生成和交换的标准规范。</p>
</li>
<li><p>公钥基础设施（Public-Key Infrastructure，PKI）：是为了更有效地运用公钥而制定的一系列规范和规格的总称，PKI 只是一个总称，而非指某一个单独的规范和规格。例如。RSA 公司所制定的 <strong>PKCS</strong>（Public-Key Cryptography Standards，公钥密码标准）系列规范也是 PKI 的一种，而互联网规格 <strong>RFC</strong>（Request for Comments）中也有很多与 PKI 相关的文档。此外 X.509 这样的规范也是 PKI 的一种。在开发 PKI 程序时所使用的由各个公司编写的 <strong>API</strong>（Application Programmming Interfere，应用程序编程接口）和规格设计书也可以算是 PKI 的相关规格。</p>
<p>PKI 的组成要素：</p>
<p>（1）用户：使用 PKI 的实体（人或计算机）。</p>
<p>（2）认证机构（Certificate Authority，CA）：是对证书进行管理的人。认证机构的工作中，公钥注册和本人身份认证这一部分可以由<strong>注册机构</strong>（Registration Authority，RA）来分担，这样一来，认证机构就可以将精力集中到颁发证书上，从而减轻了认证机构的负担，但这样也很可能增加攻击目标。</p>
<p>（3）仓库（repository）：是一个保存证书的数据库，PKI 用户在需要的时候可以从中获取证书，仓库也叫<strong>证书目录</strong>。</p>
<p>认证机构的工作：</p>
<p>（1）生成密钥对：有两种方式，一种是由 PKI 用户自行生成，一种是由认证机构来生成（认证机构会将私钥发送给用户）。</p>
<p>（2）注册证书：在用户自行生成密钥对的情况下，用户会请求认证机构来生成证书。认证机构根据其认证业务准则（Certificate Practice Statement，CPS）对用户的身份进行认证，并生成证书。在生成证书时，需要使用认证机构的私钥来进行数字签名，生成的证书格式是由 X.509 定义的。</p>
<p>（3）作废证书与 CRL ：当用户的私钥丢失、被盗、员工从公司离职失去使用私钥的使用权限，或者是名称变更导致和证书中记载的内容不一致等情况时，认证机构需要对证书进行<strong>作废</strong>（revoke）。</p>
<p>要作废证书，认证机构需要制作一张<strong>证书作废清单</strong>（Certificate Revocation List，CRL）。</p>
<p>CRL 是认证机构宣布作废的证书一览表，具体来说，是一张已作废的证书序列号的清单，并由认证机构加上数字签名，证书序列号是认证机构在颁发证书时所赋予的编号，在证书中会有记载。</p>
<p>PKI 用户需要从认证机构获取最新的 CRL ，并<strong>查询自己要用于验证签名（或者是用于加密）的公钥证书是否已经作废</strong>，这一步非常重要。</p>
<p>证书的层级结构：</p>
<p>对于用来验证数字签名的认证机构的公钥，可以由其他的认证机构施加数字签名，从而对认证机构的公钥进行验证，即生成一张<strong>认证机构的公钥证书</strong>。</p>
<p>一个认证机构来验证另一个认证机构的公钥，这样的关系可以迭代好几层，我们将最顶层的称之为<strong>根 CA</strong>（Root CA），对于根 CA 来说，则由它自己来颁发证书，这种对自己的公钥进行数字签名的行为称为<strong>自签名</strong>（self-signature）。</p>
<p>关于公钥基础设施的误解：认证机构只需要对公钥进行数字签名就可以了，因此任何人都可以成为认证机构。国家、地方政府、医院、图书馆等公共组织和团体可以成立认证机构来实现 PKI ，公司也可以在内部实现 PKI ，甚至你和你的朋友也可以。</p>
</li>
<li><p>对证书的攻击：</p>
<p>（1）在公钥注册之前进行攻击：主动攻击者可以在认证机构进行数字签名之前，将公钥替换为自己的（防止这种攻击，可以在将公钥发送给认证机构进行注册时，使用认证机构的公钥对即将发送的公钥进行加密。此外，认证机构在确认发送公钥者的身份的时候，也可以将公钥的指纹一并发送给发送者请他进行确认）</p>
<p>（2）注册相似人名进行攻击：证书是认证机构对公钥及持有者的信息加上数字签名的产物，对于一些相似的身份信息，计算机可以进行区别，但人类往往很容易认错，而这就可以被用来攻击（防止这种攻击，认证机构必须确认证书中所包含的信息是否真的属于其持有者的个人信息，当个人身份确认失败时则不向其颁发证书）。</p>
<p>（3）窃取认证机构的私钥进行攻击：认证机构是否妥善保管自己的私钥，是与该认证机构所颁发的证书的可信度密切相关的。由于认证机构记录了自己签发的证书的序列号，因此能够判断某个证书是不是该认证机构自己签发的。一旦认证机构的私钥被窃取，认证机构就需要将私钥泄露一事<strong>通过 CRL 通知用户</strong>。</p>
<p>（4）攻击者伪装成认证机构进行攻击：<strong>如果认证机构不可信，即便证书合法，其中的公钥也不能使用</strong>。</p>
<p>（5）钻 CRL 的空子进行攻击：</p>
<p>① 利用 CRL 的时间差来发动攻击：</p>
<p>主动攻击者 Mallory 黑掉了 Bob 的电脑，窃取了私钥，伪装成 Bob 给 Alice 发送了一封要求汇款的邮件，并用窃取的私钥进行了数字签名。第二天，Bob 发现电脑被黑，私钥被盗，急忙通知认证机构 Trent 自己的公钥已经失效。Trent 接到消息，将 Bob 密钥失效一事制成 CRL 并发布。然而，在发布 CRL 之前，Alice 收到了邮件，需要验证数字签名，Alice 用 Bob 的公钥进行了验证，结果成功了，而且公钥还带有认证机构 Trent 颁发的证书，于是 Alice 信任了邮件中的内容。</p>
<p>要防范上述这种攻击是非常困难的，因此对于这种攻击的对策是：</p>
<pre><code>当公钥失效时尽快通知认证机构 
尽快发布 CRL 
尽快更新 CRL 
在使用公钥前，再次确认公钥是否已经失效。
</code></pre><p>② 利用 CRL 的时间差来发动攻击：</p>
<p>Bob 是一个坏人，设想了一个从 Alice 手上骗钱的计划，用假名字开了一个账户，写了一封要求汇款的邮件给 Alice，并用私钥进行了数字签名。紧接着又向认证机构 Trent 发送了一封邮件告知自己的公钥已经失效。在从 Trent 处收到新的 CRL 证书之前，Alice 已经验证了签名并执行了汇款。Bob 赶快从用假名字开设的账户把钱取出来。Alice 收到 Trent 的 CRL 之后，大为震惊，于是尝试联系 Bob，Bob 当即进行否认，借自己的私钥被盗取，数字签名已失效完成否认。</p>
<p>要防止这种攻击是很困难的，尽管我们可以将签名的时间（timestamp）和发送公钥作废清单请求的时间进行比对，但是私钥泄露之后很久才发现也是很正常的，因此这种比对没什么意义。</p>
<p>在这个故事中，通过公钥、证书等技术无法是被出 Bob 的犯罪行为，必须依靠刑事侦查才行。为了快速确认证书是否已经失效，人们设计出了一种名为 OCSP 的协议。</p>
<p>虽然数字签名能够防止否认，但通过钻 CRL 的空子，就有可能<strong>实现否认</strong>。</p>
</li>
<li><p>对证书的疑问：</p>
<p>（1）为什么需要证书？</p>
<p>从认证机构获取公钥，就可以降低遭到中间人攻击的风险，因为带有证书的公钥是经过认证机构进行数字签名的，事实上无法篡改，但<strong>如果双方能够当面交换公钥则不需要认证机构</strong>。</p>
<p>（2）通过自己的方法进行认证是不是更安全？</p>
<p>自己开发保密的方法是犯了典型的<strong>隐蔽式安全</strong>（Security by obscurity）错误。</p>
<p>（3）为什么要信任认证机构？</p>
<p>即便认证机构是具有层级结构的，但实际上支撑“信任”关系的也不只是单纯的层级而已。不管证书的链条是否具有层级结构，我们之所以信任某个认证机构，是因为那是我们基于多个可信的情报源所做出的判断。</p>
</li>
</ul>
<h2 id="十一、密钥"><a href="#十一、密钥" class="headerlink" title="十一、密钥"></a>十一、密钥</h2><ul>
<li><p>密钥：在使用对称密码、公钥密码、消息认证码、数字签名等密码技术时，都需要一个称为<strong>密钥</strong>（key）的巨大数字，然而，数字本身的大小并不重要，重要的是<strong>密钥空间的大小</strong>，也就是可能出现的密钥的总数量，密钥空间越大，进行暴力破解就越困难。密钥空间的大小是由<strong>密钥长度</strong>决定的。</p>
<p><strong>密钥与明文是等价的</strong>。</p>
<p>信息的机密性不应该依靠密码算法本身，而更应该依赖于妥善保管的密钥。</p>
</li>
<li><p>密钥的分类：</p>
<p>（1）对称密码的密钥和公钥密码的密钥：在<strong>对称密码</strong>中，加密和解密使用同一个密钥，由于发送者和接受者之间需要共享密钥，因此对称密码又称为<strong>共享密钥密码</strong>。在<strong>公钥密码</strong>中，加密和解密使用的是不同的密钥，用于加密的密钥称为<strong>公钥</strong>，顾名思义可以公开。用于解密的密钥称为<strong>私钥</strong>，只有需要进行解密的接受者才持有，公钥和私钥称为<strong>密钥对</strong>。</p>
<p>（2）消息认证码的密钥和数字签名的密钥：在<strong>消息认证码</strong>中，发送者和接受者使用共享的密钥来进行认证，消息认证码只有持有合法密钥的人才能计算出来，可以用来识别通信内容是否被篡改或伪装。在<strong>数字签名</strong>中，签名的生成和验证使用不同的密钥。只有持有私钥的本人才能生成签名，但由于验证签名使用的是公钥，因此任何人都可以验证签名。</p>
<p>（3）用于确保机密性的密钥和用于认证的密钥：对称密码和公钥密码的密钥都是<strong>用于确保机密性的密钥</strong>，相对地，消息认证码和数字签名所使用的密钥，则是<strong>用于认证的密钥</strong>。</p>
<p>（4）会话密钥和主密钥：当我们访问以 http:// 开头的网页时，Web 服务器和浏览器之间会进行基于 SSL / TLS 的加密通信。在这样的通信中所使用的密钥仅限于本次通信的一次性密钥，下次通信不会再使用，像这样每次通信只能使用一次的密钥称为<strong>会话密钥</strong>（session key）。相对于会话密钥，一直被重复使用的密钥称为<strong>主密钥</strong>（master key）。</p>
<p>（5）用于加密内容的密钥和用于加密密钥的密钥：加密的对象是用户直接使用的信息，这样的情况下所使用的密钥称为 <strong>CEK</strong>（Contents Encrpyting Key，内容加密密钥），相对地，用于加密密钥的密钥则称为 <strong>KEK</strong>（Key Encrpyting Key，密钥加密密钥）。</p>
<p>在很多情况下，会话密钥都是作为 CEK 使用的，而主密钥则是被作为 KEK 使用的。</p>
</li>
<li><p>密钥的管理：</p>
<p>（1）生成密钥：</p>
<p>① 用随机数生成密钥：生成密钥的最好方法就是<strong>使用随机数</strong>，尽管生成伪随机数的算法有很多种，但<strong>密码学用途的伪随机数生成器必须是专门针对密码学用途而设计的</strong>。</p>
<p>② 用口令生成密钥：使用人类可以记住的<strong>口令</strong>（password / passphrase）来生成密钥。严格来说，我们很少直接用口令来作为密钥使用，一般都是将口令输入单向散列函数，用得到的散列值作为密钥使用。为了防止字典攻击，需要在口令上面附加一串称为<strong>盐</strong>（salt）的随机数，然后再将其输入单向散列函数，这种方法称为<strong>基于口令的密码</strong>（Password Based Encrpytion，PBE）。</p>
<p>（2）配送密钥：</p>
<p>① 通过<strong>事先共享密钥</strong>来解决</p>
<p>② 通过<strong>密钥分配中心</strong>来解决</p>
<p>③ 通过 <strong>Diffie-Hellman</strong> 密钥交换来解决</p>
<p>④ 通过<strong>公钥密码</strong>解决</p>
<p>（3）更新密钥：提高通信机密的技术被称为<strong>密钥更新</strong>（key updating），在使用共享密钥通信的过程中，定期改变密钥，比如用当前密钥的散列值作为下一个密钥，因为单向散列函数具有单向性，因此反算出单向散列函数的输入（即上一个密钥）是很困难的，窃听者无法解密更新密钥这个时间点之前的通信内容，这种防止破译过去的通信内容的机制，称为<strong>后向安全</strong>（backward security）。</p>
<p>（4）保存密钥：<strong>人类无法记住具有实用长度的密钥</strong>，我们记不住密钥，但如果将密钥保存下来有可能被窃取，因此我们需要将密钥<strong>保存在保险柜等安全的地方</strong>，通过保险柜的机制确保密钥的机密性。但是却无法保证便携性，随身携带又可能会丢失被盗，因此我们可以使用<strong>将密钥加密后保存</strong>的方法，用于加密密钥的密钥称为 KEK 。那么 KEK 又如何保存呢，好像进入了死循环，对密钥进行加密的方法并没有完全解决机密性的问题，但在现实中确是一个非常有效的方法，可以<strong>减少需要保管的密钥数量</strong>。用一个密钥来代替多个密钥进行保管的方法，和认证机构的层级化非常相似，我们不需要信任多个认证机构，而只需要信任一个根 CA 就可以了，同样地，我们也不需要确保多个 CEK 的机密性，而只需要确保一个 KEK 的机密性就可以了。</p>
<p>（5）作废密钥：密钥的作废和生成是同等重要的，这是因为密钥和明文是等价的。要完全删除密钥，不但要用到密码软件，还需要在设计计算机系统时对信息安全进行充分考虑。</p>
</li>
<li><p>Diffie-Hellamn 密钥交换（Diffie-Hellamn key exchange）：是 1976 年由 Whitfield Diffie 和 Martin Hellman 共同发明的一种算法，使用这种算法，通信双方只需要交换一些可以公开的消息就能够生成出共享的秘密数字，而这一秘密数字就可以被用作对称密码的密钥，IPsec 中就使用了经过改良的Diffie-Hellamn 密钥交换。</p>
<p>虽然这种方法的名字叫做“密钥交换”，但实际上双方并没有真正交换密钥，而是通过计算生成了一个相同的共享密钥，因此这种方法也叫 <strong>Diffie-Hellman 密钥协商</strong>（Diffie-Hellman key agreement）。</p>
<blockquote>
<p>密钥交换的步骤：</p>
</blockquote>
<blockquote>
<p>假设 Alice 和 Bob 需要共享一个对称密码的密钥，然而双方之间的通信已被窃听者 Eve 窃听了。</p>
</blockquote>
<blockquote>
<p>（1）Alice 向 Bob 发送两个质数 <em>P</em> 和 <em>G</em> ：</p>
</blockquote>
<blockquote>
<p><em>P</em> 必须是一个非常大的质数，而 <em>G</em> 则是一个和 <em>P</em> 相关的数，称为<strong>生成元</strong>（generator），<em>G</em> 可以是一个较小的数字。</p>
<blockquote>
<p>生成元：<em>P</em> 的生成元的乘方结果与 1~ <em>P</em> －1 中的数字是一一对应的，正是因为具有这样一一对应的关系，Alice 才能从 1~ <em>P</em> －2 的范围中随机选择一个数字（之所以不能选择 <em>P</em> －1 是因为<em>G</em><sup><em>P</em> - 1</sup> mod <em>P</em> 的值一定是等于 1 的）。</p>
</blockquote>
</blockquote>
<blockquote>
<p><em>P</em> 和 <em>G</em> 不需要保密，被窃听者 Eve 获取也没关系，此外 <em>P</em> 和 <em>G</em> 可以由 Alice 和 Bob 中任意一方生成。</p>
</blockquote>
<blockquote>
<p>（2）Alice 生成一个随机数 <em>A</em> ：</p>
</blockquote>
<blockquote>
<p><em>A</em> 是一个 1 ~ <em>P</em> — 2 之间的整数，这个数是一个只有 Alice 知道的秘密数字，没有必要告诉 Bob，也不能让 Eve 知道。</p>
</blockquote>
<blockquote>
<p>（3）Bob 生成一个随机数 <em>B</em> ：</p>
</blockquote>
<blockquote>
<p><em>B</em> 是一个 1 ~ <em>P</em> — 2 之间的整数，这个数是一个只有 Bob 知道的秘密数字，没有必要告诉 Alice ，也不能让 Eve 知道。</p>
</blockquote>
<blockquote>
<p>（4）Alice 将 <em>G</em><sup><em>A</em></sup> mod <em>P</em> 这个数发送给 Bob ：</p>
</blockquote>
<blockquote>
<p>这个数让 Eve 知道也没关系。</p>
</blockquote>
<blockquote>
<p>（5）Bob 将 <em>G</em><sup><em>B</em></sup> mod <em>P</em> 这个数发送给 Alice ：</p>
</blockquote>
<blockquote>
<p>这个数让 Eve 知道也没关系。</p>
</blockquote>
<blockquote>
<p>（6）Alice 用 Bob 发过来的数计算 <em>A</em> 次方并求 mod <em>P</em> ：</p>
</blockquote>
<blockquote>
<p>这个数就是共享密钥。</p>
</blockquote>
<blockquote>
<p>Alice 计算的密钥 = (<em>G</em><sup><em>B</em></sup> mod <em>P</em> )<sup><em>A</em></sup> mod <em>P</em></p>
</blockquote>
<blockquote>
<p>Alice 计算的密钥 = <em>G</em><sup><em>B</em> × <em>A</em></sup> mod <em>P</em></p>
</blockquote>
<blockquote>
<p>Alice 计算的密钥 = <em>G</em><sup><em>A</em> × <em>B</em></sup> mod <em>P</em></p>
</blockquote>
<blockquote>
<p>（7）Bob 用 Alice 发过来的数计算 <em>B</em> 次方并求 mod <em>P</em> ：</p>
</blockquote>
<blockquote>
<p>Bob计算的密钥 = (<em>G</em><sup><em>A</em></sup> mod <em>P</em> )<sup><em>B</em></sup> mod <em>P</em></p>
</blockquote>
<blockquote>
<p>Bob 计算的密钥 = <em>G</em><sup><em>A</em> × <em>B</em></sup> mod <em>P</em></p>
</blockquote>
<blockquote>
<p>得出：Alice 计算的密钥 = Bob 计算的密钥</p>
</blockquote>
<blockquote>
<p>在步骤（1）~（7）中，双方交换的数字（能被 Eve 知道的数字）一共有 4 个：<em>P</em> 、<em>G</em> 、<em>G</em><sup><em>A</em></sup> mod <em>P</em> 、<em>G</em><sup><em>B</em></sup> mod <em>P</em> ，根据这四个数计算共享密钥（<em>G</em><sup><em>A</em> × <em>B</em></sup> mod <em>P</em>）是非常困难的。</p>
</blockquote>
<blockquote>
<p>如果 Eve 知道 <em>A</em> 和 <em>B</em> 中的任意一个数，那么要计算 <em>G</em><sup><em>A</em> × <em>B</em></sup> 就很简单了，仅靠上面 4 个数是很难求出 <em>A</em> 和 <em>B</em> 的。</p>
</blockquote>
<blockquote>
<p>举个例子，我们能够根据 <em>G</em><sup><em>A</em></sup> mod <em>P</em> 计算出 <em>A</em> 吗？<em>G</em><sup><em>A</em></sup> mod <em>P</em> 中的 mod <em>P</em> 是这里的关键所在，如果仅仅是 <em>G</em><sup><em>A</em></sup> 的话，要计算出 <em>A</em> 并不难，然而<strong>根据 <em>G</em><sup><em>A</em></sup> mod <em>P</em> 计算出 <em>A</em> 的有效算法到现在还没有出现</strong>，这个问题被称为<strong>有限域（finite field）的离散对数问题</strong>。</p>
</blockquote>
</li>
<li><p>椭圆曲线 Diffie-Hellman 密钥交换：Diffie-Hellman密钥交换是利用“离散对数问题”的复杂度来实现密钥的安全交换的，如果将“离散对数问题”改为“椭圆曲线上的离散对数问题”，这样的算法就称为<strong>椭圆曲线 Diffie-Hellman 密钥交换</strong>。</p>
</li>
<li><p>基于口令的密码（Password Based Encryption，PBE）：是一种根据口令生成密钥并用该密钥进行加密的方法，其中加密和解密使用同一个密钥。</p>
<p>PBE 有很多种实现方法，例如可以通过 Java 的 javax.crypto 包进行实现，此外，通过密码软件 PGP 保存密钥时，也会使用 PBE 。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fmsuk1d0kdj30sg0lctdu.jpg" alt="15"></p>
<p>PBE 加密与解密包括下列 3 个步骤：</p>
<p>（1）生成 KEK —————— 重建 KEK</p>
<p>（2）生成会话密钥并加密——解密会话密钥</p>
<p>（3）加密消息———————解密消息</p>
<p>盐的作用：盐是由伪随机数生成器生成的随机数，在生成密钥（KEK）时会和口令一起被输入单向散列函数。<strong>盐是用来防御字典攻击的</strong>，<strong>字典攻击</strong>是一种事先进行计算并准备好候选密钥列表的方法。</p>
<p>我们假设在生成 KEK 的时候没有加盐，就意味着主动攻击者可以根据字典数据事先生成大量的候选 KEK 。如果在生成 KEK 的时候加盐，则盐的长度越大，候选 KEK 的数量也随之增大，事先生成候选 KEK 就会变得非常困难。</p>
<p>口令的作用：具有充足长度的密钥是无法用人脑记忆的，同样，人脑也无法记住充足长度的口令，在PEB中，我们通过口令生成密钥（KEK），再用这密钥来加密会话密钥（CEK）。由于通过口令生成的密钥（KEK）强度不如伪随机数生成器生成的会话密钥（CEK），因此需要将盐和加密后的 CEK <strong>通过物理方式进行保护</strong>，比如保存到存储卡中随身携带。</p>
<p>通过拉伸来改良 PBE：在生成 KEK 时，通过多次使用单向散列函数就可以提高安全性，例如，如果我们将盐和口令先输入单向散列函数，然后将得到的散列值再次输入单向散列函数……像这样将单向散列函数进行多次迭代的方法称为<strong>拉伸</strong>（stretching）。</p>
<p>如何生成安全的口令：</p>
<p>（1）使用只有自己才能知道的信息，不要使用自己重要的事物的名字，不要使用关于自己的信息，不要使用被人见过的信息。</p>
<p>（2）将多个不同的口令分开使用。</p>
<p>（3）有效利用笔记。</p>
<p>（4）理解口令的局限性。</p>
<p>（5）使用口令生成和管理工具。</p>
</li>
</ul>
<h2 id="十二、随机数"><a href="#十二、随机数" class="headerlink" title="十二、随机数"></a>十二、随机数</h2><ul>
<li><p>使用随机数的密码技术：</p>
<p>（1）生成密钥：用于对称密码和消息认证码。</p>
<p>（2）生成密钥对：用于公钥密码和数字签名。</p>
<p>（3）生成初始化向量 IV ：用于分组密码的 CBC 、CFB 、OFB 模式。</p>
<p>（4）生成 nonce：用于防御重放攻击以及分组密码的 CTR 模式。</p>
<p>（5）生成盐：用于 PBE 等。</p>
<p>上面的这些用途都很重要，但其中尤为重要的是“生成密钥”和“生成密钥对”这两个，密码算法再高，只要攻击者知道了密钥，就会变得形同虚设。因此我们需要用随机数来生成密钥，使之无法看穿。<strong>为了不让攻击者看穿而使用随机数</strong>这一观点，即不可预测性，正是本章的主题。</p>
</li>
<li><p>随机数的性质：</p>
<p>可将随机数的性质分为以下三类：</p>
<p>（1）随机性：所谓随机性，简单来说就是看上去杂乱无章的性质，但是<strong>杂乱无章不代表不会被看穿</strong>，因此我们将只具备随机性的伪随机数称为“弱伪随机数”。</p>
<p>（2）不可预测性：指<strong>攻击者在知道过去生成的伪随机数列的前提下，依然无法预测出下一个生成的伪随机数</strong>的性质，因此我们将具有不可预测性的伪随机数称为<strong>强伪随机数</strong>。事实上，<strong>不可预测性是通过使用其他密码技术来实现的</strong>，例如使用单向散列函数的单向性和密码的机密性来保证伪随机数生成器的不可预测性。</p>
<p>（3）不可重现性：指无法重现和某一随机数列完全相同的数列的性质，如果除了将随机数列保存下来以外，没有其他方法可以重现该数列，我们就说该随机数列具备不可重现性。仅靠软件是无法生成具备不可重现性的随机数列的，软件只能生成伪随机数列，因为运行软件的计算机本身仅具备有限的内部状态，在内部状态相同的情况下，软件必然只能生成相同的数，因此软件所生成的数列在某一时刻一定会重复出现。首次出现重复之前的数列长度称为<strong>周期</strong>，凡是具有周期的数列，都不具备不可重现性。</p>
<p> 要生成具备不可重现性的随机数列，需要从不可重现的物理现象中获取信息，例如周围的温度和声音的变化，鼠标移动的位置、键盘输入的事件间隔，根据从这些硬件中所获取的信息而生成的数列，一般可以认为是具备不可重现性的随机数列。我们将具备不可重现性的随机数称为<strong>真随机数</strong>。</p>
<blockquote>
<p>英特尔的新型 CPU 中内置了<strong>数字随机数生成器</strong>（Digital Random Number Generator，DRNG），并提供了 RDSEED 和 RDRAND 两条指令。这种 CPU 生成随机数的原料（随机信号源）来自于电路中产生的热噪声。从随机信号源获得的不可重现的比特序列，经过 AES-CBC-MAC 算法之后，形成一串 256 比特的数据，这串数据被称为<strong>调查随机样本</strong>（conditioned entropy sample）。AES-CBC-MAC 是一种基于 AES 分组密码的 CBC 模式的消息验证码算法，在这里它的作用是将一串很长的比特序列压缩到 256 比特。</p>
</blockquote>
<blockquote>
<p>RDSEED 指令直接利用调整随机样本来生成不确定的随机序列，这样的随机序列是具备不可重现性的。这个指令的所输出的结果，一般被用作其他伪随机数生成器的种子。</p>
</blockquote>
<blockquote>
<p>RDRAND 指令则是将调整随机样本输入到 CTR 模式的 AES 分组密码中，快速生成确定的随机数列，这样的数列是具备不可预测性的。</p>
</blockquote>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">随机性</th>
<th style="text-align:center">不可预测性</th>
<th style="text-align:center">不可重现性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">弱伪随机数</td>
<td style="text-align:center">具有</td>
<td style="text-align:center">不具有</td>
<td style="text-align:center">不具有</td>
</tr>
<tr>
<td style="text-align:center">强伪随机数</td>
<td style="text-align:center">具有</td>
<td style="text-align:center">具有</td>
<td style="text-align:center">不具有</td>
</tr>
<tr>
<td style="text-align:center">真随机数</td>
<td style="text-align:center">具有</td>
<td style="text-align:center">具有</td>
<td style="text-align:center">不具有</td>
</tr>
</tbody>
</table>
<ul>
<li><p>伪随机数生成器：通过硬件生成的随机数列，是根据传感器收集的热量、声音的变化等事实上无法预测和重现的自然信息来生成的，像这样的硬件设备就称为<strong>随机数生成器</strong>（Random Number Generator，RNG），而可以生成随机数的软件就称为<strong>伪随机数生成器</strong>（Pseudo Random Number Generator，PRNG）。</p>
<p>伪随机数生成器的结构：</p>
<p>（1）内部状态：是指伪随机数生成器所管理的内存中的数值，为了响应下一个伪随机数请求，伪随机数生成器会改变自己的内部状态，因此将根据内部状态计算伪随机数生成器的方法和改变内部状态的方法结合起来，就是伪随机数生成的算法。由于内部状态决定了下一个生成的伪随机数，因此内部状态不能被攻击者知道。</p>
<p>（2）种子：是用来对伪随机数生成器的内部状态进行初始化的。种子是一串随机的比特序列，根据种子可以生成出专属于自己的伪随机数列，伪随机数生成器是公开的，但种子是需要自己保密的。</p>
<p>具体的伪随机数生成器：</p>
<p>（1）杂乱的方法：该方法无法用于密码技术，因为周期太短，不具有不可预测性，并且程序员都不能理解算法的详细内容，无法判断是否具有不可预测性。</p>
<p>（2）线性同余法（line congruential method）：是一种使用很广泛的伪随机数生成器算法，然而，它并不能用于密码技术。   </p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fmsv52a6cdj30sg0lcju7.jpg" alt="16"></p>
<p><strong>线性同余法就是将当前的伪随机数乘以 <em>A</em> 在加上 <em>C</em> ，然后将除以 <em>M</em> 得到的余数作为下一个伪随机数</strong>。（<em>A</em>、<em>C</em>、<em>M</em> 都是常量，且 <em>A</em> 和 <em>C</em> 需要小于 <em>M</em>）</p>
<p><strong>线性同余法不具备不可预测性，因此不可以将线性同余法用于密码技术</strong>。很多伪随机数生成器的库函数（library function）都是采用线性同余法编写的，例如 C 语言的库函数 rand ，以及 Java 的java.util.Random类，都采用了线性同余法，因此这些函数都无法用于密码技术。</p>
<p>（3）单向散列函数法：</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fmsv51wqusj30sg0lctbq.jpg" alt="17"></p>
<p>① 用伪随机数的种子初始化内部状态（计数器）。</p>
<p>② 用单向散列函数计算计算器的散列值。</p>
<p>③ 将散列值作为随机数输出——计算器的值加 1 。</p>
<p>④ 据需要的伪随机数数量重复步骤。</p>
<p>在此方法中，<strong>单向散列函数的单向性是支撑伪随机数生成器不可预测性的基础</strong>。</p>
<p>（4）密码法：</p>
<p>① 初始化内部状态（计数器）。</p>
<p>② 用密钥加密计数器的值。</p>
<p>③ 将密文作为伪随机数输出——计数器的值加 1 。 </p>
<p>④ 根据需要的伪随机数数量重复步骤。</p>
<p>在此方法中，<strong>密码的机密性是支撑伪随机数生成器不可预测性的基础</strong>。</p>
<p>（5）ANSI X9.17 ：关于用密码实现伪随机数生成器的具体方法，被用于密码软件 PGP 中。</p>
<p>（6）其他算法：除了上面介绍的算法，还有很多其他的生成随机数的算法，在安全相关的软件开发中，开发者在选择随机数生成算法时必须确认“这个随机数算法是否能够用于密码学和安全相关用途”。一个随机数算法再优秀，如果它不具备不可预测性，那么就不能用于密码学和安全相关用途。</p>
<p>有一个有名的伪随机数生成算法叫做<strong>梅森旋转算法</strong>（Mersenne twister），但它并不能用于安全相关的用途，和线性同余法一样，只要观察足够长的随机数列，就能够对之后生成的随机数列进行预测。</p>
<p>Java 中有一个用于生成随机数列的类，名叫 java.util.Random ,然而这个类也不能用于安全相关用途，要用于安全用途，可以使用另一个名叫 java.security.SecureRandom 的类。</p>
<p>和 Java 一样，Ruby 中也分别有 Random 类和 SecureRandom 模块，在安全相关用途中应该使用 SecureRandom，而不是 Random 。</p>
</li>
<li><p>对伪随机数的攻击：</p>
<p>（1）对种子进行攻击：伪随机数的种子和密码的密钥同等重要，一旦被攻击者知道种子，那他就能知道这个伪随机数生成器所生成的全部伪随机数列。要避免种子被攻击者知道，我们需要使用具备不可重现性的真随机数作为种子。</p>
<p>（2）对随机数池进行攻击：我们一般不会到了需要的时候才生成真随机数，而是事先在一个名为<strong>随机数池</strong>（Random pool）的文件中积累随机比特序列。随机数池的内容不可以被攻击者知道，否则伪随机数的种子就可能被预测出来。</p>
<blockquote>
<p>Linux 系统中的 /dev/random 文件就是一个根据硬件设备驱动收集的背景噪声储存真随机数的随机数池。</p>
</blockquote>
</li>
</ul>
<h2 id="十三、PGP"><a href="#十三、PGP" class="headerlink" title="十三、PGP"></a>十三、PGP</h2><ul>
<li><p>PGP（Pretty Good Privacy）：是于 1990 年左右由 Philip Zimmermann 个人编写的密码软件，现在依然被广泛使用。</p>
</li>
<li><p>OpenPGP：是对密文和数字签名格式进行定义的标准规格（RFC1991、RFC2440、RFC4880、RFC5581、RFC6637）。</p>
<p>1996 年的 RFC1991 中对 PGP 的消息格式进行了定义。2007 年的 RFC4880 中新增了对 RSA 和DSA 的支持。2012年的 RFC6637 中新增了对椭圆曲线（EEC）的支持，并且还支持基于 Curve P-256、P-384、P-521 三种椭圆曲线的椭圆曲线 DSA（Elliptic Curve Digital Signature Algorithm，ECDSA）和椭圆曲线 Diffie-Hellman 密钥交换（Elliptic Curve Diffie-Hellman，ECDH）。</p>
<p>RFC6637 中新增了用于比较密码学强度的平衡性的对照表，由此表可知，例如当我们选用 256 比特的椭圆曲线密码算法时，相应地应该选用 256 比特的散列算法以及密钥长度为 128 比特的对称算法。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">椭圆曲线名</th>
<th style="text-align:center">ECC</th>
<th style="text-align:center">RSA</th>
<th style="text-align:center">散列</th>
<th style="text-align:center">对称密码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">P-256</td>
<td style="text-align:center">256</td>
<td style="text-align:center">3072</td>
<td style="text-align:center">256</td>
<td style="text-align:center">128</td>
</tr>
<tr>
<td style="text-align:center">P-384</td>
<td style="text-align:center">384</td>
<td style="text-align:center">7680</td>
<td style="text-align:center">384</td>
<td style="text-align:center">192</td>
</tr>
<tr>
<td style="text-align:center">P-521</td>
<td style="text-align:center">521</td>
<td style="text-align:center">15360</td>
<td style="text-align:center">512</td>
<td style="text-align:center">256</td>
</tr>
</tbody>
</table>
<ul>
<li><p>GNU Privacy Guard（GunPG、GPG）：是一款基于 OpenPGP 标准开发的密码学软件，支持加密、数字签名、密钥管理、S/MIME、ssh 等多功能，基于 GNU GPL 协议发布，因此任何人可以使用它。GunPG 本身是一款命令行工具，也经常被集成到其他软件中去。</p>
</li>
<li><p>PGP 的功能：</p>
<p>（1）对称密码：可以使用的对称密码算法包括 AES、IDEA、CAST、三重 DES、Blowfish、Twofish、Camellia等。</p>
<p>（2）公钥密码：可以使用的公钥密钥算法包括 RSA 和 ElGamal 等。</p>
<p>（3）数字签名：可以使用的数字签名算法包括 RSA、 DSA、ECDMA（椭圆曲线 DSA）、EdDSA（爱德华兹曲线 DSA）等。</p>
<p>（4）单向散列函数：可以使用的单向散列函数包括 SHA-1、SHA-224、SHA-256、SHA-384、SHA-512 和 RIPEMD-160 等。</p>
<p>（5）证书：可以使用 OpenGPG 中规定格式的证书，以及与 X.509 规范兼容的证书，此外，还可以颁发公钥的作废证明（revocation certificate），并可以使用 CRL 和 OSCP 对证书进行检验。</p>
<p>（6）压缩：压缩采用 ZIP、ZLIB、BZIPZ 等格式。</p>
<p>（7）文本数据：可以将二进制数据和文本数据（ASCII radix-64 格式）进行互换。（radix-64 格式是在邮件等场合中经常使用的 base-64 编码的基础上，增加了检测数据错误的校验和的版本）</p>
<p>（8）大文件的拆分和拼合</p>
<p>（9）钥匙串管理：可以管理所生成的密钥对以及外部获取的公钥，用于管理密钥的文件称为钥匙串（key ring）</p>
</li>
<li><p>加密与解密：基本结构和混合密码系统是一样的，差异在于这里还包括了消息的压缩与解压缩以及二进制＜－＞文本转换（ASCII radix-64 格式）这两个步骤。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fmsv52k13dj30sg0lctbg.jpg" alt="18"></p>
</li>
<li><p>生成和验证数字签名：</p>
</li>
<li><p>生成数字签名并加密以及解密并验证数字签名： </p>
</li>
<li><p>信任网（web of trust）：在这种方法中，PGP 用户会互相对对方的公钥进行数字签名，不依赖认证机构，而是建立每个人之间的信任关系。PGP 用户可以自行设置对谁进行何种程度的信任，PGP 就是根据信任数据库中的设置来判断所得到的公钥是否属于本人。PGP 当初的设计目的是在连国家都不可信的情况下依然能够使用，因此并不关心有没有可信的认证机构。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">信任级别</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">绝对信任（Ultimately trusted）</td>
</tr>
<tr>
<td style="text-align:center">完全信任（Fully trusted）</td>
</tr>
<tr>
<td style="text-align:center">有限信任（Marginally trusted）</td>
</tr>
<tr>
<td style="text-align:center">不信任（Never trust this key）</td>
</tr>
<tr>
<td style="text-align:center">未知密钥（Not enough information）</td>
</tr>
<tr>
<td style="text-align:center">未设置（No owner trust assigned）</td>
</tr>
</tbody>
</table>
<h2 id="十四、SSL-TLS"><a href="#十四、SSL-TLS" class="headerlink" title="十四、SSL / TLS"></a>十四、SSL / TLS</h2><ul>
<li><p>SSL/TLS ：是世界上使用最广泛的密码通信方法。</p>
<p>客户端与服务器：当我们需要用浏览器浏览一个网页的时候，Web 浏览器就是我方计算机上运行的一个程序，而 Web 服务器则是对方计算机上运行的一个程序，它们都遵循 <strong>HTTP</strong>（HyperText Transfer Protocol，超文本传输协议）来进行通信，其中，Web浏览器被称为 <strong>HTTP 客户端</strong>，Web 服务器被称为 <strong>HTTP 服务器</strong>，HTTP 可以认为是在 HTTP 客户端与 HTTP 服务器之间进行请求和响应的规范。</p>
<p>用 SSL/TLS 承载 HTTP：当Web浏览器发送信用卡号时，我们可以用 SSL（Secure Socket Layer）或者 TLS（Transport Layer Security）作为对通信进行加密的协议，然后<strong>在此之上承载 HTTP</strong> 。通过将两种协议叠加，我们就可以对 HTTP 的通信进行加密，因此当通过 SSL/TLS 进行通信时，URL不是以 http://开头，而是以https://开头。</p>
<p>SSL/TLS 也可以保护其他的协议：不仅可以承载 HTTP ，发送邮件时使用的 SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）和接受邮件时使用的 POP3（Post Office Protocol，邮局协议）都可以用 SSL/TLS 进行承载。</p>
<p>密码套件（cipher suite）：SSL/TLS 提供了一种密码通信的框架，这意味着 SSL/TLS 中使用的对称密码、公钥密码、数字签名、单向散列函数等技术，都可以像零件一样进行替换，也就是说，如果发现所使用的某个密码技术存在的弱点，只要将这一部分进行替换就好了。</p>
<p>尽管如此，并不是说所有的组件都可以自由选择，选择过于自由，难以保证整体的兼容性，为此，SSL/TLS 就像事先搭配好的盒饭一样，规定了一些密码技术的“推荐套餐”，被称为密码套件。</p>
<p>SSL 与 TLS 的区别：SSL（Secure Socket Layer，安全套接层）是 1994 年由网景（Netscape）公司设计的一种协议，随后成为行业标准。SSL 已于 1995 年发布了 3.0 版本，但在 2014 年，SSL 3.0 协议被发现存在可能导致 POODLE 攻击的安全漏洞，因此 SSL 3.0 已经不安全了。</p>
<p>TLS（Transport Layer Security，传输层安全）是 IETF 在 SSL 3.0 的基础上设计的协议，TLS 相当于 SSL 的后续版本。</p>
</li>
<li><p>使用 SSL/TLS 进行通信：</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fmsv51lq3jj30sg0lcq5m.jpg" alt="19"></p>
<p>（1）TLS 记录协议：位于 TLS 握手协议的下层，是负责使用对称密码对消息进行加密通信的部分，该协议中使用了对称密码和消息认证码，但是具体的算法和共享密钥则是通过后面的握手协议在服务器和客户端之间协商决定的。</p>
<p>首先消息被分割成多个较短的片段（fragment），然后分别对每个片段进行压缩。压缩算法需要与通讯对象进行协商。</p>
<p>接下来，经过压缩的片段会被加上消息认证码，这是为了保证完整性，并进行数据的认证，通过附加消息认证码的 MAC 值，可以识别出篡改。与此同时，为了防止重放攻击，在计算消息认证码时，还加上了片段的编号。单向散列函数的算法，以及消息认证码所使用的共享密钥都需要与通信对象协商决定。</p>
<p>再接下来，经过压缩的片段再加上消息认证码会一起通过对称密码进行加密。加密使用 CBC 模式，CBC 模式 的初始化向量（IV）通过主密码生成，而对称密码的算法以及共享密钥需要与通信对象协商决定。</p>
<p>最后，上述经过加密的数据加上数据类型、版本号、压缩后的长度组成的报头（header）就是最终的报文数据。其中，数据类型为 TLS 记录协议所承载的 4 个子协议 的其中之一。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fmsv517yjij30sg0lcwi1.jpg" alt="20"></p>
<p>（2）TLS 握手协议：</p>
<p>（2.1）握手协议：握手协议负责生成共享密钥以及交换证书，其中生成密钥是为了进行密码通信，交换证书是为了通信双方相互进行认证。由于握手协议中的信息交换是在没有加密的情况下进行的，也就是说协议所收发的数据很有可能被窃听，因此在这一过程中必须使用公钥密码或者 Diffie-Hellman 密钥交换。</p>
<blockquote>
<p>握手协议详解：</p>
</blockquote>
<blockquote>
<ol>
<li>ClientHello（客户端﹣＞服务器）</li>
</ol>
</blockquote>
<blockquote>
<p> 客户端向服务器发送 ClientHello 消息</p>
</blockquote>
<blockquote>
<p> 客户端：“你好。我能理解的密码套件有 RSA/3DES，或者 DSS/AES，请问我们使用哪一种密码套件进行通信呢？”</p>
</blockquote>
<blockquote>
<p> 客户端会向服务器发送下列消息： </p>
</blockquote>
<blockquote>
<pre><code>可用版本号
当前时间
客户端随机数
会话 ID
可用的密码套件清单
可用的压缩方式清单
</code></pre><p> 之所以发送“可用版本号”“可用的密码套件清单”“可用的压缩方式清单”，是因为不同的客户端所支持的方式不同，具体使用哪一种来通信，需要和服务器来协商。</p>
</blockquote>
<blockquote>
<p> “当前时间”在基本的 TLS 中是不使用的，但上层协议有可能会使用，“客户端随机数”是一个由客户端生成的不可预测的随机数，我们在后面的步骤中需要用到它。</p>
</blockquote>
<blockquote>
<p> “会话 ID”是当客户端和服务器希望重新使用之前建立的会话时所使用的信息。</p>
</blockquote>
<blockquote>
<ol start="2">
<li>SeverHello（客户端＜﹣服务器）</li>
</ol>
</blockquote>
<blockquote>
<p> 对于客户端发送的 ClientHello 消息，服务器会返回一个 SeverHello 消息。</p>
</blockquote>
<blockquote>
<p> 服务器：“你好，我们就用 RSA/3DES 来进行通信吧。”</p>
</blockquote>
<blockquote>
<p> 服务器会将下列消息随 SeverHello 消息一起发出去。</p>
</blockquote>
<blockquote>
<pre><code>使用的版本号
当前时间
服务器随机数
会话 ID
使用的密码套件
使用的压缩方式
</code></pre></blockquote>
<blockquote>
<p> 服务器会根据客户端在 ClientHello 消息中发送过来的消息确定通信中使用的“版本号”“密码套件”和“压缩方式”。</p>
</blockquote>
<blockquote>
<p> “服务器随机数”是一个服务器生成的不可预测的随机数，这个随机数必须与客户端生成的随机数无关，会在后面的步骤中用到它。</p>
</blockquote>
<blockquote>
<ol start="3">
<li>Certificate（客户端＜﹣服务器）</li>
</ol>
</blockquote>
<blockquote>
<p> 服务器会发送 Certificate 消息。</p>
</blockquote>
<blockquote>
<p> 服务器：“好，这是我的证书。”</p>
</blockquote>
<blockquote>
<p> 通过 Certificate 消息，服务器会向客户端发送下列消息。</p>
</blockquote>
<blockquote>
<pre><code>证书清单
</code></pre></blockquote>
<blockquote>
<p> 证书清单是一组 X.509v3 证书序列，首先发送的是服务器（发送方）的证书，然后会按顺序发送服务器证书签名的认证机构的证书。</p>
</blockquote>
<blockquote>
<p> 客户端会对服务器发送过来的证书进行验证，当以匿名方式通信时，不发送 Certificate 消息。</p>
</blockquote>
<blockquote>
<ol start="4">
<li>ServerKeyExchange（客户端＜﹣服务器） </li>
</ol>
</blockquote>
<blockquote>
<p> 服务器发送 SeverKeyExchange 消息。</p>
</blockquote>
<blockquote>
<p> 服务器：“我们用这些消息来进行密钥交换吧”</p>
</blockquote>
<blockquote>
<p> 当 Certificate 消息不足以满足需求的时，服务器会通过 ServerKeyExchange 消息向客户端发送一些必要消息。具体所发送的消息内容会根据所使用的密码套件而有所不同。</p>
</blockquote>
<blockquote>
<p> 当不需要这些消息时，将不会发送 ServerKeyExchange 消息。  </p>
</blockquote>
<blockquote>
<ol start="5">
<li>CertificateRequest (客户端＜﹣服务器）</li>
</ol>
</blockquote>
<blockquote>
<p> 服务器发送 Certificate 消息。</p>
</blockquote>
<blockquote>
<p> 服务器：“对了，请给我看一下你的证书吧。”</p>
</blockquote>
<blockquote>
<p> CertificateRequest 消息用于服务器向客户端请求证书，这是为了进行客户端认证，通过这一消息，服务器会向客户端发送下列消息</p>
</blockquote>
<blockquote>
<pre><code>服务器能够理解的证书类型清单
服务器能够理解的认证机构名称清单
</code></pre></blockquote>
<blockquote>
<p> 当不使用客户端认证时，不会发送 CertificateRequest 消息。</p>
</blockquote>
<blockquote>
<ol start="6">
<li>ServerHelloDone（客户端＜﹣服务器）</li>
</ol>
</blockquote>
<blockquote>
<p> 服务器发送 SeverHelloDone 消息。</p>
</blockquote>
<blockquote>
<p> 服务器：“问候到此结束。”</p>
</blockquote>
<blockquote>
<p> 这一消息表示从 ServerHello 消息开始的一系列消息的结束。</p>
</blockquote>
<blockquote>
<ol start="7">
<li>Certificate（客户端﹣＞服务器） </li>
</ol>
</blockquote>
<blockquote>
<p> 客户端发送 Certificate 消息。</p>
</blockquote>
<blockquote>
<p> 客户端：“这是我的证书。”</p>
</blockquote>
<blockquote>
<p> 当步骤 5 中服务器发送了 CertificateRequest 消息时，客户端会将自己的证书同 Certificate 消息一同发给服务器。</p>
</blockquote>
<blockquote>
<p> 服务器读取客户端的证书并进行验证。 </p>
</blockquote>
<blockquote>
<p> 当服务器没有发送 CertificateRequest 消息时，客户端不会发送 Certificate 消息。</p>
</blockquote>
<blockquote>
<ol start="8">
<li>ClientExchange（客户端﹣＞服务器） </li>
</ol>
</blockquote>
<blockquote>
<p> 客户端发送 ClientExchange 消息。</p>
</blockquote>
<blockquote>
<p> 客户端：“这是经过加密的预备主密码。”</p>
</blockquote>
<blockquote>
<p> 当密码套件中包含 RSA 时，会随着 ClientExchange 消息一起发送经过加密的预备主密码。</p>
</blockquote>
<blockquote>
<p> 当密码套件中包含 Diffie-Hellman 密钥交换时，会随着 ClientExchange 消息一起发送 Diffie-Hellman 的公开值。</p>
</blockquote>
<blockquote>
<p> 预备主密码（pre-master secret）是由客户端生成的随机数，之后会被用作生成主密码的种子，这个值会使用服务器的公钥进行加密后发送给服务器。</p>
</blockquote>
<blockquote>
<p> 根据预备主密码，服务器和客户端会计算出相同的主密码，然后再根据主密码生成下列比特序列（密钥素材）。</p>
</blockquote>
<blockquote>
<pre><code>对称密码的密钥
消息认证码的密钥
对称密码的 CBC 模式中使用的初始化向量（IV）
</code></pre></blockquote>
<blockquote>
<ol start="9">
<li>CertificateVerify（客户端﹣＞服务器） </li>
</ol>
</blockquote>
<blockquote>
<p> 客户端发送 CertificateVerify 消息。</p>
</blockquote>
<blockquote>
<p> 客户端：“我确实是客户端证书的持有者本人。”</p>
</blockquote>
<blockquote>
<p> 客户端只有在服务器发送 CertificateRequest 消息时才会发送 CertificateVerify 消息。这个消息的目的是向服务器证明自己的确持有客户端证书的私钥。</p>
</blockquote>
<blockquote>
<p> 为了实现这一目的，客户端会计算“主密码”和“握手协议中传送的消息”的散列值，并加上自己的数字签名后发送服务器。</p>
</blockquote>
<blockquote>
<ol start="10">
<li>ChangeCipherSpec（客户端﹣＞服务器）</li>
</ol>
</blockquote>
<blockquote>
<p> 客户端发送 ChangeCipherSpec 消息。</p>
</blockquote>
<blockquote>
<p> 客户端：“好，现在我要切换密码了。”</p>
</blockquote>
<blockquote>
<p> 实际上，ChangeCipherSpec 消息并不是握手协议的消息，而是密码变更协议的消息。</p>
</blockquote>
<blockquote>
<p> 在 ChangeCipherSpec 消息之前，客户端和服务器之间已经交换了所有关于密码套件的信息，因此在收到这一消息时，客户端和服务器会同时切换密码。</p>
</blockquote>
<blockquote>
<p> 在这一消息之后，TLS 记录协议就开始使用双方协商决定的密码通信方式了。</p>
</blockquote>
<blockquote>
<ol start="11">
<li>Finished（客户端﹣＞服务器）</li>
</ol>
</blockquote>
<blockquote>
<p> 客户端发送 Finished 消息。 </p>
</blockquote>
<blockquote>
<p> 客户端：“握手协议到此结束。”</p>
</blockquote>
<blockquote>
<p> 由于已经完成了密码切换，因此 Finished 消息时】是使用切换后的密码套件来发送的。实际负责加密操作的是 TLS 记录协议。</p>
</blockquote>
<blockquote>
<p> Finished 消息的内容是固定的，因此服务器可以将收到的密文解密，来确认所收到的 Finished 消息是否正确，通过这一消息，就可以确认握手协议是否正常结束，密码套件的切换是否正确。</p>
</blockquote>
<blockquote>
<ol start="12">
<li>ChangeCipherSpec（客户端＜﹣服务器）</li>
</ol>
</blockquote>
<blockquote>
<p> 这次轮到服务器发送 ChangeCipherSpec 消息了。</p>
</blockquote>
<blockquote>
<p> 服务器：“好，现在我要切换密码了。”</p>
</blockquote>
<blockquote>
<ol start="13">
<li>Finished（客户端＜﹣服务器） </li>
</ol>
</blockquote>
<blockquote>
<p> 和客户端一样，服务器也会发送 Finished 消息。</p>
</blockquote>
<blockquote>
<p> 服务器：“握手协议到此结束。”</p>
</blockquote>
<blockquote>
<p> 这一消息会使用切换后的密码套件来发送，实际负责加密操作的是 TLS 记录协议。</p>
</blockquote>
<blockquote>
<ol start="14">
<li>切换至应用数据协议</li>
</ol>
</blockquote>
<blockquote>
<p> 在此之后，客户端和服务器会使用应用数据协议和 TLS 记录协议进行密码通信。</p>
</blockquote>
<blockquote>
<p> 从结果上来看，握手协议完成了下列操作：</p>
</blockquote>
<blockquote>
<pre><code>客户端获得了服务器的合法公钥，完成了服务器认证
服务器获得了客户端的合法公钥，完成了客户端的认证（当需要客户端认证时）
客户端和服务器生成了密码通信中使用的共享密钥
客户端和服务器生成了消息认证码中使用共享密钥
</code></pre></blockquote>
</li>
</ul>
<p> （2.2）密码规格变更协议：用于密码切换的同步。</p>
<p> （2.3）警告协议：用于当发送错误时通知通信对象，当握手协议的过程中产生异常，或者发生消息认证码错误、压缩数据无法解压缩等问题时，会使用该协议。</p>
<p> （2.4）应用数据协议：用于和通信对象之间传送应用数据，当 TLS 承载 HTTP 时，HTTP 的请求和响应就会通过 TLS 的应用数据协议和 TLS 记录协议来进行传送。</p>
<ul>
<li><p>主密码：主密码是 TLS 客户端和服务器之间协商出来的一个秘密的数值，TLS 密码通信的机密性和数据的认证全部依靠这个数值，主密码是一个 48 字节（384 比特）的数值。</p>
<p>主密码是客户端和服务器根据下列信息计算出来的：</p>
<pre><code>预备主密码
客户端随机数
服务器随机数
</code></pre><p>当使用 RSA 公钥密码时，客户端会在发送 ClientKeyExchange 消息时，将经过加密的预备密码一起发送给服务器，当使用 Diffie-Hellman 密钥交换时，客户端会在发送 ClientKeyChange 消息时，将 Diffie-Hellman 的公开值一起发送给服务器。根据这个值，客户端和服务器会各自生成预备主密码。客户端随机数和服务器随机数的作用相当于防止攻击者事先计算出密钥的盐。</p>
<p>主密码用于生成下列 6 中消息：</p>
<pre><code>对称密码的密钥（客户端﹣＞服务器）
对称密码的密钥（客户端＜﹣服务器）
消息认证码的密钥（客户端﹣＞服务器）
消息认证码的密钥（客户端＜﹣服务器）
对称密码的 CBC 模式所使用的初始化向量（客户端﹣＞服务器）
对称密码的 CBC 模式所使用的初始化向量 （客户端＜﹣服务器）
</code></pre></li>
</ul>
<ul>
<li>TLS 握手协议中使用的密码技术</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">密码技术</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">公钥密码</td>
<td style="text-align:center">加密预备主密码</td>
</tr>
<tr>
<td style="text-align:center">单向散列函数</td>
<td style="text-align:center">构成伪随机数生成器</td>
</tr>
<tr>
<td style="text-align:center">数字签名</td>
<td style="text-align:center">验证服务器和客户端的证书</td>
</tr>
<tr>
<td style="text-align:center">伪随机数生成器</td>
<td style="text-align:center">生成预备主密码、根据主密码生成密钥（密码参数）、生成初始化向量</td>
</tr>
</tbody>
</table>
<ul>
<li>TLS 记录协议中使用的密码技术</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">密码技术</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">对称密码（CBC模式）</td>
<td style="text-align:center">确保片段的机密性</td>
</tr>
<tr>
<td style="text-align:center">消息认证码</td>
<td style="text-align:center">确保片段的完整性并进行认证</td>
</tr>
<tr>
<td style="text-align:center">认证加密（AEAD）</td>
<td style="text-align:center">确保片段的完整性和机密性并进行认证</td>
</tr>
</tbody>
</table>
<ul>
<li><p>对 SSL/TLS 的攻击：</p>
<p>（1）对各个密码技术的攻击：当然 SSL/TLS 作为框架的特性也被体现，更换密码套件即可。</p>
<p>（2）OpenSSL 的心脏出血漏洞：2014 年，Goolge 的 Neel Mehta 发现了广泛使用的密码学工具 OpenSSL 中存在一个 bug ,这个漏洞被称为<strong>心脏出血</strong>（HeartBleed） ，心脏出血并不是 SSL/TLS 协议本身的漏洞，而是 OpenSSL 这一实现上的漏洞。具体来说，由于 OpenSSL 在 TLS 心跳拓展功能中对于请求的数据大小没有进行检查，从而导致将内存中于该请求无关的信息返回给了请求者，攻击者通过访问包含该漏洞的 OpenSSL 的服务器，就可以在一定范围内窃取服务器上的信息。</p>
<p>这一漏洞公布时，全世界有相当多的服务器都收到了影响，据称当时有 17% 的 SSL/TLS 服务器都具有这一漏洞。</p>
<p>（3）SSL 3.0 的漏洞与 POODLE 攻击：Google 发现了针对 SSL 3.0 漏洞的攻击——POODLE攻击，SSL 3.0 中对 CBC 模式加密时的分组填充操作没有进行严格的规定，而且填充数据的完整性没有收到消息认证码的保护，POODLE攻击正是利用了这一漏洞。POODLE 攻击的本质就是填充提示攻击。</p>
<p>在某些条件下，攻击者可以将通信协议的版本从 TLS 强制降级到 SSL 3.0，也就是说，导致存在遭受 POODLE 攻击的风险。</p>
<p>要有效抵御 POODLE 攻击，必须禁用 SSL 3.0。</p>
<p>（4）FREAK 攻击与密码产品出口管制：FREAK 是 Factoring RSA Export Keys（出口级 RSA 密钥质因数分解）的缩写，从首字母看，并未出现“A”，缩写成 FREAK 是为了和“freak”形成双关，其攻击方式是强制 SSL/TLS 服务器使用一种名为 RSA Export Suites 的强度较低的密码套件。要实现 FREAK 攻击，除了需要 SSL/TLS 服务器具有该漏洞，同时还需要用户的 Web 浏览器（HTTP 客户端）接受使用 RSA Export Suites 来进行通信。</p>
<p>美国曾经将密码算法和软件作为武器来看待，因此历史上一度禁止将“高强度密码软件”出口到国外（<strong>密码产品出口管制</strong>），直到 20世纪 90年代后半期这一政策才有所缓和，RSA Export Suites 就是一种配合当时的环境而故意弱化的密码套件。</p>
<p>（5）对伪随机数生成器的攻击：1995年，加州大学的研究生发现了网景浏览器的一个 bug，这个 bug 存在于伪随机数生成器中。由于 SSL 中使用的伪随机数生成器的种子都在时间和进程编号等可预测的范围内，因此所得到的密钥范围实际上非常小。</p>
<p>（6）利用证书的时间差进行攻击：在 SSL/TLS 中，客户端会使用服务器证书对服务器进行认证，在这个过程中，客户端需要使用合法认证机构的公钥对证书所附带的数字签名进行验证。要验证证书需要使用最新版的 CRL（证书作废清单），如果 Web 浏览器没有获取最新版的 CRL，即便使用 SSL/TLS 也无法保证通信的安全。</p>
</li>
<li><p>SSL/TLS 注意事项：</p>
<p>（1）不要误解证书的含义：<strong>即便对方拥有合法的证书，也不代表你就可以放心地发送信用卡号</strong>，仅通过 SSL/TLS 是无法确认对方是否在从事信用卡诈骗的。</p>
<p>另外，认证机构所进行的本人身份确认也分为不同的等级，需要仔细确认一下认证机构的业务规则。</p>
<p>（2）密码通信之前的数据是不受保护的</p>
<p>（3）密码通信之后的数据是不受保护的 </p>
</li>
</ul>
<h2 id="十五、密码技术与现实社会"><a href="#十五、密码技术与现实社会" class="headerlink" title="十五、密码技术与现实社会"></a>十五、密码技术与现实社会</h2><ul>
<li><p>密码学家的工具箱</p>
<p>（1）对称密码：是一种用相同的密钥进行加密和解密的技术，用于确保消息的机密性。在对称密码的算法中，目前主要使用的是 AES 。尽管对称密码能够确保消息的机密性，但需要解决将解密密钥配送给接受者的密钥配送问题。</p>
<p>（2）公钥密码：是一种用不同的密钥进行加密和解密的技术，和对称密码一样用于确保消息的机密性。使用最广泛的是公钥算法是 RSA ，除此之外，还有 ElGamal 和 Rabin 等算法，以及与其相关 Diffie-Hellman 密钥交换（DH）和椭圆曲线 Diffie-Hellman 密钥交换（ECDH）等技术。和对称密码相比，公钥密钥的速度非常慢，因此一般都会与对称密码一起组成混合密码系统使用。公钥密码能够解决对称密码中的密钥交换问题，但存在通过中间人攻击被伪装的风险，因此需要对带有数字签名的公钥进行认证。</p>
<p>（3）单向散列函数：是一种将长消息转换为短散列值的技术，用于确保消息的完整性。在单向散列函数的算法方面，SHA-1 曾被广泛使用，但由于人们已经发现了一些针对该算法的理论上可行的攻击方式，因此该算法不应再被用于新的用途，今后我们应该主要使用的算法包括目前已经在广泛使用的 SHA-2（SHA-224、SHA-256、SHA-384、SHA-512），以及具有全新结构的 SHA-3（Keccak）算法。单向散列函数可以单独使用，也可以作为消息认证码、数字签名以及伪随机数生成器等技术的组成元素来使用。</p>
<p>（4）消息认证码：是一种能够识别通信对象发送的消息是否被篡改的认证技术，用于验证消息的完整性，以及对消息进行认证。消息认证码的算法中，最常用的是利用单向散列函数的 HMAC ，HMAC 的构成不依赖于某一种具体的单向散列函数算法。消息认证码能够对通信对象进行认证，但无法对第三方进行认证，此外也无法防止否认。消息认证码也可以用来实现认证加密。</p>
<p>（5）数字签名：是一种能够对第三方进行消息认证，并能够防止通信对象作出否认的技术。数字签名的算法包括 RSA 、ElGamal 、DSA 、椭圆曲线 DSA（ECDSA）、爱德华兹曲线 DSA（EDDSA）等。公钥基础设施（PKI）中使用的证书，就是公钥加上认证机构的数字签名所构成的。要验证公钥的数字签名，需要通过某种途径获取认证机构自身的合法公钥。</p>
<p>（6）伪随机数生成器：是一种能够生成具备不可预测性的比特序列的技术，由密码和单向散列函数等技术构成。用于生成密钥、初始化向量和 nonce 等。</p>
</li>
<li><p>密码与认证：认证也是密码技术中重要的组成部分，例如，公钥密码是一种很重要的技术，但如果无法确认自己所持有的公钥的合法性，即是否是经过验证的公钥，公钥密码就无法发挥作用。</p>
<p>此外，即便在使用高强度的密码算法来确保机密性的情况下，依然存在像填充提示攻击这样通过伪造密文来窃取明文相关信息的攻击方式。在这种情况下，我们需要对接受到的密文进行认证，判断是不是通过合法的加密过程生辰出来的，这样才能有效地确保信息的机密性。</p>
</li>
<li><p>密码技术的框架化</p>
<p>框架的特点就是能够对其中作为组成元素的技术进行替换。例如，消息认证码算法 HMAC 的设计就允许对单向散列函数的算法进行替换，此外，在 PGP 中，对称密码、公钥密码、单向散列函数等都是可以替换的。在 SSL/TLS 中，客户端和服务器可以通过握手协议进行通信，并当场决定所使用的密码套件。</p>
<p>当然，现实世界中的问题也没有这样单纯，2014 年发现的 POODLE 攻击，就是利用 SSL/TLS 在握手协议中确定密码套件的机制来对协议的版本来进行强制降级的，这可以说是一种针对 SSL/TLS<br>框架本身的攻击。</p>
</li>
<li><p>密码技术与压缩技术</p>
<p>在密码学家的工具箱中，所有的技术都可以看成是一种“压缩技术”。</p>
<p>无论是对称密码还是公钥密码，密码的作用是确保机密性。通过保护较短的密钥来保护较长的明文，这样的做法被称为<strong>机密性的压缩</strong>。</p>
<p>单向散列函数是用于确认完整性。通过检查较短的散列值来确认较长的明文的完整性，这样的做法可以称为<strong>完整性的压缩</strong>。</p>
<p>消息认证码和数字签名都是用于认证的技术，但我们并不是直接对较长的消息本身进行认证，而是通过将较长的消息与密钥结合起来，生成较短的比特序列（认证符号）,再通过认证符号进行认证。在消息认证码中，MAC 值就是认证符号，在数字签名中，签名就是认证符号。通过较短的认证符号来对较长的消息进行认证，这样的做法可以称为<strong>认证的压缩</strong>。</p>
<p>在伪随机数生成器中，要大量生成具备不可预测性的随机数列非常困难，于是我们通过将种子输入伪随机数生成器，生成具备不可预测性的伪随机数列，这可以被称为<strong>不可预测性的压缩</strong>。反过来说，伪随机数生成器是将种子的不可预测性进行了扩张。</p>
<p>从另一角度总结：</p>
<pre><code>密钥是机密性的精华
散列值是完整性的精华
认证符号是认证的精华
种子是不可预测性的精华
</code></pre></li>
<li><p>比特币</p>
<p>比特币于 2009 年被实际运用，随后在世界各国流行起来。2015 年，美国开设了世界上第一家比特币交易所 Coinbase。 </p>
<p>（1）P2P 网络：比特币体系中没有中央银行，比特币完全依赖于去哪世界所有比特币用户组成的 P2P 网络（Peer to Peer Network）。全世界所有比特币用户的计算机（node 或者 peer）共同保存、验证和使用支撑比特币体系的所有必要信息。</p>
<p>与其说比特币是一种货币，不如说<strong>比特币是一种基于 P2P 网络的支付结算系统</strong>。</p>
<p>（2）地址：比特币交易是在<strong>比特币地址</strong>之间完成的，大多数情况下人们会为每一次比特币交易创建不同的地址，当然，在捐赠等场景中，也会反复使用同一个地址。</p>
<p>比特币使用的地址是由公钥的散列值生成的。具体来说，将椭圆曲线 DSA 的公钥输入 SHA-256 和 RIPEMD-160 两个单项散列函数来求出散列值，为其附加一些信息后再通过 Base58Check 进行编码，转换成字符串。为防止混淆，Base58Check 编码中不使用数字（0）、大写（O）、大写（I）和小写（l）。</p>
<p>（3）钱包：比特币交易需要客户端，这种客户端叫做钱包。用户可以在自己的计算机和智能手机上安装钱包应用程序，也可以通过提供钱包服务的网站来使用比特币。</p>
<p>（4）区块链（block chain）：是<strong>保存比特币全部交易记录的公共账薄</strong>，记录了比特币体系中<strong>所有的地址</strong>迄今为止<strong>所有的交易</strong>。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fmsv5011z2j30sg0lc78j.jpg" alt="21"></p>
<p>（5）区块的添加：比特币的首付款是以交易为单位进行的，若干条交易会被合并为一个区块，并被添加到区块链中，当 P2P 网络确认区块的添加后，相应的交易也就成立了。</p>
<p>一个区块是由若干条交易以及一个区块头所组成的，区块头保存了“上一个区块的区块头的散列值”，如图所示，其中区块头 2 中保存的散列值 H2 就是根据它前面的区块 1 的区块头 1 计算出来的。此外，区块头中还保存着“本区块所有交易的整体散列值”，如图所示，区块头 2 中的散列值 T2 就是根据区块 2 中记录的所有交易数据计算出的散列值。也就是说，一旦对区块链中的数据进行任何改动，都需要重建所改动的区块之后的所有区块的数据，由此可见，区块头中的两个散列值有效增加了篡改区块链数据的难度。</p>
<p>区块头中还保存着一个名为 nonce 的任意数值，以及时间戳等信息。</p>
<p>（6）交易：所谓交易，就是对“从一个地址向另一个地址转移了多少比特币”这一事件的描述。举一个例子，假设 Alice 从 Bob 商店购买了商品，需要向 Bob 商店支付 1 BTC 的贷款。</p>
<pre><code>Bob 商店创建公钥密钥对（公钥 B 和私钥 b）
Bob 商店根据公钥 B 生成地址 B，并发送给 Alice
Alice 创建公钥密钥对（公钥 A 和私钥 a）
Alice 创建交易：“从地址 A 向地址 B 发送 1 BTC”。此时，Alice 使用私钥 a 对交易签署
了数字签名。
Alice将这条交易发送至 P2P 网络，即向全世界广播这条交易。
随后，Alice 创建的交易与其他一些交易一起被合并为一个区块，并添加到区块链中。
添加的区块被 P2P 网络确认后，“从地址 A 向地址 B 发送 1 BTC”的交易就成立了。
</code></pre><p>此时，外界并不知道“A 是 Alice 的地址，B 是 Bob 商店的地址”，但是 Alice 需要向 Bob 商店付款，Bob 商店也需要从 Alice 处收款，因此这条交易到底是谁把钱付给谁，至少 Alice 和 Bob 商店是要知道的。Alice 和 Bob 商店之间的身份确认，需要通过社交网络、电子邮件、网站等比特币系统之外的渠道进行。</p>
<p>当交易被合并到区块，并被添加到区块链后，地址 A 能够支付的金额就减少了 1 BTC，而地址 B 能够支付的金额则增加了 1 BTC。</p>
<p>在创建交易时运用了数字签名技术，比特币中使用的数字签名算法为椭圆曲线 DSA，其中使用的椭圆曲线方程为 x<sup>2</sup> = y<sup>3</sup> + 7</p>
<p>（7）挖矿：随着全世界的比特币不断增加，区块链也会随之不断增长，这就意味着 P2P 网络中的“某个人”在负责将新的区块添加到区块链。“将新的区块添加到区块链”这一行为，正好就相当于“创造新的比特币余额”。向区块链添加区块就好像从金矿中挖出比特币一样，因此称为<strong>挖矿</strong>，而从事挖矿的人则称为<strong>矿工</strong>。</p>
<p>由于区块链是一条单链，因此在某个特定的时间点只能向其中添加一个区块，按照比特币协议的规定，成功将区块添加到区块链的矿工，将获得挖矿奖励以及该区块所有交易的<strong>手续费</strong>（transaction fee）。</p>
<p>为了防止比特币被伪造，矿工必须证明自己确实完成了规定量的工作，这种证明被称为<strong>工作量证明</strong>（Proof of Work，PoW），工作量证明是通过散列值来实现的。</p>
<p>要向区块链添加新的区块，矿工需要生成合法的区块头，而且区块头中“前一区块的散列值”的格式是有规定的，它的前面的若干个比特必须为 0 。上图中的散列值 H2 可能是下面这样的值。</p>
<pre><code>00000000000000007780B6F7B32254538D2DA45DE67777
</code></pre><p>区块头中之所以需要一个称为 nonce 的任意数值，就是为了凑出像上面这样前面若干比特都是 0 的散列值，也就是说，矿工需要不断更换 nonce 进行尝试，直到计算出符合要求的散列值为止。</p>
<p>这个过程实际上和暴力破解单向散列函数十分相似，这只是为了证明某个矿工确实投入了大量的计算资源来完成工作。比特币系统中大约每 10 分钟会添加一个新的区块，为了保持这样的恒定速率，计算的难度会不断地调整。</p>
<p>（8）确认：由于全世界有大量的矿工在不断尝试添加新的区块，因此如果在某一时间点上有多个矿工同时计算出了符合要求的散列值，区块链就可能产生分支。由于比特币是一个 P2P 网络，因此无法确定是哪一个区块先达到的节点，比如节点 1 可能先收到区块 A，节点 2 可能先收到 区块 B ，这样就会造成节点 1 和节点 2 的区块链产生差异。到底哪个区块才应该被添加到区块中呢？P2P 网络需要对此作出判断，这个动作称为确认。当产生分支时，P2P 网络的各个节点会选择计算量大的分支继续工作，从而抑制区块链继续产生分支。比特币系统假设善意的矿工所拥有的计算资源要大于恶意的矿工所拥有的计算资源，这也就是比特币系统得以正常运转的前提。</p>
<p>（9）匿名性：我们需要正确理解比特币的匿名性，诚然，在钱包中生成地址时，我们不需要将这个地址和自己的身份进行关联，也没有必要把自己的身份告诉交易对象，从这点来看，比特币交易的确是匿名的。</p>
<p>然而，之前的讲解有提到，某个地址所进行的交易会公开给全世界所有用户，而且交易记录也会近似永远留在区块链上，因此，通常用户不会同一个地址反复进行交易。</p>
<p>此外，商品交易中本来就需要一定程度上公开身份信息，不然你也没办法收到商品。而且，P2P 网络的性质决定了某条交易所对应的节点 IP 是需要被记录的，这也产生了一定的风险。</p>
<p>（10）信任的意义：</p>
<p>比特币系统具有以下三层含义的信任：</p>
<pre><code>信任使用比特币进行交易的对象
信任比特币交易所
信任比特币系统
</code></pre><p>“信任使用比特币进行交易的对象”与信任使用现金进行交易的对象是差不多的。</p>
<p>“信任比特币交易所”与信任存款的银行是差不多的。</p>
<p>“信任比特币系统”相当于信任比特币所使用的密码技术以及用于实现这些密码技术的钱包等软件。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">比特币</th>
<th style="text-align:center">单位(缩写)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">bitcoin(BTC)</td>
</tr>
<tr>
<td style="text-align:center">0.01</td>
<td style="text-align:center">bitcent(cBTC)</td>
</tr>
<tr>
<td style="text-align:center">0.001</td>
<td style="text-align:center">millibitcoin(mBTC)</td>
</tr>
<tr>
<td style="text-align:center">0.0000001</td>
<td style="text-align:center">microbitcoin(uBTC)</td>
</tr>
<tr>
<td style="text-align:center">0.00000001</td>
<td style="text-align:center">satoshi</td>
</tr>
</tbody>
</table>
<ul>
<li><p>量子密码：是基于量子理论的通信技术，由 Bennett 和 Brassard 与 20 世纪 80 年代提出，严格来说，并没有直接构成一种密码体系，而是一种让通信本身不可窃听的技术，可以理解是一种利用光子的量子特性来实现通信的方法。</p>
<pre><code>利用了下列两个事实：
（1）从原理上说，无法准确测出光子的偏振方向
     根据这一事实，可以让窃听得到的内容变得不正确
（2）测量行为本身会导致光子的状态发生改变
     根据这一事实，接受者可以判断通信是否被窃听
</code></pre><p>一次性密码本的最大问题在于难以发送和明文具有相同长度的大量密钥，然而如果使用量子密码来发送密钥，接受者就可以识别出密钥是否被窃听，量子密码让一次性密码本的实现更进了一步。</p>
<p>量子密码有很多方法正在研究之中，BB84 协议用 4 个量子状态代表 1 比特的信息，B92 协议用 2 个量子状态代表 1 比特的信息，E91 协议和 BB84 协议等价，但它采用相互纠缠（entangled）的一对光子来实现的，量子纠缠是一种量子现象，只要测定其中一个量子的状态，就可以确定相距很远的另一个光子的状态。</p>
<p>（1）量子计算机：由英国物理学家 David Deutsch 于 1985 年提出，根据量子理论，粒子可同时具有多种状态，如果使用具有多种状态的粒子进行计算，则可以同时完成多种状态的计算。如果一个粒子能够计算 0 或 1 两种状态，那么 128 个这样的粒子就可以同时计算 2<sup>128</sup> 种状态，换句话说，这就是一台超级并行计算机。目前量子计算机还未达到实用的程度，但相关研究正在如火如荼开展。</p>
<p>（2）量子密码与量子计算机：如果量子密码比量子计算机先进入实用领域，则可以使用量子密码来实现一次性密码本，从而产生完美的密码技术，由于一次性密码本是无法破译的，因此即便使用量子计算机也无法破译，即便它快速完成暴力破解，也无法判断到底哪一个才是正确的密钥。</p>
<p>如果量子计算机比量子密码先进入使用领域，则使用目前的密码技术所产生的密文将会全部被破译。</p>
<p>在量子计算机出现后依然能够抵抗破译的密码称为<strong>耐量子密码</strong>或者<strong>后量子密码</strong>（Post-Quantum Cryptography，PQCrypto ），其中有一种算法叫做<strong>多变量公钥密码</strong>（Multivariate Public Key Cryptosystem），它利用的是 NP 完全问题的复杂度。</p>
</li>
<li><p>人是密码技术中最大的弱点：</p>
<p>（1）采用生物信息的认证技术（<strong>生物识别认证</strong>，biometric authentication）也并不是完美的认证，要进行生物识别认证，就必须在某个时间点上将生物信息转换为比特序列，实际的认证是通过转换后的比特序列来完成的，一旦比特序列被窃取，就会和钥匙被偷产生相同的后果。</p>
<p>（2）防御必须天衣无缝，攻击只需突破一点。</p>
<p>（3）社会工程学（social enginneering）攻击，<strong>信息安全在于流程而非产品</strong>，不能因为购买了安全产品就认为可以高枕无忧了，还必须让系统相关的所有人员保持较高的安全意识。</p>
<p>（4）拒绝服务攻击（Denial of Service Attack），也称为 <strong>DoS 攻击</strong>，拒绝服务攻击是一种针对服务<strong>可用性</strong>（availablility）的攻击方式。拒绝服务攻击并非只是无法使用服务这么简单，当安全性较高的服务瘫痪时，用户往往会自发地转移到安全性较低的服务，通过拒绝服务攻击，可以让窃听等其他攻击更加容易。</p>
</li>
</ul>
<h2 id="附录、椭圆曲线密码"><a href="#附录、椭圆曲线密码" class="headerlink" title="附录、椭圆曲线密码"></a>附录、椭圆曲线密码</h2><ul>
<li><p>椭圆曲线密码（Elliptic Curve Cryptography，ECC）：是利用椭圆曲线来实现的密码技术的统称，实际上包括以下内容：</p>
<pre><code>基于椭圆曲线的公钥密码
基于椭圆曲线的数字签名
基于椭圆曲线的密钥交换
</code></pre><p>椭圆曲线目前正被广泛使用，例如在 SSL/TLS 中，就使用了椭圆曲线 Diffie-Hellman 密钥交换（ECDH、ECDHE）和椭圆曲线 DSA（ECDSA），比特币中也是用了椭圆曲线 DSA 。</p>
<p><strong>椭圆曲线密码密钥短但强度高</strong>。</p>
<p>椭圆曲线（Elliptic Curve，EC）实际上并不是椭圆形，之所以叫椭圆曲线源自于求椭圆弧长的椭圆积分的反函数。</p>
<p>一般来说，椭圆曲线可用下列方程式表示，其中 <em>a</em> ，<em>b</em> ，<em>c</em> ，<em>d</em> 为系数。</p>
<blockquote>
<p><em>E</em> : <em>y</em> <sup>2</sup> = <em>a**x</em> <sup>3</sup> + <em>b**x</em> <sup>2</sup> + <em>c**x</em> + d</p>
</blockquote>
</li>
<li><p>椭圆曲线运算：</p>
<p>（1）椭圆曲线上的加法运算：过曲线上两点 <em>A</em>，<em>B</em> 画一条直线，找到直线与椭圆曲线的交点，我们将该交点关于 <em>x</em> 轴对称位置的点定义为 <em>A</em> + <em>B</em> 。</p>
<p>（2）椭圆曲线上的二倍运算：若出现两点重合的情况，因为无法画出两点的直线，因此我们画出点 <em>A</em> 的切线，然后找到该切线与椭圆曲线的交点，将该点关于 <em>x</em> 轴对称位置的点定义为 <em>A</em> + <em>A</em> 。</p>
<p>（3）椭圆曲线上的正负取反运算：将点 <em>A</em> 关于 <em>x</em> 轴对称位置的点定义为 -<em>A</em> 。</p>
<p>将 <em>A</em> 和 -<em>A</em> 相加会怎样，根据椭圆曲线的定义，我们应该找到过点 <em>A</em> 和点 -<em>A</em> 的直线与椭圆曲线的交点，但过点 <em>A</em> 和点 -<em>A</em> 的直线与椭圆曲线之间只有点 <em>A</em> 和点 -<em>A</em> 这两个交点，于是我们认为这条直线与椭圆曲线在“无限远点”的位置相交。这个无限远点在图像上画不出来，我们将其记作 <em>O</em> 。可以发现，无限远点 <em>O</em> 的作用和数字 0 相近，<em>A</em> + (-<em>A</em>) = <em>O</em> 是永远成立的。</p>
<p>基于上述运算规则，给定椭圆曲线上的某一点 <em>G</em> ，“已知数 <em>x</em> 求点 <em>xG</em> 的问题”并不困难，反过来，“已知点 <em>xG</em> 求数 <em>x</em> 的问题”则非常困难，这就是椭圆曲线密码中利用的离散对数问题。</p>
</li>
<li><p>椭圆曲线上的离散对数问题：</p>
<p>在椭圆曲线密码中，我们首先确定一条椭圆曲线，然后对椭圆曲线上的某一些点（以及无限远点）之间的“运算”进行定义，并用这些“运算”来进行密码技术相关的计算。</p>
<p>椭圆曲线利用了上述“运算”中“椭圆曲线上的离散对数问题”的复杂度，就像 RSA 利用了“质因数分解”的复杂度，以及 ElGamal 密码和 Diffie-Hellman 密钥交换利用了“有限域上的离散对数问题”的复杂度一样。</p>
<p>椭圆曲线上的离散对数问题（Elliptic Curve Discrete Logarithm Problem，ECDLP），其本质就是“已知点 <em>xG</em> 求数 <em>x</em> 的问题” 。</p>
<pre><code>椭圆曲线上的离散对数问题：
已知：
椭圆曲线 *E*
椭圆曲线 *E* 上的一点 *G*（基点）
椭圆曲线 *E* 上的一点 *xG* （*G* 的 *x* 倍）
求：
数 *x*
</code></pre></li>
<li><p>有限域上的椭圆曲线运算：</p>
<p>其实椭圆曲线密码所使用的椭圆曲线运算，并不是在之前所讲的那种光滑曲线上进行的。</p>
<p>椭圆曲线上的图像要形成一条光滑的曲线，其坐标 <em>x</em>，<em>y</em> 必须都是实数，即“实数域 R 上的椭圆曲线”。</p>
<p>椭圆曲线密码所使用的椭圆曲线并非是在实数域 R 上，而是在有限域 F<sub>p</sub> 上。有限域 F<sub>p</sub> 是指对于某个给定的质数 <em>p</em> ，由 0，1，…, <em>p</em> -1 共 <em>p</em> 个元素所组成的整数集合中定义的加减乘除运算。有限域中的运算就是之间介绍的时钟运算，更直观一点就是用整数来计算坐标，并将结果除以 <em>p</em> 求余数。</p>
<blockquote>
<p>实数域 R 上的光滑椭圆曲线：</p>
</blockquote>
<blockquote>
<p><em>E</em> : <em>y</em> <sup>2</sup> = <em>x</em> <sup>3</sup> + <em>x</em> <sup>2</sup> + 1</p>
</blockquote>
<blockquote>
<p>有限域 F<sub>p</sub> 上的椭圆曲线：</p>
</blockquote>
<blockquote>
<p><em>E</em> : <em>y</em> <sup>2</sup> ≡ <em>x</em> <sup>3</sup> + <em>x</em> <sup>2</sup> + 1（mod 23）</p>
</blockquote>
</li>
<li><p>椭圆曲线 Diffie-Hellman 密钥交换：除了运用椭圆曲线这一点之外，它的流程与 Diffie-Hellman 密钥交换基本上是相同的。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fmsv50dxwij30sg0lcdjh.jpg" alt="22"></p>
<p>非椭圆曲线的 Diffie-Hellman 所利用的是：</p>
<blockquote>
<p>以 <em>p</em> 为模， 已知 <em>G</em> 和 <em>G</em><sup><em>x</em></sup> mod <em>p</em> 求 <em>x</em> 的复杂度（有限域上的离散对数问题）</p>
</blockquote>
<p>椭圆曲线 Diffie-Hellman 所利用的是：</p>
<blockquote>
<p>在椭圆曲线上， 已知点 <em>xG</em> 求数 <em>x</em> 的复杂度（椭圆曲线上的离散对数问题）</p>
</blockquote>
<p>交换步骤：</p>
<p>（1）Alice 向 Bob 发送点 <em>G</em> 。点 <em>G</em> 被 Eve 知道也没关系。</p>
<p>（2）Alice 生成随机数 <em>a</em> 。这个数没有必要告诉 Bob ，也不能让 Eve 知道。我们将数 <em>a</em> 称为 Alice 的私钥。</p>
<p>（3）Bob 生成随机数 <em>b</em> 。这个数没有必要告诉 Alice ，也不能让 Eve 知道。我们将数 <em>b</em> 称为 Bob 的私钥。</p>
<p>（4）Alice 向 Bob 发送点 <em>aG</em> 。点 <em>aG</em> 被 Eve 知道也没关系，它是 Alice 的公钥。</p>
<p>（5）Bob 向 Alice 发送点 <em>bG</em> 。点 <em>bG</em> 被 Eve 知道也没关系，它是 Bob 的公钥。</p>
<p>（6）<strong>Alice 对 Bob 发送的点 <em>bG</em> 计算其在椭圆曲线上 <em>a</em> 倍的点</strong>。Alice 在椭圆曲线上计算 <em>a(bG)</em> = <em>abG</em> ，它就是 Alice 与 Bob 的共享密钥。</p>
<p>（7）相对地，<strong>Bob 对 Alice 发送的点 <em>aG</em> 计算其在椭圆曲线上 <em>b</em> 倍的点</strong>。Alice 在椭圆曲线上计算 <em>b(aG)</em> = <em>abG</em> ，它就是 Alice 与 Bob 的共享密钥。</p>
<p>在椭圆曲线 Diffie-Hellman 密钥交换时，生成共享密钥需要使用随机数 <em>a</em>、<em>b</em>。如果每次通信都使用不同的随机数，则共享密钥也会随之改变。这样依赖，即便某个时间点的通信被破解，也无需担心在此之前的通信内容被破解。这样的特性称为<strong>前向安全性</strong>（Forward Secrecy，FS）或者完全前向安全性（Perfect Forward Secrecy，PFS）。 </p>
</li>
<li><p>椭圆曲线 ElGamal 密码：</p>
<p>通过椭圆曲线 Diffie-Hellman 密钥交换，Alice 和 Bob 能够生成共享密钥 <em>abG</em> 。利用共享密钥 <em>abG</em> 就可以很容易地实现椭圆曲线 EIGamal 密码。</p>
<p>假设 Alice 要向 Bob 发送一条消息，Alice 可以将自己要发送的消息用椭圆曲线上的一个点 <em>M</em> 来表示（实际上使用的是该点的 <em>x</em> 坐标）。</p>
<p>加密：</p>
<p>（1）Alice 用自己的私钥 <em>a</em> 以及 Bob 的公钥 <em>bG</em> ，对消息 <em>M</em> 计算点 <em>M</em> + <em>abG</em> 。此点 <em>M</em> + <em>abG</em> 就是密文。</p>
<p>（2）Alice 将密文 <em>M</em> + <em>abG</em> 发送给 Bob 。</p>
<p>解密：</p>
<p>（1）Bob 接受到密文 <em>M</em> + <em>abG</em> 。</p>
<p>（2）Bob 用 Alice 的公钥 <em>aG</em> 以及自己的私钥 <em>b</em> 计算出了共享密钥 <em>abG</em> 。</p>
<p>（3）Bob 将收到的密文 <em>M</em> + <em>abG</em> 减去共享密钥 <em>abG</em> 得到消息 <em>M</em> 。 </p>
</li>
<li><p>椭圆曲线 DSA（ECDSA）：使用椭圆曲线还可以实现数字签名。</p>
<p>假设 Alice 要对消息 <em>m</em> ，而 Bob 需要验证签名。以下写着“计算”的部分都代表以 <em>p</em> 为模的时钟运算。</p>
<blockquote>
<p>生成数字签名：</p>
</blockquote>
<p>（1）Alice 根据随机数 <em>r</em> 和基点 <em>G</em> 求出点 <em>rG</em> =（x，y）。</p>
<p>（2）Alice 根据随机数 <em>r</em> 、消息 <em>m</em> 的散列值 <em>h</em> 、私钥 <em>a</em> 计算  $ s=\frac{h+ax}{r} $ 。</p>
<p>（3）最后，Alice 将消息 <em>m</em> 、点 <em>rG</em> = （x，y）和 s 发送给 Bob，其中点 <em>rG</em> 和 <em>s</em> 就是数字签名</p>
<blockquote>
<p>验证数字签名：</p>
</blockquote>
<p>（1）Bob 接受到消息 <em>m</em> 、点 <em>rG</em> = （x，y）和 <em>s</em> 。</p>
<p>（2）Bob 根据消息 <em>m</em> 求出散列值 <em>h</em> 。</p>
<p>（3）最后，Bob 根据上述消息，用 Alice 的公钥进行一下计算。</p>
<p>$$\frac{h}{s}G+\frac{x}{s}(aG)$$ </p>
<p>并将结果与 <em>rG</em> 进行比较。</p>
<p>如果数字签名正确，则计算结果应如下所示。</p>
<p>$$\frac{h}{s}G+\frac{x}{s}(aG)=\frac{h+ax}{s}G$$<br>$$=\frac{r(h+ax)}{h+ax}G$$<br>$$=rG$$</p>
<p>由于攻击者没有 Alice 私钥，因此无法计算出合法的 <em>s</em> ，此外，即便是对于同一条消息，只要改变随机数 <em>r</em> ，所得带的数字签名也会随之改变。</p>
</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2018/02/25/modern-art/" class="prev">PREV</a><a href="/2017/10/24/1501/" class="next">NEXT</a></div><div class="copyright"></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>